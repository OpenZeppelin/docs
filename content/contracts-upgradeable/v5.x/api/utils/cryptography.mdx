---
title: "Cryptography"
description: "Smart contract cryptography utilities and implementations"
---

<Callout>
This document is better viewed at https://docs.openzeppelin.com/contracts/api/utils/cryptography
</Callout>

A collection of contracts and libraries that implement various signature validation schemes and cryptographic primitives. These utilities enable secure authentication, multisignature operations, and advanced cryptographic operations in smart contracts.

* [`ECDSA`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#ECDSA), [`MessageHashUtils`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#MessageHashUtils): Libraries for interacting with ECDSA signatures.
* [`P256`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#P256): Library for verifying and recovering public keys from secp256r1 signatures.
* [`RSA`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#RSA): Library with RSA PKCS#1 v1.5 signature verification utilities.
* [`SignatureChecker`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#SignatureChecker): A library helper to support regular ECDSA from EOAs as well as ERC-1271 signatures for smart contracts.
* [`Hashes`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#Hashes): Commonly used hash functions.
* [`MerkleProof`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#MerkleProof): Functions for verifying [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree) proofs.
* [`EIP712`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#EIP712): Contract with functions to allow processing signed typed structure data according to [EIP-712](https://eips.ethereum.org/EIPS/eip-712).
* [`ERC7739Utils`](https://docs.openzeppelin.com/contracts/api/token#ERC7739Utils): Utilities library that implements a defensive rehashing mechanism to prevent replayability of smart contract signatures based on ERC-7739.
* [`AbstractSigner`](https://docs.openzeppelin.com/contracts/api/utils#AbstractSigner): Abstract contract for internal signature validation in smart contracts.
* [`ERC7739`](https://docs.openzeppelin.com/contracts/api/token#ERC7739): An abstract contract to validate signatures following the rehashing scheme from [`ERC7739Utils`](https://docs.openzeppelin.com/contracts/api/token#ERC7739Utils).
* [`SignerECDSA`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#SignerECDSA), [`SignerP256`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#SignerP256), [`SignerRSA`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#SignerRSA): Implementations of an [`AbstractSigner`](https://docs.openzeppelin.com/contracts/api/utils#AbstractSigner) with specific signature validation algorithms.
* [`SignerERC7702`](https://docs.openzeppelin.com/contracts/api/utils#SignerERC7702): Implementation of [`AbstractSigner`](https://docs.openzeppelin.com/contracts/api/utils#AbstractSigner) that validates signatures using the contract‚Äôs own address as the signer, useful for delegated accounts following EIP-7702.
* [`SignerERC7913`](https://docs.openzeppelin.com/contracts/api/utils#SignerERC7913), [`MultiSignerERC7913`](https://docs.openzeppelin.com/contracts/api/utils#MultiSignerERC7913), [`MultiSignerERC7913Weighted`](https://docs.openzeppelin.com/contracts/api/utils#MultiSignerERC7913Weighted): Implementations of [`AbstractSigner`](https://docs.openzeppelin.com/contracts/api/utils#AbstractSigner) that validate signatures based on ERC-7913. Including a simple and weighted multisignature scheme.
* [`ERC7913P256Verifier`](https://docs.openzeppelin.com/contracts/api/token#ERC7913P256Verifier), [`ERC7913RSAVerifier`](https://docs.openzeppelin.com/contracts/api/token#ERC7913RSAVerifier): Ready to use ERC-7913 signature verifiers for P256 and RSA keys.

## Utils

[`ECDSA`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#ECDSA)

[`MessageHashUtils`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#MessageHashUtils)

[`P256`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#P256)

[`RSA`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#RSA)

[`SignatureChecker`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#SignatureChecker)

[`Hashes`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#Hashes)

[`MerkleProof`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#MerkleProof)

[`EIP712`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#EIP712)

[`ERC7739Utils`](https://docs.openzeppelin.com/contracts/api/token#ERC7739Utils)

## Abstract Signers

[`AbstractSigner`](https://docs.openzeppelin.com/contracts/api/utils#AbstractSigner)

[`ERC7739`](https://docs.openzeppelin.com/contracts/api/token#ERC7739)

[`SignerECDSA`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#SignerECDSA)

[`SignerP256`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#SignerP256)

[`SignerRSA`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#SignerRSA)

[`SignerERC7702`](https://docs.openzeppelin.com/contracts/api/utils#SignerERC7702)

[`SignerERC7913`](https://docs.openzeppelin.com/contracts/api/utils#SignerERC7913)

[`MultiSignerERC7913`](https://docs.openzeppelin.com/contracts/api/utils#MultiSignerERC7913)

[`MultiSignerERC7913Weighted`](https://docs.openzeppelin.com/contracts/api/utils#MultiSignerERC7913Weighted)

## Verifiers

[`ERC7913P256Verifier`](https://docs.openzeppelin.com/contracts/api/token#ERC7913P256Verifier)

[`ERC7913RSAVerifier`](https://docs.openzeppelin.com/contracts/api/token#ERC7913RSAVerifier)

<a id="EIP712Upgradeable"></a>

## `EIP712Upgradeable` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.4.0/contracts/utils/cryptography/EIP712Upgradeable.sol)

```solidity
import "@openzeppelin/contracts/utils/cryptography/EIP712Upgradeable.sol";
```

[EIP-712](https://eips.ethereum.org/EIPS/eip-712) is a standard for hashing and signing of typed structured data.

The encoding scheme specified in the EIP requires a domain separator and a hash of the typed structured data, whose
encoding is very generic and therefore its implementation in Solidity is not feasible, thus this contract
does not implement the encoding itself. Protocols need to implement the type-specific encoding they need in order to
produce the hash of their typed data using a combination of `abi.encode` and `keccak256`.

This contract implements the EIP-712 domain separator ([`EIP712Upgradeable._domainSeparatorV4`](#EIP712Upgradeable-_domainSeparatorV4--)) that is used as part of the encoding
scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA
([`EIP712Upgradeable._hashTypedDataV4`](#EIP712Upgradeable-_hashTypedDataV4-bytes32-)).

The implementation of the domain separator was designed to be as efficient as possible while still properly updating
the chain id to protect against replay attacks on an eventual fork of the chain.

<Callout>
This contract implements the version of the encoding known as "v4", as implemented by the JSON RPC method
</Callout>
[`eth_signTypedDataV4` in MetaMask](https://docs.metamask.io/guide/signing-data.html).

<Callout>
The upgradeable version of this contract does not use an immutable cache and recomputes the domain separator
</Callout>
each time [`EIP712Upgradeable._domainSeparatorV4`](#EIP712Upgradeable-_domainSeparatorV4--) is called. That is cheaper than accessing a cached version in cold storage.

### Functions
- [__EIP712_init(name, version)](#EIP712Upgradeable-__EIP712_init-string-string-)
- [__EIP712_init_unchained(name, version)](#EIP712Upgradeable-__EIP712_init_unchained-string-string-)
- [_domainSeparatorV4()](#EIP712Upgradeable-_domainSeparatorV4--)
- [_hashTypedDataV4(structHash)](#EIP712Upgradeable-_hashTypedDataV4-bytes32-)
- [eip712Domain()](#EIP712Upgradeable-eip712Domain--)
- [_EIP712Name()](#EIP712Upgradeable-_EIP712Name--)
- [_EIP712Version()](#EIP712Upgradeable-_EIP712Version--)
- [_EIP712NameHash()](#EIP712Upgradeable-_EIP712NameHash--)
- [_EIP712VersionHash()](#EIP712Upgradeable-_EIP712VersionHash--)

#### IERC5267

#### Initializable
- [_checkInitializing()](#Initializable-_checkInitializing--)
- [_disableInitializers()](#Initializable-_disableInitializers--)
- [_getInitializedVersion()](#Initializable-_getInitializedVersion--)
- [_isInitializing()](#Initializable-_isInitializing--)
- [_initializableStorageSlot()](#Initializable-_initializableStorageSlot--)

### Events

#### IERC5267
- [EIP712DomainChanged()](#IERC5267-EIP712DomainChanged--)

#### Initializable
- [Initialized(version)](#Initializable-Initialized-uint64-)

### Errors

#### IERC5267

#### Initializable
- [InvalidInitialization()](#Initializable-InvalidInitialization--)
- [NotInitializing()](#Initializable-NotInitializing--)

<a id="EIP712Upgradeable-__EIP712_init-string-string-"></a>

### `__EIP712_init(string name, string version)`
*internal*

Initializes the domain separator and parameter caches.

The meaning of `name` and `version` is specified in
[EIP-712](https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator):

- `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.
- `version`: the current major version of the signing domain.

<Callout>
These parameters cannot be changed except through a [smart
</Callout>
contract upgrade](learn::upgrading-smart-contracts.mdx).

<a id="EIP712Upgradeable-__EIP712_init_unchained-string-string-"></a>

### `__EIP712_init_unchained(string name, string version)`
*internal*

<a id="EIP712Upgradeable-_domainSeparatorV4--"></a>

### `_domainSeparatorV4() ‚Üí bytes32`
*internal*

Returns the domain separator for the current chain.

<a id="EIP712Upgradeable-_hashTypedDataV4-bytes32-"></a>

### `_hashTypedDataV4(bytes32 structHash) ‚Üí bytes32`
*internal*

Given an already [hashed struct](https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct), this
function returns the hash of the fully encoded EIP712 message for this domain.

This hash can be used together with [`ECDSA.recover`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#ECDSA-recover) to obtain the signer of a message. For example:

```solidity
bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
    keccak256("Mail(address to,string contents)"),
    mailTo,
    keccak256(bytes(mailContents))
)));
address signer = ECDSA.recover(digest, signature);
```

<a id="EIP712Upgradeable-eip712Domain--"></a>

### `eip712Domain() ‚Üí bytes1 fields, string name, string version, uint256 chainId, address verifyingContract, bytes32 salt, uint256[] extensions`
*public*

returns the fields and values that describe the domain separator used by this contract for EIP-712
signature.

<a id="EIP712Upgradeable-_EIP712Name--"></a>

### `_EIP712Name() ‚Üí string`
*internal*

The name parameter for the EIP712 domain.

<Callout>
This function reads from storage by default, but can be redefined to return a constant value if gas costs
</Callout>
are a concern.

<a id="EIP712Upgradeable-_EIP712Version--"></a>

### `_EIP712Version() ‚Üí string`
*internal*

The version parameter for the EIP712 domain.

<Callout>
This function reads from storage by default, but can be redefined to return a constant value if gas costs
</Callout>
are a concern.

<a id="EIP712Upgradeable-_EIP712NameHash--"></a>

### `_EIP712NameHash() ‚Üí bytes32`
*internal*

The hash of the name parameter for the EIP712 domain.

<Callout>
In previous versions this function was virtual. In this version you should override `_EIP712Name` instead.
</Callout>

<a id="EIP712Upgradeable-_EIP712VersionHash--"></a>

### `_EIP712VersionHash() ‚Üí bytes32`
*internal*

The hash of the version parameter for the EIP712 domain.

<Callout>
In previous versions this function was virtual. In this version you should override `_EIP712Version` instead.
</Callout>

<a id="MultiSignerERC7913Upgradeable"></a>

## `MultiSignerERC7913Upgradeable` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.4.0/contracts/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol)

```solidity
import "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";
```

Implementation of [`AbstractSigner`](https://docs.openzeppelin.com/contracts/api/utils#AbstractSigner) using multiple ERC-7913 signers with a threshold-based
signature verification system.

This contract allows managing a set of authorized signers and requires a minimum number of
signatures (threshold) to approve operations. It uses ERC-7913 formatted signers, which
makes it natively compatible with ECDSA and ERC-1271 signers.

Example of usage:

```solidity
contract MyMultiSignerAccount is Account, MultiSignerERC7913, Initializable 
    function initialize(bytes[] memory signers, uint64 threshold) public initializer 
        _addSigners(signers);
        _setThreshold(threshold);
    

    function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf 
        _addSigners(signers);
    

    function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf 
        _removeSigners(signers);
    

    function setThreshold(uint64 threshold) public onlyEntryPointOrSelf 
        _setThreshold(threshold);
    

```

<Callout type='warn'>
Failing to properly initialize the signers and threshold either during construction
</Callout>
(if used standalone) or during initialization (if used as a clone) may leave the contract
either front-runnable or unusable.

### Functions
- [__MultiSignerERC7913_init(signers_, threshold_)](#MultiSignerERC7913Upgradeable-__MultiSignerERC7913_init-bytes---uint64-)
- [__MultiSignerERC7913_init_unchained(signers_, threshold_)](#MultiSignerERC7913Upgradeable-__MultiSignerERC7913_init_unchained-bytes---uint64-)
- [getSigners(start, end)](#MultiSignerERC7913Upgradeable-getSigners-uint64-uint64-)
- [getSignerCount()](#MultiSignerERC7913Upgradeable-getSignerCount--)
- [isSigner(signer)](#MultiSignerERC7913Upgradeable-isSigner-bytes-)
- [threshold()](#MultiSignerERC7913Upgradeable-threshold--)
- [_addSigners(newSigners)](#MultiSignerERC7913Upgradeable-_addSigners-bytes---)
- [_removeSigners(oldSigners)](#MultiSignerERC7913Upgradeable-_removeSigners-bytes---)
- [_setThreshold(newThreshold)](#MultiSignerERC7913Upgradeable-_setThreshold-uint64-)
- [_validateReachableThreshold()](#MultiSignerERC7913Upgradeable-_validateReachableThreshold--)
- [_rawSignatureValidation(hash, signature)](#MultiSignerERC7913Upgradeable-_rawSignatureValidation-bytes32-bytes-)
- [_validateSignatures(hash, signers, signatures)](#MultiSignerERC7913Upgradeable-_validateSignatures-bytes32-bytes---bytes---)
- [_validateThreshold(validatingSigners)](#MultiSignerERC7913Upgradeable-_validateThreshold-bytes---)

#### AbstractSigner

#### Initializable
- [_checkInitializing()](#Initializable-_checkInitializing--)
- [_disableInitializers()](#Initializable-_disableInitializers--)
- [_getInitializedVersion()](#Initializable-_getInitializedVersion--)
- [_isInitializing()](#Initializable-_isInitializing--)
- [_initializableStorageSlot()](#Initializable-_initializableStorageSlot--)

### Events
- [ERC7913SignerAdded(signers)](#MultiSignerERC7913Upgradeable-ERC7913SignerAdded-bytes-)
- [ERC7913SignerRemoved(signers)](#MultiSignerERC7913Upgradeable-ERC7913SignerRemoved-bytes-)
- [ERC7913ThresholdSet(threshold)](#MultiSignerERC7913Upgradeable-ERC7913ThresholdSet-uint64-)

#### AbstractSigner

#### Initializable
- [Initialized(version)](#Initializable-Initialized-uint64-)

### Errors
- [MultiSignerERC7913AlreadyExists(signer)](#MultiSignerERC7913Upgradeable-MultiSignerERC7913AlreadyExists-bytes-)
- [MultiSignerERC7913NonexistentSigner(signer)](#MultiSignerERC7913Upgradeable-MultiSignerERC7913NonexistentSigner-bytes-)
- [MultiSignerERC7913InvalidSigner(signer)](#MultiSignerERC7913Upgradeable-MultiSignerERC7913InvalidSigner-bytes-)
- [MultiSignerERC7913ZeroThreshold()](#MultiSignerERC7913Upgradeable-MultiSignerERC7913ZeroThreshold--)
- [MultiSignerERC7913UnreachableThreshold(signers, threshold)](#MultiSignerERC7913Upgradeable-MultiSignerERC7913UnreachableThreshold-uint64-uint64-)

#### AbstractSigner

#### Initializable
- [InvalidInitialization()](#Initializable-InvalidInitialization--)
- [NotInitializing()](#Initializable-NotInitializing--)

<a id="MultiSignerERC7913Upgradeable-__MultiSignerERC7913_init-bytes---uint64-"></a>

### `__MultiSignerERC7913_init(bytes[] signers_, uint64 threshold_)`
*internal*

<a id="MultiSignerERC7913Upgradeable-__MultiSignerERC7913_init_unchained-bytes---uint64-"></a>

### `__MultiSignerERC7913_init_unchained(bytes[] signers_, uint64 threshold_)`
*internal*

<a id="MultiSignerERC7913Upgradeable-getSigners-uint64-uint64-"></a>

### `getSigners(uint64 start, uint64 end) ‚Üí bytes[]`
*public*

Returns a slice of the set of authorized signers.

Using `start = 0` and `end = type(uint64).max` will return the entire set of signers.

<Callout type='warn'>
Depending on the `start` and `end`, this operation can copy a large amount of data to memory, which
</Callout>
can be expensive. This is designed for view accessors queried without gas fees. Using it in state-changing
functions may become uncallable if the slice grows too large.

<a id="MultiSignerERC7913Upgradeable-getSignerCount--"></a>

### `getSignerCount() ‚Üí uint256`
*public*

Returns the number of authorized signers

<a id="MultiSignerERC7913Upgradeable-isSigner-bytes-"></a>

### `isSigner(bytes signer) ‚Üí bool`
*public*

Returns whether the `signer` is an authorized signer.

<a id="MultiSignerERC7913Upgradeable-threshold--"></a>

### `threshold() ‚Üí uint64`
*public*

Returns the minimum number of signers required to approve a multisignature operation.

<a id="MultiSignerERC7913Upgradeable-_addSigners-bytes---"></a>

### `_addSigners(bytes[] newSigners)`
*internal*

Adds the `newSigners` to those allowed to sign on behalf of this contract.
Internal version without access control.

Requirements:

* Each of `newSigners` must be at least 20 bytes long. Reverts with [`MultiSignerERC7913InvalidSigner`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#MultiSignerERC7913InvalidSigner) if not.
* Each of `newSigners` must not be authorized. See [`MultiSignerERC7913Upgradeable.isSigner`](#MultiSignerERC7913Upgradeable-isSigner-bytes-). Reverts with [`MultiSignerERC7913AlreadyExists`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#MultiSignerERC7913AlreadyExists) if so.

<a id="MultiSignerERC7913Upgradeable-_removeSigners-bytes---"></a>

### `_removeSigners(bytes[] oldSigners)`
*internal*

Removes the `oldSigners` from the authorized signers. Internal version without access control.

Requirements:

* Each of `oldSigners` must be authorized. See [`MultiSignerERC7913Upgradeable.isSigner`](#MultiSignerERC7913Upgradeable-isSigner-bytes-). Otherwise [`MultiSignerERC7913NonexistentSigner`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#MultiSignerERC7913NonexistentSigner) is thrown.
* See [`MultiSignerERC7913Upgradeable._validateReachableThreshold`](#MultiSignerERC7913Upgradeable-_validateReachableThreshold--) for the threshold validation.

<a id="MultiSignerERC7913Upgradeable-_setThreshold-uint64-"></a>

### `_setThreshold(uint64 newThreshold)`
*internal*

Sets the signatures `threshold` required to approve a multisignature operation.
Internal version without access control.

Requirements:

* See [`MultiSignerERC7913Upgradeable._validateReachableThreshold`](#MultiSignerERC7913Upgradeable-_validateReachableThreshold--) for the threshold validation.

<a id="MultiSignerERC7913Upgradeable-_validateReachableThreshold--"></a>

### `_validateReachableThreshold()`
*internal*

Validates the current threshold is reachable.

Requirements:

* The [`MultiSignerERC7913Upgradeable.getSignerCount`](#MultiSignerERC7913Upgradeable-getSignerCount--) must be greater or equal than to the [`MultiSignerERC7913Upgradeable.threshold`](#MultiSignerERC7913Upgradeable-threshold--). Throws
[`MultiSignerERC7913UnreachableThreshold`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#MultiSignerERC7913UnreachableThreshold) if not.

<a id="MultiSignerERC7913Upgradeable-_rawSignatureValidation-bytes32-bytes-"></a>

### `_rawSignatureValidation(bytes32 hash, bytes signature) ‚Üí bool`
*internal*

Decodes, validates the signature and checks the signers are authorized.
See [`MultiSignerERC7913Upgradeable._validateSignatures`](#MultiSignerERC7913Upgradeable-_validateSignatures-bytes32-bytes---bytes---) and [`MultiSignerERC7913Upgradeable._validateThreshold`](#MultiSignerERC7913Upgradeable-_validateThreshold-bytes---) for more details.

Example of signature encoding:

```solidity
// Encode signers (verifier || key)
bytes memory signer1 = abi.encodePacked(verifier1, key1);
bytes memory signer2 = abi.encodePacked(verifier2, key2);

// Order signers by their id
if (keccak256(signer1) > keccak256(signer2)) 
    (signer1, signer2) = (signer2, signer1);
    (signature1, signature2) = (signature2, signature1);


// Assign ordered signers and signatures
bytes[] memory signers = new bytes[](2);
bytes[] memory signatures = new bytes[](2);
signers[0] = signer1;
signatures[0] = signature1;
signers[1] = signer2;
signatures[1] = signature2;

// Encode the multi signature
bytes memory signature = abi.encode(signers, signatures);
```

Requirements:

* The `signature` must be encoded as `abi.encode(signers, signatures)`.

<a id="MultiSignerERC7913Upgradeable-_validateSignatures-bytes32-bytes---bytes---"></a>

### `_validateSignatures(bytes32 hash, bytes[] signers, bytes[] signatures) ‚Üí bool valid`
*internal*

Validates the signatures using the signers and their corresponding signatures.
Returns whether the signers are authorized and the signatures are valid for the given hash.

<Callout type='warn'>
Sorting the signers by their `keccak256` hash will improve the gas efficiency of this function.
</Callout>
See [`SignatureChecker.areValidSignaturesNow(bytes32, bytes[], bytes[])`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#SignatureChecker-areValidSignaturesNow) for more details.

Requirements:

* The `signatures` and `signers` arrays must be equal in length. Returns false otherwise.

<a id="MultiSignerERC7913Upgradeable-_validateThreshold-bytes---"></a>

### `_validateThreshold(bytes[] validatingSigners) ‚Üí bool`
*internal*

Validates that the number of signers meets the [`MultiSignerERC7913Upgradeable.threshold`](#MultiSignerERC7913Upgradeable-threshold--) requirement.
Assumes the signers were already validated. See [`MultiSignerERC7913Upgradeable._validateSignatures`](#MultiSignerERC7913Upgradeable-_validateSignatures-bytes32-bytes---bytes---) for more details.

<a id="MultiSignerERC7913Upgradeable-ERC7913SignerAdded-bytes-"></a>

### `ERC7913SignerAdded(bytes indexed signers)`
*event*

Emitted when a signer is added.

<a id="MultiSignerERC7913Upgradeable-ERC7913SignerRemoved-bytes-"></a>

### `ERC7913SignerRemoved(bytes indexed signers)`
*event*

Emitted when a signers is removed.

<a id="MultiSignerERC7913Upgradeable-ERC7913ThresholdSet-uint64-"></a>

### `ERC7913ThresholdSet(uint64 threshold)`
*event*

Emitted when the threshold is updated.

<a id="MultiSignerERC7913Upgradeable-MultiSignerERC7913AlreadyExists-bytes-"></a>

### `MultiSignerERC7913AlreadyExists(bytes signer)`
*error*

The `signer` already exists.

<a id="MultiSignerERC7913Upgradeable-MultiSignerERC7913NonexistentSigner-bytes-"></a>

### `MultiSignerERC7913NonexistentSigner(bytes signer)`
*error*

The `signer` does not exist.

<a id="MultiSignerERC7913Upgradeable-MultiSignerERC7913InvalidSigner-bytes-"></a>

### `MultiSignerERC7913InvalidSigner(bytes signer)`
*error*

The `signer` is less than 20 bytes long.

<a id="MultiSignerERC7913Upgradeable-MultiSignerERC7913ZeroThreshold--"></a>

### `MultiSignerERC7913ZeroThreshold()`
*error*

The `threshold` is zero.

<a id="MultiSignerERC7913Upgradeable-MultiSignerERC7913UnreachableThreshold-uint64-uint64-"></a>

### `MultiSignerERC7913UnreachableThreshold(uint64 signers, uint64 threshold)`
*error*

The `threshold` is unreachable given the number of `signers`.

<a id="MultiSignerERC7913WeightedUpgradeable"></a>

## `MultiSignerERC7913WeightedUpgradeable` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.4.0/contracts/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol)

```solidity
import "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";
```

Extension of [`MultiSignerERC7913`](https://docs.openzeppelin.com/contracts/api/utils#MultiSignerERC7913) that supports weighted signatures.

This contract allows assigning different weights to each signer, enabling more
flexible governance schemes. For example, some signers could have higher weight
than others, allowing for weighted voting or prioritized authorization.

Example of usage:

```solidity
contract MyWeightedMultiSignerAccount is Account, MultiSignerERC7913Weighted, Initializable 
    function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold) public initializer 
        _addSigners(signers);
        _setSignerWeights(signers, weights);
        _setThreshold(threshold);
    

    function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf 
        _addSigners(signers);
    

    function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf 
        _removeSigners(signers);
    

    function setThreshold(uint64 threshold) public onlyEntryPointOrSelf 
        _setThreshold(threshold);
    

    function setSignerWeights(bytes[] memory signers, uint64[] memory weights) public onlyEntryPointOrSelf 
        _setSignerWeights(signers, weights);
    

```

<Callout type='warn'>
When setting a threshold value, ensure it matches the scale used for signer weights.
</Callout>
For example, if signers have weights like 1, 2, or 3, then a threshold of 4 would require at
least two signers (e.g., one with weight 1 and one with weight 3). See [`MultiSignerERC7913WeightedUpgradeable.signerWeight`](#MultiSignerERC7913WeightedUpgradeable-signerWeight-bytes-).

### Functions
- [__MultiSignerERC7913Weighted_init(signers_, weights_, threshold_)](#MultiSignerERC7913WeightedUpgradeable-__MultiSignerERC7913Weighted_init-bytes---uint64---uint64-)
- [__MultiSignerERC7913Weighted_init_unchained(signers_, weights_, threshold_)](#MultiSignerERC7913WeightedUpgradeable-__MultiSignerERC7913Weighted_init_unchained-bytes---uint64---uint64-)
- [signerWeight(signer)](#MultiSignerERC7913WeightedUpgradeable-signerWeight-bytes-)
- [totalWeight()](#MultiSignerERC7913WeightedUpgradeable-totalWeight--)
- [_setSignerWeights(signers, weights)](#MultiSignerERC7913WeightedUpgradeable-_setSignerWeights-bytes---uint64---)
- [_addSigners(newSigners)](#MultiSignerERC7913WeightedUpgradeable-_addSigners-bytes---)
- [_removeSigners(signers)](#MultiSignerERC7913WeightedUpgradeable-_removeSigners-bytes---)
- [_validateReachableThreshold()](#MultiSignerERC7913WeightedUpgradeable-_validateReachableThreshold--)
- [_validateThreshold(signers)](#MultiSignerERC7913WeightedUpgradeable-_validateThreshold-bytes---)

#### MultiSignerERC7913Upgradeable
- [__MultiSignerERC7913_init(signers_, threshold_)](#MultiSignerERC7913Upgradeable-__MultiSignerERC7913_init-bytes---uint64-)
- [__MultiSignerERC7913_init_unchained(signers_, threshold_)](#MultiSignerERC7913Upgradeable-__MultiSignerERC7913_init_unchained-bytes---uint64-)
- [getSigners(start, end)](#MultiSignerERC7913Upgradeable-getSigners-uint64-uint64-)
- [getSignerCount()](#MultiSignerERC7913Upgradeable-getSignerCount--)
- [isSigner(signer)](#MultiSignerERC7913Upgradeable-isSigner-bytes-)
- [threshold()](#MultiSignerERC7913Upgradeable-threshold--)
- [_setThreshold(newThreshold)](#MultiSignerERC7913Upgradeable-_setThreshold-uint64-)
- [_rawSignatureValidation(hash, signature)](#MultiSignerERC7913Upgradeable-_rawSignatureValidation-bytes32-bytes-)
- [_validateSignatures(hash, signers, signatures)](#MultiSignerERC7913Upgradeable-_validateSignatures-bytes32-bytes---bytes---)

#### AbstractSigner

#### Initializable
- [_checkInitializing()](#Initializable-_checkInitializing--)
- [_disableInitializers()](#Initializable-_disableInitializers--)
- [_getInitializedVersion()](#Initializable-_getInitializedVersion--)
- [_isInitializing()](#Initializable-_isInitializing--)
- [_initializableStorageSlot()](#Initializable-_initializableStorageSlot--)

### Events
- [ERC7913SignerWeightChanged(signer, weight)](#MultiSignerERC7913WeightedUpgradeable-ERC7913SignerWeightChanged-bytes-uint64-)

#### MultiSignerERC7913Upgradeable
- [ERC7913SignerAdded(signers)](#MultiSignerERC7913Upgradeable-ERC7913SignerAdded-bytes-)
- [ERC7913SignerRemoved(signers)](#MultiSignerERC7913Upgradeable-ERC7913SignerRemoved-bytes-)
- [ERC7913ThresholdSet(threshold)](#MultiSignerERC7913Upgradeable-ERC7913ThresholdSet-uint64-)

#### AbstractSigner

#### Initializable
- [Initialized(version)](#Initializable-Initialized-uint64-)

### Errors
- [MultiSignerERC7913WeightedInvalidWeight(signer, weight)](#MultiSignerERC7913WeightedUpgradeable-MultiSignerERC7913WeightedInvalidWeight-bytes-uint64-)
- [MultiSignerERC7913WeightedMismatchedLength()](#MultiSignerERC7913WeightedUpgradeable-MultiSignerERC7913WeightedMismatchedLength--)

#### MultiSignerERC7913Upgradeable
- [MultiSignerERC7913AlreadyExists(signer)](#MultiSignerERC7913Upgradeable-MultiSignerERC7913AlreadyExists-bytes-)
- [MultiSignerERC7913NonexistentSigner(signer)](#MultiSignerERC7913Upgradeable-MultiSignerERC7913NonexistentSigner-bytes-)
- [MultiSignerERC7913InvalidSigner(signer)](#MultiSignerERC7913Upgradeable-MultiSignerERC7913InvalidSigner-bytes-)
- [MultiSignerERC7913ZeroThreshold()](#MultiSignerERC7913Upgradeable-MultiSignerERC7913ZeroThreshold--)
- [MultiSignerERC7913UnreachableThreshold(signers, threshold)](#MultiSignerERC7913Upgradeable-MultiSignerERC7913UnreachableThreshold-uint64-uint64-)

#### AbstractSigner

#### Initializable
- [InvalidInitialization()](#Initializable-InvalidInitialization--)
- [NotInitializing()](#Initializable-NotInitializing--)

<a id="MultiSignerERC7913WeightedUpgradeable-__MultiSignerERC7913Weighted_init-bytes---uint64---uint64-"></a>

### `__MultiSignerERC7913Weighted_init(bytes[] signers_, uint64[] weights_, uint64 threshold_)`
*internal*

<a id="MultiSignerERC7913WeightedUpgradeable-__MultiSignerERC7913Weighted_init_unchained-bytes---uint64---uint64-"></a>

### `__MultiSignerERC7913Weighted_init_unchained(bytes[] signers_, uint64[] weights_, uint64 threshold_)`
*internal*

<a id="MultiSignerERC7913WeightedUpgradeable-signerWeight-bytes-"></a>

### `signerWeight(bytes signer) ‚Üí uint64`
*public*

Gets the weight of a signer. Returns 0 if the signer is not authorized.

<a id="MultiSignerERC7913WeightedUpgradeable-totalWeight--"></a>

### `totalWeight() ‚Üí uint64`
*public*

Gets the total weight of all signers.

<a id="MultiSignerERC7913WeightedUpgradeable-_setSignerWeights-bytes---uint64---"></a>

### `_setSignerWeights(bytes[] signers, uint64[] weights)`
*internal*

Sets weights for multiple signers at once. Internal version without access control.

Requirements:

* `signers` and `weights` arrays must have the same length. Reverts with [`MultiSignerERC7913WeightedMismatchedLength`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#MultiSignerERC7913WeightedMismatchedLength) on mismatch.
* Each signer must exist in the set of authorized signers. Otherwise reverts with [`MultiSignerERC7913NonexistentSigner`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#MultiSignerERC7913NonexistentSigner)
* Each weight must be greater than 0. Otherwise reverts with [`MultiSignerERC7913WeightedInvalidWeight`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#MultiSignerERC7913WeightedInvalidWeight)
* See [`MultiSignerERC7913Upgradeable._validateReachableThreshold`](#MultiSignerERC7913Upgradeable-_validateReachableThreshold--) for the threshold validation.

Emits [`ERC7913SignerWeightChanged`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#ERC7913SignerWeightChanged) for each signer.

<a id="MultiSignerERC7913WeightedUpgradeable-_addSigners-bytes---"></a>

### `_addSigners(bytes[] newSigners)`
*internal*

See [`MultiSignerERC7913._addSigners`](https://docs.openzeppelin.com/contracts/api/utils#MultiSignerERC7913-addSigners).

In cases where [`MultiSignerERC7913WeightedUpgradeable.totalWeight`](#MultiSignerERC7913WeightedUpgradeable-totalWeight--) is almost `type(uint64).max` (due to a large `_totalExtraWeight`), adding new
signers could cause the [`MultiSignerERC7913WeightedUpgradeable.totalWeight`](#MultiSignerERC7913WeightedUpgradeable-totalWeight--) computation to overflow. Adding a [`MultiSignerERC7913WeightedUpgradeable.totalWeight`](#MultiSignerERC7913WeightedUpgradeable-totalWeight--) calls after the new
signers are added ensures no such overflow happens.

<a id="MultiSignerERC7913WeightedUpgradeable-_removeSigners-bytes---"></a>

### `_removeSigners(bytes[] signers)`
*internal*

See [`MultiSignerERC7913._removeSigners`](https://docs.openzeppelin.com/contracts/api/utils#MultiSignerERC7913-removeSigners).

Just like [`MultiSignerERC7913Upgradeable._addSigners`](#MultiSignerERC7913Upgradeable-_addSigners-bytes---), this function does not emit [`ERC7913SignerWeightChanged`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#ERC7913SignerWeightChanged) events. The
[`ERC7913SignerRemoved`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#ERC7913SignerRemoved) event emitted by [`MultiSignerERC7913._removeSigners`](https://docs.openzeppelin.com/contracts/api/utils#MultiSignerERC7913-removeSigners) is enough to track weights here.

<a id="MultiSignerERC7913WeightedUpgradeable-_validateReachableThreshold--"></a>

### `_validateReachableThreshold()`
*internal*

Sets the threshold for the multisignature operation. Internal version without access control.

Requirements:

* The [`MultiSignerERC7913WeightedUpgradeable.totalWeight`](#MultiSignerERC7913WeightedUpgradeable-totalWeight--) must be `>=` the [`MultiSignerERC7913Upgradeable.threshold`](#MultiSignerERC7913Upgradeable-threshold--). Otherwise reverts with [`MultiSignerERC7913UnreachableThreshold`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#MultiSignerERC7913UnreachableThreshold)

<Callout>
This function intentionally does not call `super._validateReachableThreshold` because the base implementation
</Callout>
assumes each signer has a weight of 1, which is a subset of this weighted implementation. Consider that multiple
implementations of this function may exist in the contract, so important side effects may be missed
depending on the linearization order.

<a id="MultiSignerERC7913WeightedUpgradeable-_validateThreshold-bytes---"></a>

### `_validateThreshold(bytes[] signers) ‚Üí bool`
*internal*

Validates that the total weight of signers meets the threshold requirement.

<Callout>
This function intentionally does not call `super._validateThreshold` because the base implementation
</Callout>
assumes each signer has a weight of 1, which is a subset of this weighted implementation. Consider that multiple
implementations of this function may exist in the contract, so important side effects may be missed
depending on the linearization order.

<a id="MultiSignerERC7913WeightedUpgradeable-ERC7913SignerWeightChanged-bytes-uint64-"></a>

### `ERC7913SignerWeightChanged(bytes indexed signer, uint64 weight)`
*event*

Emitted when a signer's weight is changed.

<Callout>
Not emitted in [`MultiSignerERC7913Upgradeable._addSigners`](#MultiSignerERC7913Upgradeable-_addSigners-bytes---) or [`MultiSignerERC7913Upgradeable._removeSigners`](#MultiSignerERC7913Upgradeable-_removeSigners-bytes---). Indexers must rely on [`ERC7913SignerAdded`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#ERC7913SignerAdded)
</Callout>
and [`ERC7913SignerRemoved`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#ERC7913SignerRemoved) to index a default weight of 1. See [`MultiSignerERC7913WeightedUpgradeable.signerWeight`](#MultiSignerERC7913WeightedUpgradeable-signerWeight-bytes-).

<a id="MultiSignerERC7913WeightedUpgradeable-MultiSignerERC7913WeightedInvalidWeight-bytes-uint64-"></a>

### `MultiSignerERC7913WeightedInvalidWeight(bytes signer, uint64 weight)`
*error*

Thrown when a signer's weight is invalid.

<a id="MultiSignerERC7913WeightedUpgradeable-MultiSignerERC7913WeightedMismatchedLength--"></a>

### `MultiSignerERC7913WeightedMismatchedLength()`
*error*

Thrown when the arrays lengths don't match. See [`MultiSignerERC7913WeightedUpgradeable._setSignerWeights`](#MultiSignerERC7913WeightedUpgradeable-_setSignerWeights-bytes---uint64---).

<a id="SignerECDSAUpgradeable"></a>

## `SignerECDSAUpgradeable` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.4.0/contracts/utils/cryptography/signers/SignerECDSAUpgradeable.sol)

```solidity
import "@openzeppelin/contracts/utils/cryptography/signers/SignerECDSAUpgradeable.sol";
```

Implementation of [`AbstractSigner`](https://docs.openzeppelin.com/contracts/api/utils#AbstractSigner) using [ECDSA](api:utils/cryptography#ECDSA) signatures.

For [`Account`](https://docs.openzeppelin.com/contracts/api/account#Account) usage, a [`SignerECDSAUpgradeable._setSigner`](#SignerECDSAUpgradeable-_setSigner-address-) function is provided to set the [`SignerECDSAUpgradeable.signer`](#SignerECDSAUpgradeable-signer--) address.
Doing so is easier for a factory, who is likely to use initializable clones of this contract.

Example of usage:

```solidity
contract MyAccountECDSA is Account, SignerECDSA, Initializable 
    function initialize(address signerAddr) public initializer 
      _setSigner(signerAddr);
    

```

<Callout type='warn'>
Failing to call [`SignerECDSAUpgradeable._setSigner`](#SignerECDSAUpgradeable-_setSigner-address-) either during construction (if used standalone)
</Callout>
or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.

### Functions
- [__SignerECDSA_init(signerAddr)](#SignerECDSAUpgradeable-__SignerECDSA_init-address-)
- [__SignerECDSA_init_unchained(signerAddr)](#SignerECDSAUpgradeable-__SignerECDSA_init_unchained-address-)
- [_setSigner(signerAddr)](#SignerECDSAUpgradeable-_setSigner-address-)
- [signer()](#SignerECDSAUpgradeable-signer--)
- [_rawSignatureValidation(hash, signature)](#SignerECDSAUpgradeable-_rawSignatureValidation-bytes32-bytes-)

#### AbstractSigner

#### Initializable
- [_checkInitializing()](#Initializable-_checkInitializing--)
- [_disableInitializers()](#Initializable-_disableInitializers--)
- [_getInitializedVersion()](#Initializable-_getInitializedVersion--)
- [_isInitializing()](#Initializable-_isInitializing--)
- [_initializableStorageSlot()](#Initializable-_initializableStorageSlot--)

### Events

#### AbstractSigner

#### Initializable
- [Initialized(version)](#Initializable-Initialized-uint64-)

### Errors

#### AbstractSigner

#### Initializable
- [InvalidInitialization()](#Initializable-InvalidInitialization--)
- [NotInitializing()](#Initializable-NotInitializing--)

<a id="SignerECDSAUpgradeable-__SignerECDSA_init-address-"></a>

### `__SignerECDSA_init(address signerAddr)`
*internal*

<a id="SignerECDSAUpgradeable-__SignerECDSA_init_unchained-address-"></a>

### `__SignerECDSA_init_unchained(address signerAddr)`
*internal*

<a id="SignerECDSAUpgradeable-_setSigner-address-"></a>

### `_setSigner(address signerAddr)`
*internal*

Sets the signer with the address of the native signer. This function should be called during construction
or through an initializer.

<a id="SignerECDSAUpgradeable-signer--"></a>

### `signer() ‚Üí address`
*public*

Return the signer's address.

<a id="SignerECDSAUpgradeable-_rawSignatureValidation-bytes32-bytes-"></a>

### `_rawSignatureValidation(bytes32 hash, bytes signature) ‚Üí bool`
*internal*

Signature validation algorithm.

<Callout type='warn'>
Implementing a signature validation algorithm is a security-sensitive operation as it involves
</Callout>
cryptographic verification. It is important to review and test thoroughly before deployment. Consider
using one of the signature verification libraries ([ECDSA](api:utils/cryptography#ECDSA),
[P256](api:utils/cryptography#P256) or [RSA](api:utils/cryptography#RSA)).

<a id="SignerERC7913Upgradeable"></a>

## `SignerERC7913Upgradeable` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.4.0/contracts/utils/cryptography/signers/SignerERC7913Upgradeable.sol)

```solidity
import "@openzeppelin/contracts/utils/cryptography/signers/SignerERC7913Upgradeable.sol";
```

Implementation of [`AbstractSigner`](https://docs.openzeppelin.com/contracts/api/utils#AbstractSigner) using
[ERC-7913](https://eips.ethereum.org/EIPS/eip-7913) signature verification.

For [`Account`](https://docs.openzeppelin.com/contracts/api/account#Account) usage, a [`SignerECDSAUpgradeable._setSigner`](#SignerECDSAUpgradeable-_setSigner-address-) function is provided to set the ERC-7913 formatted [`SignerECDSAUpgradeable.signer`](#SignerECDSAUpgradeable-signer--).
Doing so is easier for a factory, who is likely to use initializable clones of this contract.

The signer is a `bytes` object that concatenates a verifier address and a key: `verifier || key`.

Example of usage:

```solidity
contract MyAccountERC7913 is Account, SignerERC7913, Initializable 
    function initialize(bytes memory signer_) public initializer 
      _setSigner(signer_);
    

    function setSigner(bytes memory signer_) public onlyEntryPointOrSelf 
      _setSigner(signer_);
    

```

<Callout type='warn'>
Failing to call [`SignerECDSAUpgradeable._setSigner`](#SignerECDSAUpgradeable-_setSigner-address-) either during construction (if used standalone)
</Callout>
or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.

### Functions
- [__SignerERC7913_init(signer_)](#SignerERC7913Upgradeable-__SignerERC7913_init-bytes-)
- [__SignerERC7913_init_unchained(signer_)](#SignerERC7913Upgradeable-__SignerERC7913_init_unchained-bytes-)
- [signer()](#SignerERC7913Upgradeable-signer--)
- [_setSigner(signer_)](#SignerERC7913Upgradeable-_setSigner-bytes-)
- [_rawSignatureValidation(hash, signature)](#SignerERC7913Upgradeable-_rawSignatureValidation-bytes32-bytes-)

#### AbstractSigner

#### Initializable
- [_checkInitializing()](#Initializable-_checkInitializing--)
- [_disableInitializers()](#Initializable-_disableInitializers--)
- [_getInitializedVersion()](#Initializable-_getInitializedVersion--)
- [_isInitializing()](#Initializable-_isInitializing--)
- [_initializableStorageSlot()](#Initializable-_initializableStorageSlot--)

### Events

#### AbstractSigner

#### Initializable
- [Initialized(version)](#Initializable-Initialized-uint64-)

### Errors

#### AbstractSigner

#### Initializable
- [InvalidInitialization()](#Initializable-InvalidInitialization--)
- [NotInitializing()](#Initializable-NotInitializing--)

<a id="SignerERC7913Upgradeable-__SignerERC7913_init-bytes-"></a>

### `__SignerERC7913_init(bytes signer_)`
*internal*

<a id="SignerERC7913Upgradeable-__SignerERC7913_init_unchained-bytes-"></a>

### `__SignerERC7913_init_unchained(bytes signer_)`
*internal*

<a id="SignerERC7913Upgradeable-signer--"></a>

### `signer() ‚Üí bytes`
*public*

Return the ERC-7913 signer (i.e. `verifier || key`).

<a id="SignerERC7913Upgradeable-_setSigner-bytes-"></a>

### `_setSigner(bytes signer_)`
*internal*

Sets the signer (i.e. `verifier || key`) with an ERC-7913 formatted signer.

<a id="SignerERC7913Upgradeable-_rawSignatureValidation-bytes32-bytes-"></a>

### `_rawSignatureValidation(bytes32 hash, bytes signature) ‚Üí bool`
*internal*

Verifies a signature using [`SignatureChecker.isValidSignatureNow(bytes, bytes32, bytes, )`](https://docs.openzeppelin.com/contracts/api/utils/cryptography#SignatureChecker-isValidSignatureNow)
with [`SignerECDSAUpgradeable.signer`](#SignerECDSAUpgradeable-signer--), `hash` and `signature`.

<a id="SignerP256Upgradeable"></a>

## `SignerP256Upgradeable` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.4.0/contracts/utils/cryptography/signers/SignerP256Upgradeable.sol)

```solidity
import "@openzeppelin/contracts/utils/cryptography/signers/SignerP256Upgradeable.sol";
```

Implementation of [`AbstractSigner`](https://docs.openzeppelin.com/contracts/api/utils#AbstractSigner) using [P256](api:utils/cryptography#P256) signatures.

For [`Account`](https://docs.openzeppelin.com/contracts/api/account#Account) usage, a [`SignerECDSAUpgradeable._setSigner`](#SignerECDSAUpgradeable-_setSigner-address-) function is provided to set the [`SignerECDSAUpgradeable.signer`](#SignerECDSAUpgradeable-signer--) public key.
Doing so is easier for a factory, who is likely to use initializable clones of this contract.

Example of usage:

```solidity
contract MyAccountP256 is Account, SignerP256, Initializable 
    function initialize(bytes32 qx, bytes32 qy) public initializer 
      _setSigner(qx, qy);
    

```

<Callout type='warn'>
Failing to call [`SignerECDSAUpgradeable._setSigner`](#SignerECDSAUpgradeable-_setSigner-address-) either during construction (if used standalone)
</Callout>
or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.

### Functions
- [__SignerP256_init(qx, qy)](#SignerP256Upgradeable-__SignerP256_init-bytes32-bytes32-)
- [__SignerP256_init_unchained(qx, qy)](#SignerP256Upgradeable-__SignerP256_init_unchained-bytes32-bytes32-)
- [_setSigner(qx, qy)](#SignerP256Upgradeable-_setSigner-bytes32-bytes32-)
- [signer()](#SignerP256Upgradeable-signer--)
- [_rawSignatureValidation(hash, signature)](#SignerP256Upgradeable-_rawSignatureValidation-bytes32-bytes-)

#### AbstractSigner

#### Initializable
- [_checkInitializing()](#Initializable-_checkInitializing--)
- [_disableInitializers()](#Initializable-_disableInitializers--)
- [_getInitializedVersion()](#Initializable-_getInitializedVersion--)
- [_isInitializing()](#Initializable-_isInitializing--)
- [_initializableStorageSlot()](#Initializable-_initializableStorageSlot--)

### Events

#### AbstractSigner

#### Initializable
- [Initialized(version)](#Initializable-Initialized-uint64-)

### Errors
- [SignerP256InvalidPublicKey(qx, qy)](#SignerP256Upgradeable-SignerP256InvalidPublicKey-bytes32-bytes32-)

#### AbstractSigner

#### Initializable
- [InvalidInitialization()](#Initializable-InvalidInitialization--)
- [NotInitializing()](#Initializable-NotInitializing--)

<a id="SignerP256Upgradeable-__SignerP256_init-bytes32-bytes32-"></a>

### `__SignerP256_init(bytes32 qx, bytes32 qy)`
*internal*

<a id="SignerP256Upgradeable-__SignerP256_init_unchained-bytes32-bytes32-"></a>

### `__SignerP256_init_unchained(bytes32 qx, bytes32 qy)`
*internal*

<a id="SignerP256Upgradeable-_setSigner-bytes32-bytes32-"></a>

### `_setSigner(bytes32 qx, bytes32 qy)`
*internal*

Sets the signer with a P256 public key. This function should be called during construction
or through an initializer.

<a id="SignerP256Upgradeable-signer--"></a>

### `signer() ‚Üí bytes32 qx, bytes32 qy`
*public*

Return the signer's P256 public key.

<a id="SignerP256Upgradeable-_rawSignatureValidation-bytes32-bytes-"></a>

### `_rawSignatureValidation(bytes32 hash, bytes signature) ‚Üí bool`
*internal*

Signature validation algorithm.

<Callout type='warn'>
Implementing a signature validation algorithm is a security-sensitive operation as it involves
</Callout>
cryptographic verification. It is important to review and test thoroughly before deployment. Consider
using one of the signature verification libraries ([ECDSA](api:utils/cryptography#ECDSA),
[P256](api:utils/cryptography#P256) or [RSA](api:utils/cryptography#RSA)).

<a id="SignerP256Upgradeable-SignerP256InvalidPublicKey-bytes32-bytes32-"></a>

### `SignerP256InvalidPublicKey(bytes32 qx, bytes32 qy)`
*error*

<a id="SignerRSAUpgradeable"></a>

## `SignerRSAUpgradeable` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.4.0/contracts/utils/cryptography/signers/SignerRSAUpgradeable.sol)

```solidity
import "@openzeppelin/contracts/utils/cryptography/signers/SignerRSAUpgradeable.sol";
```

Implementation of [`AbstractSigner`](https://docs.openzeppelin.com/contracts/api/utils#AbstractSigner) using [RSA](api:utils/cryptography#RSA) signatures.

For [`Account`](https://docs.openzeppelin.com/contracts/api/account#Account) usage, a [`SignerECDSAUpgradeable._setSigner`](#SignerECDSAUpgradeable-_setSigner-address-) function is provided to set the [`SignerECDSAUpgradeable.signer`](#SignerECDSAUpgradeable-signer--) public key.
Doing so is easier for a factory, who is likely to use initializable clones of this contract.

Example of usage:

```solidity
contract MyAccountRSA is Account, SignerRSA, Initializable 
    function initialize(bytes memory e, bytes memory n) public initializer 
      _setSigner(e, n);
    

```

<Callout type='warn'>
Failing to call [`SignerECDSAUpgradeable._setSigner`](#SignerECDSAUpgradeable-_setSigner-address-) either during construction (if used standalone)
</Callout>
or during initialization (if used as a clone) may leave the signer either front-runnable or unusable.

### Functions
- [__SignerRSA_init(e, n)](#SignerRSAUpgradeable-__SignerRSA_init-bytes-bytes-)
- [__SignerRSA_init_unchained(e, n)](#SignerRSAUpgradeable-__SignerRSA_init_unchained-bytes-bytes-)
- [_setSigner(e, n)](#SignerRSAUpgradeable-_setSigner-bytes-bytes-)
- [signer()](#SignerRSAUpgradeable-signer--)
- [_rawSignatureValidation(hash, signature)](#SignerRSAUpgradeable-_rawSignatureValidation-bytes32-bytes-)

#### AbstractSigner

#### Initializable
- [_checkInitializing()](#Initializable-_checkInitializing--)
- [_disableInitializers()](#Initializable-_disableInitializers--)
- [_getInitializedVersion()](#Initializable-_getInitializedVersion--)
- [_isInitializing()](#Initializable-_isInitializing--)
- [_initializableStorageSlot()](#Initializable-_initializableStorageSlot--)

### Events

#### AbstractSigner

#### Initializable
- [Initialized(version)](#Initializable-Initialized-uint64-)

### Errors

#### AbstractSigner

#### Initializable
- [InvalidInitialization()](#Initializable-InvalidInitialization--)
- [NotInitializing()](#Initializable-NotInitializing--)

<a id="SignerRSAUpgradeable-__SignerRSA_init-bytes-bytes-"></a>

### `__SignerRSA_init(bytes e, bytes n)`
*internal*

<a id="SignerRSAUpgradeable-__SignerRSA_init_unchained-bytes-bytes-"></a>

### `__SignerRSA_init_unchained(bytes e, bytes n)`
*internal*

<a id="SignerRSAUpgradeable-_setSigner-bytes-bytes-"></a>

### `_setSigner(bytes e, bytes n)`
*internal*

Sets the signer with a RSA public key. This function should be called during construction
or through an initializer.

<a id="SignerRSAUpgradeable-signer--"></a>

### `signer() ‚Üí bytes e, bytes n`
*public*

Return the signer's RSA public key.

<a id="SignerRSAUpgradeable-_rawSignatureValidation-bytes32-bytes-"></a>

### `_rawSignatureValidation(bytes32 hash, bytes signature) ‚Üí bool`
*internal*

See [`AbstractSigner._rawSignatureValidation`](https://docs.openzeppelin.com/contracts/api/utils#AbstractSigner-rawSignatureValidation). Verifies a PKCSv1.5 signature by calling
[RSA.pkcs1Sha256](contracts/v5.x/api/utils/cryptography.mdx#RSA-pkcs1Sha256-bytes-bytes-bytes-bytes-).

<Callout type='warn'>
Following the RSASSA-PKCS1-V1_5-VERIFY procedure outlined in RFC8017 (section 8.2.2), the
</Callout>
provided `hash` is used as the `M` (message) and rehashed using SHA256 according to EMSA-PKCS1-v1_5
encoding as per section 9.2 (step 1) of the RFC.

<a id="ERC7739Upgradeable"></a>

## `ERC7739Upgradeable` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.4.0/contracts/utils/cryptography/signers/draft-ERC7739Upgradeable.sol)

```solidity
import "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739Upgradeable.sol";
```

Validates signatures wrapping the message hash in a nested EIP712 type. See [`ERC7739Utils`](https://docs.openzeppelin.com/contracts/api/token#ERC7739Utils).

Linking the signature to the EIP-712 domain separator is a security measure to prevent signature replay across different
EIP-712 domains (e.g. a single offchain owner of multiple contracts).

This contract requires implementing the [`AccountERC7579Upgradeable._rawSignatureValidation`](../account#AccountERC7579Upgradeable-_rawSignatureValidation-bytes32-bytes-) function, which passes the wrapped message hash,
which may be either an typed data or a personal sign nested type.

<Callout>
[EIP-712](api:utils/cryptography#EIP712) uses [ShortStrings](api:utils/cryptography#ShortStrings) to
</Callout>
optimize gas costs for short strings (up to 31 characters). Consider that strings longer than that will use storage,
which may limit the ability of the signer to be used within the ERC-4337 validation phase (due to
[ERC-7562 storage access rules](https://eips.ethereum.org/EIPS/eip-7562#storage-rules)).

### Functions
- [__ERC7739_init()](#ERC7739Upgradeable-__ERC7739_init--)
- [__ERC7739_init_unchained()](#ERC7739Upgradeable-__ERC7739_init_unchained--)
- [isValidSignature(hash, signature)](#ERC7739Upgradeable-isValidSignature-bytes32-bytes-)

#### IERC1271

#### EIP712Upgradeable
- [__EIP712_init(name, version)](#EIP712Upgradeable-__EIP712_init-string-string-)
- [__EIP712_init_unchained(name, version)](#EIP712Upgradeable-__EIP712_init_unchained-string-string-)
- [_domainSeparatorV4()](#EIP712Upgradeable-_domainSeparatorV4--)
- [_hashTypedDataV4(structHash)](#EIP712Upgradeable-_hashTypedDataV4-bytes32-)
- [eip712Domain()](#EIP712Upgradeable-eip712Domain--)
- [_EIP712Name()](#EIP712Upgradeable-_EIP712Name--)
- [_EIP712Version()](#EIP712Upgradeable-_EIP712Version--)
- [_EIP712NameHash()](#EIP712Upgradeable-_EIP712NameHash--)
- [_EIP712VersionHash()](#EIP712Upgradeable-_EIP712VersionHash--)

#### IERC5267

#### AbstractSigner
- [_rawSignatureValidation(hash, signature)](#AbstractSigner-_rawSignatureValidation-bytes32-bytes-)

#### Initializable
- [_checkInitializing()](#Initializable-_checkInitializing--)
- [_disableInitializers()](#Initializable-_disableInitializers--)
- [_getInitializedVersion()](#Initializable-_getInitializedVersion--)
- [_isInitializing()](#Initializable-_isInitializing--)
- [_initializableStorageSlot()](#Initializable-_initializableStorageSlot--)

### Events

#### IERC1271

#### EIP712Upgradeable

#### IERC5267
- [EIP712DomainChanged()](#IERC5267-EIP712DomainChanged--)

#### AbstractSigner

#### Initializable
- [Initialized(version)](#Initializable-Initialized-uint64-)

### Errors

#### IERC1271

#### EIP712Upgradeable

#### IERC5267

#### AbstractSigner

#### Initializable
- [InvalidInitialization()](#Initializable-InvalidInitialization--)
- [NotInitializing()](#Initializable-NotInitializing--)

<a id="ERC7739Upgradeable-__ERC7739_init--"></a>

### `__ERC7739_init()`
*internal*

<a id="ERC7739Upgradeable-__ERC7739_init_unchained--"></a>

### `__ERC7739_init_unchained()`
*internal*

<a id="ERC7739Upgradeable-isValidSignature-bytes32-bytes-"></a>

### `isValidSignature(bytes32 hash, bytes signature) ‚Üí bytes4 result`
*public*

Attempts validating the signature in a nested EIP-712 type.

A nested EIP-712 type might be presented in 2 different ways:

- As a nested EIP-712 typed data
- As a _personal_ signature (an EIP-712 mimic of the `eth_personalSign` for a smart contract)

