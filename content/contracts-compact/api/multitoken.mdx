---
title: MultiToken API
---

This module provides the full MultiToken module API.

<Callout type='info'>
  For an overview of the module, read the [MultiToken guide](../multitoken).
</Callout>

## Core

### MultiToken

[View on GitHub](https://github.com/OpenZeppelin/compact-contracts/blob/main/contracts/src/token/MultiToken.compact)

```ts
import "./compact-contracts/node_modules/@openzeppelin-compact/contracts/src/token/";
```

---

### Ledger [toc] [#MultiToken-Ledger]
### Ledger [!toc] [#MultiToken-Ledger]

#### _balances [toc] [#MultiToken-_balances]
#### [!toc] [#MultiToken-_balances]
<APIItemCompact
  circuitSig='_balances: Map<Uint<128>, Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>>'
  kind="ledger"
  id="MultiToken-_balances"
>
  Mapping from token ID to account balances.
</APIItemCompact>

#### _operatorApprovals [toc] [#MultiToken-_operatorApprovals]
#### [!toc] [#MultiToken-_operatorApprovals]
<APIItemCompact
  circuitSig='_operatorApprovals: Map<Either<ZswapCoinPublicKey, ContractAddress>, Map<Either<ZswapCoinPublicKey, ContractAddress>, Boolean>>'
  kind="ledger"
  id="MultiToken-_operatorApprovals"
>
  Mapping from account to operator approvals.
</APIItemCompact>

#### _uri [toc] [#MultiToken-_uri]
#### [!toc] [#MultiToken-_uri]
<APIItemCompact
  circuitSig='_uri: Opaque<"string">'
  kind="ledger"
  id="MultiToken-_uri"
>
  Base URI for computing token URIs.
</APIItemCompact>

### Witnesses [toc] [#MultiToken-Witnesses]
### Witnesses [!toc] [#MultiToken-Witnesses]

None.

### Circuits [toc] [#MultiToken-Circuits]
### Circuits [!toc] [#MultiToken-Circuits]

#### initialize [toc] [#MultiToken-initialize]
#### [!toc] [#MultiToken-initialize]
<APIItemCompact
  circuitSig='initialize(uri_: Opaque<"string">) → []'
  kind="circuit"
  complexity="k=10, rows=45"
  modulePrefix="MultiToken"
>
  Initializes the contract by setting the base URI for all tokens.

  This MUST be called in the implementing contract’s constructor.
  Failure to do so can lead to an irreparable contract.

  Requirements:

  * Contract is not initialized.
</APIItemCompact>

#### uri [toc] [#MultiToken-uri]
#### [!toc] [#MultiToken-uri]
<APIItemCompact
  circuitSig='uri(id: Uint<128>) → Opaque<"string">'
  kind="circuit"
  complexity="k=10, rows=90"
  modulePrefix="MultiToken"
>
  This implementation returns the same URI for **all** token types.
  It relies on the token type ID substitution mechanism defined in the EIP: [ERC1155-Metadata](https://eips.ethereum.org/EIPS/eip-1155#metadata).
  Clients calling this function must replace the `\id\` substring with the actual token type ID.

  Requirements:

  * Contract is initialized.
</APIItemCompact>

#### balanceOf [toc] [#MultiToken-balanceOf]
#### [!toc] [#MultiToken-balanceOf]
<APIItemCompact
  circuitSig="balanceOf(account: Either<ZswapCoinPublicKey, ContractAddress>, id: Uint<128>) → Uint<128>"
  kind="circuit"
  complexity="k=10, rows=439"
  modulePrefix="MultiToken"
>
  Returns the amount of `id` tokens owned by `account`.

  Requirements:

  * Contract is initialized.
</APIItemCompact>

#### setApprovalForAll [toc] [#MultiToken-setApprovalForAll]
#### [!toc] [#MultiToken-setApprovalForAll]
<APIItemCompact
  circuitSig="setApprovalForAll(operator: Either<ZswapCoinPublicKey, ContractAddress>, approved: Boolean) → []"
  kind="circuit"
  complexity="k=10, rows=404"
  stackParams="true"
  modulePrefix="MultiToken"
>
  Enables or disables approval for `operator` to manage all of the caller’s assets.

  Requirements:

  * Contract is initialized.
  * `operator` is not the zero address.
</APIItemCompact>

#### isApprovedForAll [toc] [#MultiToken-isApprovedForAll]
#### [!toc] [#MultiToken-isApprovedForAll]
<APIItemCompact
  circuitSig="isApprovedForAll(account: Either<ZswapCoinPublicKey, ContractAddress>, operator: Either<ZswapCoinPublicKey, ContractAddress>) → Boolean"
  kind="circuit"
  complexity="k=10, rows=619"
  stackParams="true"
  modulePrefix="MultiToken"
>
  Queries if `operator` is an authorized operator for `owner`.

  Requirements:

  * Contract is initialized.
</APIItemCompact>

#### transferFrom [toc] [#MultiToken-transferFrom]
#### [!toc] [#MultiToken-transferFrom]
<APIItemCompact
  circuitSig="transferFrom( from: Either<ZswapCoinPublicKey, ContractAddress>, to: Either<ZswapCoinPublicKey, ContractAddress>, id: Uint<128>, value: Uint<128>) → []"
  kind="circuit"
  complexity="k=11, rows=1882"
  stackParams="true"
  modulePrefix="MultiToken"
>
  Transfers ownership of `value` amount of `id` tokens from `from` to `to`.
  The caller must be `from` or approved to transfer on their behalf.

  <Callout type='info'>
    Transfers to contract addresses are currently disallowed until contract-to-contract interactions are supported in Compact.
    This restriction prevents assets from being inadvertently locked in contracts that cannot currently handle token receipt.
  </Callout>

  Requirements:

  * Contract is initialized.
  * `to` is not a ContractAddress.
  * `to` is not the zero address.
  * `from` is not the zero address.
  * Caller must be `from` or approved via [setApprovalForAll](#MultiToken-setApprovalForAll).
  * `from` must have an `id` balance of at least `value`.
</APIItemCompact>

#### _transfer [toc] [#MultiToken-_transfer]
#### [!toc] [#MultiToken-_transfer]
<APIItemCompact
  circuitSig="_transfer(from: Either<ZswapCoinPublicKey, ContractAddress>, to: Either<ZswapCoinPublicKey, ContractAddress>, id: Uint<128>, value: Uint<128>): []"
  kind="circuit"
  complexity="k=11, rows=1487"
  stackParams="true"
  modulePrefix="MultiToken"
>
  Transfers ownership of `value` amount of `id` tokens from `from` to `to`.
  Does not impose restrictions on the caller, making it suitable for composition in higher-level contract logic.

  <Callout type='info'>
    Transfers to contract addresses are currently disallowed until contract-to-contract interactions are supported in Compact.
    This restriction prevents assets from being inadvertently locked in contracts that cannot currently handle token receipt.
  </Callout>

  Requirements:

  * Contract is initialized.
  * `to` is not a ContractAddress.
  * `to` is not the zero address.
  * `from` is not the zero address.
  * `from` must have an `id` balance of at least `value`.
</APIItemCompact>

#### _update [toc] [#MultiToken-_update]
#### [!toc] [#MultiToken-_update]
<APIItemCompact
  circuitSig="_update(from: Either<ZswapCoinPublicKey, ContractAddress>, to: Either<ZswapCoinPublicKey, ContractAddress>, id: Uint<128>, value: Uint<128>): []"
  kind="circuit"
  complexity="k=11, rows=1482"
  stackParams="true"
  modulePrefix="MultiToken"
>
  Transfers a value amount of tokens of type id from from to to.
  This circuit will mint (or burn) if `from` (or `to`) is the zero address.

  Requirements:

  * Contract is initialized.
  * If `from` is not zero, the balance of `id` of `from` must be >= `value`.
</APIItemCompact>

#### _unsafeTransferFrom [toc] [#MultiToken-_unsafeTransferFrom]
#### [!toc] [#MultiToken-_unsafeTransferFrom]
<APIItemCompact
  circuitSig="_unsafeTransferFrom(from: Either<ZswapCoinPublicKey, ContractAddress>, to: Either<ZswapCoinPublicKey, ContractAddress>, id: Uint<128>, value: Uint<128>) → []"
  kind="circuit"
  complexity="k=11, rows=1881"
  stackParams="true"
  modulePrefix="MultiToken"
>
  Unsafe variant of [transferFrom](#MultiToken-transferFrom) which allows transfers to contract addresses.
  The caller must be `from` or approved to transfer on their behalf.

  <Callout type='warn'>
    Transfers to contract addresses are considered unsafe because contract-to-contract calls are not currently supported.
    Tokens sent to a contract address may become irretrievable.
    Once contract-to-contract calls are supported, this circuit may be deprecated.
  </Callout>

  Requirements:

  * Contract is initialized.
  * `to` is not the zero address.
  * `from` is not the zero address.
  * Caller must be `from` or approved via [setApprovalForAll](#MultiToken-setApprovalForAll).
  * `from` must have an `id` balance of at least `value`.
</APIItemCompact>

#### _unsafeTransfer [toc] [#MultiToken-_unsafeTransfer]
#### [!toc] [#MultiToken-_unsafeTransfer]
<APIItemCompact
  circuitSig="_unsafeTransfer(from: Either<ZswapCoinPublicKey, ContractAddress>, to: Either<ZswapCoinPublicKey, ContractAddress>, id: Uint<128>, value: Uint<128>) → []"
  kind="circuit"
  complexity="k=11, rows=1486"
  stackParams="true"
  modulePrefix="MultiToken"
>
  Unsafe variant of [_transfer](#MultiToken-_transfer) which allows transfers to contract addresses.
  Does not impose restrictions on the caller, making it suitable as a low-level building block for advanced contract logic.

  <Callout type='warn'>
    Transfers to contract addresses are considered unsafe because contract-to-contract calls are not currently supported.
    Tokens sent to a contract address may become irretrievable.
    Once contract-to-contract calls are supported, this circuit may be deprecated.
  </Callout>

  Requirements:

  * Contract is initialized.
  * `from` is not the zero address.
  * `to` is not the zero address.
  * `from` must have an `id` balance of at least `value`.
</APIItemCompact>

#### _setURI [toc] [#MultiToken-_setURI]
#### [!toc] [#MultiToken-_setURI]
<APIItemCompact
  circuitSig='_setURI(newURI: Opaque<"string">) → []'
  kind="circuit"
  complexity="k=10, rows=39"
  modulePrefix="MultiToken"
>
  Sets a new URI for all token types, by relying on the token type ID substitution mechanism defined in the MultiToken standard.
  See https://eips.ethereum.org/EIPS/eip-1155#metadata.

  By this mechanism, any occurrence of the `\id\` substring
  in either the URI or any of the values in the JSON file at said URI will be replaced by clients with the token type ID.

  For example, the `https://token-cdn-domain/\id\.json` URI would be interpreted by clients as
  `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json` for token type ID 0x4cce0.

  Requirements:

  * Contract is initialized.
</APIItemCompact>

#### _mint [toc] [#MultiToken-_mint]
#### [!toc] [#MultiToken-_mint]
<APIItemCompact
  circuitSig="_mint(to: Either<ZswapCoinPublicKey, ContractAddress>, id: Uint<128>, value: Uint<128>) → []"
  kind="circuit"
  complexity="k=10, rows=912"
  stackParams="true"
  modulePrefix="MultiToken"
>
  Creates a `value` amount of tokens of type `token_id`, and assigns them to `to`.

  <Callout>
    Transfers to contract addresses are currently disallowed until contract-to-contract interactions are supported in Compact.
    This restriction prevents assets from being inadvertently locked in contracts that cannot currently handle token receipt.
  </Callout>

  Requirements:

  * Contract is initialized.
  * `to` is not the zero address.
  * `to` is not a ContractAddress
</APIItemCompact>

#### _unsafeMint [toc] [#MultiToken-_unsafeMint]
#### [!toc] [#MultiToken-_unsafeMint]
<APIItemCompact
  circuitSig="_unsafeMint(to: Either<ZswapCoinPublicKey, ContractAddress>, id: Uint<128>, value: Uint<128>) → []"
  kind="circuit"
  complexity="k=10, rows=911"
  stackParams="true"
  modulePrefix="MultiToken"
>
  Unsafe variant of `_mint` which allows transfers to contract addresses.

  <Callout type='warn'>
    Transfers to contract addresses are considered unsafe because contract-to-contract calls are not currently supported.
    Tokens sent to a contract address may become irretrievable.
    Once contract-to-contract calls are supported, this circuit may be deprecated.
  </Callout>

  Requirements:

  * Contract is initialized.
  * `to` is not the zero address.
</APIItemCompact>

#### _burn [toc] [#MultiToken-_burn]
#### [!toc] [#MultiToken-_burn]
<APIItemCompact
  circuitSig="_burn(from: Either<ZswapCoinPublicKey, ContractAddress>, id: Uint<128>, value: Uint<128>) → []"
  kind="circuit"
  complexity="k=10, rows=688"
  stackParams="true"
  modulePrefix="MultiToken"
>
  Destroys a `value` amount of tokens of type `token_id` from `from`.

  Requirements:

  * Contract is initialized.
  * `from` is not the zero address.
  * `from` must have an `id` balance of at least `value`.
</APIItemCompact>

#### _setApprovalForAll [toc] [#MultiToken-_setApprovalForAll]
#### [!toc] [#MultiToken-_setApprovalForAll]
<APIItemCompact
  circuitSig="_setApprovalForAll(owner: Either<ZswapCoinPublicKey, ContractAddress>, operator: Either<ZswapCoinPublicKey, ContractAddress>, approved: Boolean) → []"
  kind="circuit"
  complexity="k=10, rows=518"
  stackParams="true"
  modulePrefix="MultiToken"
>
  Enables or disables approval for `operator` to manage all of the caller’s assets.
  This circuit does not check for access permissions but can be useful as a building block for more complex contract logic.

  Requirements:

  * Contract is initialized.
  * `operator` is not the zero address.
</APIItemCompact>
