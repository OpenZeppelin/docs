---
title: NonFungibleToken
---

This module provides the full NonFungibleToken module API.

<Callout>
For an overview of the module, read the [NonFungibleToken guide](/contracts-compact/nonFungibleToken).
</Callout>

## Core

```ts
import "./node-modules/@openzeppelin-compact/non-fungible-token/src/NonFungibleToken" prefix NonFungibleToken_;
```

### NonFungibleToken

[View on GitHub](https://github.com/OpenZeppelin/compact-contracts/blob/main/contracts/nonFungibleToken/src/NonFungibleToken.compact)

**Circuits**

* [`initialize(name_, symbol_)`](#initialize) - circuit
* [`balanceOf(owner)`](#balanceof) - circuit
* [`ownerOf(tokenId)`](#ownerof) - circuit
* [`name()`](#name) - circuit
* [`symbol()`](#symbol) - circuit
* [`tokenURI(tokenId)`](#tokenuri) - circuit
* [`_setTokenURI(tokenId, tokenURI)`](#_settokenuri) - circuit
* [`approve(to, tokenId)`](#approve) - circuit
* [`getApproved(tokenId)`](#getapproved) - circuit
* [`setApprovalForAll(operator, approved)`](#setapprovalforall) - circuit
* [`isApprovedForAll(owner, operator)`](#isapprovedforall) - circuit
* [`transferFrom(from, to, tokenId)`](#transferfrom) - circuit
* [`_unsafeTransferFrom(from, to, tokenId)`](#_unsafetransferfrom) - circuit
* [`_ownerOf(tokenId)`](#_ownerof) - circuit
* [`_getApproved(tokenId)`](#_getapproved) - circuit
* [`_isAuthorized(owner, spender, tokenId)`](#_isauthorized) - circuit
* [`_checkAuthorized(owner, spender, tokenId)`](#_checkauthorized) - circuit
* [`_update(to, tokenId, auth)`](#_update) - internal
* [`_mint(to, tokenId)`](#_mint) - circuit
* [`_unsafeMint(to, tokenId)`](#_unsafemint) - circuit
* [`_burn(tokenId)`](#_burn) - circuit
* [`_transfer(from, to, tokenId)`](#_transfer) - circuit
* [`_unsafeTransfer(from, to, tokenId)`](#_unsafetransfer) - circuit
* [`_approve(to, tokenId, auth)`](#_approve) - circuit
* [`_setApprovalForAll(owner, operator, approved)`](#_setapprovalforall) - circuit
* [`_requireOwned(tokenId)`](#_requireowned) - circuit

#### initialize

```
initialize(name_: Opaque<"string">, symbol_: Opaque<"string">) → []
```

**Type:** circuit

Initializes the contract by setting the name and symbol.

This MUST be called in the implementing contract’s constructor.
Failure to do so can lead to an irreparable contract.

Requirements:

* Contract is not initialized.

Constraints:

* k=10, rows=65

#### balanceOf

```
balanceOf(owner: Either<ZswapCoinPublicKey, ContractAddress>) → Uint<128>
```

**Type:** circuit

Returns the number of tokens in `owner`'s account.

Requirements:

* Contract is initialized.

Constraints:

* k=10, rows=309

#### ownerOf

```
ownerOf(tokenId: Uint<128>) → Either<ZswapCoinPublicKey, ContractAddress>
```

**Type:** circuit

Returns the owner of the `tokenId` token.

Requirements:

* The contract is initialized.
* The `tokenId` must exist.

Constraints:

* k=10, rows=290

#### name

```
name() → Opaque<"string">
```

**Type:** circuit

Returns the token name.

Requirements:

* Contract is initialized.

Constraints:

* k=10, rows=36

#### symbol

```
symbol() → Opaque<"string">
```

**Type:** circuit

Returns the symbol of the token.

Requirements:

* Contract is initialized.

Constraints:

* k=10, rows=36

#### tokenURI

```
tokenURI(tokenId: Uint<128>) → Opaque<"string">
```

**Type:** circuit

Returns the token URI for the given `tokenId`.
Returns an empty string if a tokenURI does not exist.

Requirements:

* The contract is initialized.
* The `tokenId` must exist.

<Callout>
Native strings and string operations aren’t supported within the Compact language, e.g. concatenating a base URI + token ID is not possible like in other NFT implementations.
Therefore, we propose the URI storage approach; whereby, NFTs may or may not have unique "base" URIs.
It’s up to the implementation to decide on how to handle this.
</Callout>

Constraints:

* k=10, rows=296

#### _setTokenURI

```
_setTokenURI(tokenId: Uint<128>, tokenURI: Opaque<"string">) → []
```

**Type:** circuit

Sets the the URI as `tokenURI` for the given `tokenId`.

Requirements:

* The contract is initialized.
* The `tokenId` must exist.

<Callout>
The URI for a given NFT is usually set when the NFT is minted.
</Callout>

Constraints:

* k=10, rows=253

#### approve

```
approve(to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → []
```

**Type:** circuit

Gives permission to `to` to transfer `tokenId` token to another account.
The approval is cleared when the token is transferred.

Only a single account can be approved at a time, so approving the zero address clears previous approvals.

Requirements:

* The contract is initialized.
* The caller must either own the token or be an approved operator.
* `tokenId` must exist.

Constraints:

* k=10, rows=966

#### getApproved

```
getApproved(tokenId: Uint<128>) → Either<ZswapCoinPublicKey, ContractAddress>
```

**Type:** circuit

Returns the account approved for `tokenId` token.

Requirements:

* The contract is initialized.
* `tokenId` must exist.

Constraints:

* k=10, rows=409

#### setApprovalForAll

```
setApprovalForAll(operator: Either<ZswapCoinPublicKey, ContractAddress>, approved: Boolean) → []
```

**Type:** circuit

Approve or remove `operator` as an operator for the caller.
Operators can call [transferFrom](#transferfrom) for any token owned by the caller.

Requirements:

* The contract is initialized.
* The `operator` cannot be the zero address.

Constraints:

* k=10, rows=409

#### isApprovedForAll

```
isApprovedForAll(owner: Either<ZswapCoinPublicKey, ContractAddress>, operator: Either<ZswapCoinPublicKey, ContractAddress>) → Boolean
```

**Type:** circuit

Returns if the `operator` is allowed to manage all of the assets of `owner`.

Requirements:

* The contract must have been initialized.

Constraints:

* k=10, rows=621

#### transferFrom

```
transferFrom(from: Either<ZswapCoinPublicKey, ContractAddress>, to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → []
```

**Type:** circuit

Transfers `tokenId` token from `from` to `to`.

<Callout>
Transfers to contract addresses are currently disallowed until contract-to-contract interactions are supported in Compact.
This restriction prevents assets from being inadvertently locked in contracts that cannot currently handle token receipt.
</Callout>

Requirements:

* The contract is initialized.
* `from` is not the zero address.
* `to` is not the zero address.
* `to` is not a ContractAddress.
* `tokenId` token must be owned by `from`.
* If the caller is not `from`, it must be approved to move this token by either [approve](#approve) or [setApprovalForAll](#setapprovalforall).

Constraints:

* k=11, rows=1966

#### _unsafeTransferFrom

```
_unsafeTransferFrom(from: Either<ZswapCoinPublicKey, ContractAddress>, to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → []
```

**Type:** circuit

Unsafe variant of [transferFrom](#transferfrom) which allows transfers to contract addresses.

<Callout type='warn'>
Transfers to contract addresses are considered unsafe because contract-to-contract calls are not currently supported.
Tokens sent to a contract address may become irretrievable.
Once contract-to-contract calls are supported, this circuit may be deprecated.
</Callout>

Requirements:

* The contract is initialized.
* `from` is not the zero address.
* `to` is not the zero address.
* `tokenId` token must be owned by `from`.
* If the caller is not `from`, it must be approved to move this token by either [approve](#approve) or [setApprovalForAll](#setapprovalforall).

Constraints:

* k=11, rows=1963

#### _ownerOf

```
_ownerOf(tokenId: Uint<128>) → Either<ZswapCoinPublicKey, ContractAddress>
```

**Type:** circuit

Returns the owner of the `tokenId`. Does NOT revert if token doesn’t exist

Requirements:

* The contract is initialized.

Constraints:

* k=10, rows=253

#### _getApproved

```
_getApproved(tokenId: Uint<128>) → Either<ZswapCoinPublicKey, ContractAddress>
```

**Type:** circuit

Returns the approved address for `tokenId`. Returns the zero address if `tokenId` is not minted.

Requirements:

* The contract is initialized.

Constraints:

* k=10, rows=253

#### _isAuthorized

```
_isAuthorized(owner: Either<ZswapCoinPublicKey, ContractAddress>, spender: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → Boolean
```

**Type:** circuit

Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in particular (ignoring whether it is owned by `owner`).

Requirements:

* The contract is initialized.

<Callout type='warn'>
This function assumes that `owner` is the actual owner of `tokenId` and does not verify this assumption.
</Callout>

Constraints:

* k=11, rows=1098

#### _checkAuthorized

```
_checkAuthorized(owner: Either<ZswapCoinPublicKey, ContractAddress>, spender: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → []
```

**Type:** circuit

Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.

Requirements:

* The contract is initialized.
* `spender` has approval from `owner` for `tokenId` OR `spender` has approval to manage all of `owner`'s assets.

<Callout type='warn'>
This function assumes that `owner` is the actual owner of `tokenId` and does not verify this assumption.
</Callout>

Constraints:

* k=11, rows=1121

#### _update

```
_update(to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>, auth: Either<ZswapCoinPublicKey, ContractAddress>) → Either<ZswapCoinPublicKey, ContractAddress>
```

**Type:** internal

Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner (or `to`) is the zero address.
Returns the owner of the `tokenId` before the update.

Requirements:

* The contract is initialized.
* If `auth` is non 0, then this function will check that `auth` is either the owner of the token, or approved to operate on the token (by the owner).

Constraints:

* k=12, rows=2049

#### _mint

```
_mint(to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → []
```

**Type:** circuit

Mints `tokenId` and transfers it to `to`.

Requirements:

* The contract is initialized.
* `tokenId` must not exist.
* `to` is not the zero address.
* `to` is not a ContractAddress.

Constraints:

* k=10, rows=1013

#### _unsafeMint

```
_unsafeMint(account: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>) → []
```

**Type:** circuit

Unsafe variant of [_mint](#_mint) which allows transfers to contract addresses.

Requirements:

* Contract is initialized.
* `tokenId` must not exist.
* `to` is not the zero address.

<Callout type='warn'>
Transfers to contract addresses are considered unsafe because contract-to-contract calls are not currently supported.
Tokens sent to a contract address may become irretrievable.
Once contract-to-contract calls are supported, this circuit may be deprecated.
</Callout>

Constraints:

* k=10, rows=1010

#### _burn

```
_burn(tokenId: Uint<128>) → []
```

**Type:** circuit

Destroys `tokenId`.
The approval is cleared when the token is burned.
This circuit does not check if the sender is authorized to operate on the token.

Requirements:

* The contract is initialized.
* `tokenId` must exist.

Constraints:

* k=10, rows=479

#### _transfer

```
_transfer(from: Either<ZswapCoinPublicKey, ContractAddress>, to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → []
```

**Type:** circuit

Transfers `tokenId` from `from` to `to`. As opposed to [transferFrom](#transferfrom), this imposes no restrictions on `ownPublicKey()`.

<Callout>
Transfers to contract addresses are currently disallowed until contract-to-contract interactions are supported in Compact.
This restriction prevents assets from being inadvertently locked in contracts that cannot currently handle token receipt.
</Callout>

Requirements:

* The contract is initialized.
* `to` is not the zero address.
* `to` is not a ContractAddress.
* `tokenId` token must be owned by `from`.

Constraints:

* k=11, rows=1224

#### _unsafeTransfer

```
_unsafeTransfer(from: Either<ZswapCoinPublicKey, ContractAddress>, to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → []
```

**Type:** circuit

Unsafe variant of [_transfer](#_transfer) which allows transfers to contract addresses.

Transfers `tokenId` from `from` to `to`. As opposed to [_unsafeTransferFrom](#_unsafetransferfrom), this imposes no restrictions on `ownPublicKey()`. It does NOT check if the recipient is a `ContractAddress`.

<Callout type='warn'>
Transfers to contract addresses are considered unsafe because contract-to-contract calls are not currently supported. Tokens sent to a contract address may become irretrievable.
Once contract-to-contract calls are supported, this circuit may be deprecated.
</Callout>

Requirements:

* Contract is initialized.
* `to` is not the zero address.
* `tokenId` token must be owned by `from`.

Constraints:

* k=11, rows=1221

#### _approve

```
_approve(to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>, auth: Either<ZswapCoinPublicKey, ContractAddress>) → []
```

**Type:** circuit

Approve `to` to operate on `tokenId`

Requirements:

* The contract is initialized.
* If `auth` is non 0, then this function will check that `auth` is either the owner of the token, or approved to operate on the token (by the owner).

Constraints:

* k=11, rows=1109

#### _setApprovalForAll

```
_setApprovalForAll(owner: Either<ZswapCoinPublicKey, ContractAddress>, operator: Either<ZswapCoinPublicKey, ContractAddress>, approved: Boolean) → []
```

**Type:** circuit

Approve `operator` to operate on all of `owner` tokens

Requirements:

* The contract is initialized.
* `operator` is not the zero address.

Constraints:

* k=10, rows=524

#### _requireOwned

```
_requireOwned(tokenId: Uint<128>) → Either<ZswapCoinPublicKey, ContractAddress>
```

**Type:** circuit

Reverts if the `tokenId` doesn’t have a current owner (it hasn’t been minted, or it has been burned).
Returns the owner.

Requirements:

* The contract is initialized.
* `tokenId` must exist.

Constraints:

* k=10, rows=288
