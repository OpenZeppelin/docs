---
title: NonFungibleToken API
---

This module provides the full NonFungibleToken module API.

<Callout type='info'>
  For an overview of the module, read the [NonFungibleToken guide](../nonFungibleToken).
</Callout>

## NonFungibleToken [toc] [#NonFungibleToken]
<APIGithubLinkHeader
    moduleName="NonFungibleToken"
    link={`https://github.com/OpenZeppelin/compact-contracts/blob/main/contracts/src/token/NonFungibleToken.compact`}
/>

```ts
import "./compact-contracts/node_modules/@openzeppelin-compact/contracts/src/token/NonFungibleToken";
```

---

### Ledger [toc] [#NonFungibleToken-Ledger]
### Ledger [!toc] [#NonFungibleToken-Ledger]

#### _name [toc] [#NonFungibleToken-_name]
#### [!toc] [#NonFungibleToken-_name]
<APIItemCompact
  circuitSig='_name: Opaque<"string">'
  kind="sealed ledger"
  id="NonFungibleToken-_name"
>
  The immutable token name.
</APIItemCompact>

#### _symbol [toc] [#NonFungibleToken-_symbol]
#### [!toc] [#NonFungibleToken-_symbol]
<APIItemCompact
  circuitSig='_symbol: Opaque<"string">'
  kind="sealed ledger"
  id="NonFungibleToken-_symbol"
>
  The immutable token symbol.
</APIItemCompact>

#### _owners [toc] [#NonFungibleToken-_owners]
#### [!toc] [#NonFungibleToken-_owners]
<APIItemCompact
  circuitSig='_owners: Map<Uint<128>, Either<ZswapCoinPublicKey, ContractAddress>>'
  kind="ledger"
  id="NonFungibleToken-_owners"
>
  Mapping from token IDs to their owner addresses.
</APIItemCompact>

#### _balances [toc] [#NonFungibleToken-_balances]
#### [!toc] [#NonFungibleToken-_balances]
<APIItemCompact
  circuitSig='_balances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>'
  kind="ledger"
  id="NonFungibleToken-_balances"
>
  Mapping from account addresses to their token balances.
</APIItemCompact>

#### _tokenApprovals [toc] [#NonFungibleToken-_tokenApprovals]
#### [!toc] [#NonFungibleToken-_tokenApprovals]
<APIItemCompact
  circuitSig='_tokenApprovals: Map<Uint<128>, Either<ZswapCoinPublicKey, ContractAddress>>'
  kind="ledger"
  id="NonFungibleToken-_tokenApprovals"
>
  Mapping from token IDs to approved addresses.
</APIItemCompact>

#### _operatorApprovals [toc] [#NonFungibleToken-_operatorApprovals]
#### [!toc] [#NonFungibleToken-_operatorApprovals]
<APIItemCompact
  circuitSig='_operatorApprovals: Map<Either<ZswapCoinPublicKey, ContractAddress>, Map<Either<ZswapCoinPublicKey, ContractAddress>, Boolean>>'
  kind="ledger"
  id="NonFungibleToken-_operatorApprovals"
>
  Mapping from owner addresses to operator approvals.
</APIItemCompact>

#### _tokenURIs [toc] [#NonFungibleToken-_tokenURIs]
#### [!toc] [#NonFungibleToken-_tokenURIs]
<APIItemCompact
  circuitSig='_tokenURIs: Map<Uint<128>, Opaque<"string">>'
  kind="ledger"
  id="NonFungibleToken-_tokenURIs"
>
  Mapping from token IDs to their metadata URIs.
</APIItemCompact>

### Witnesses [toc] [#NonFungibleToken-Witnesses]
### Witnesses [!toc] [#NonFungibleToken-Witnesses]

None.

### Circuits [toc] [#NonFungibleToken-Circuits]
### Circuits [!toc] [#NonFungibleToken-Circuits]

#### initialize [toc] [#NonFungibleToken-initialize]
#### [!toc] [#NonFungibleToken-initialize]
<APIItemCompact
  circuitSig='initialize(name_: Opaque<"string">, symbol_: Opaque<"string">) → []'
  kind="circuit"
  complexity="k=10, rows=65"
  modulePrefix="NonFungibleToken"
>
  Initializes the contract by setting the name and symbol.

  This MUST be called in the implementing contract’s constructor.
  Failure to do so can lead to an irreparable contract.

  Requirements:

  * Contract is not initialized.
</APIItemCompact>

#### balanceOf [toc] [#NonFungibleToken-balanceOf]
#### [!toc] [#NonFungibleToken-balanceOf]
<APIItemCompact
  circuitSig='balanceOf(owner: Either<ZswapCoinPublicKey, ContractAddress>) → Uint<128>'
  kind="circuit"
  complexity="k=10, rows=309"
  modulePrefix="NonFungibleToken"
>
  Returns the number of tokens in `owner`'s account.

  Requirements:

  * Contract is initialized.
</APIItemCompact>

#### ownerOf [toc] [#NonFungibleToken-ownerOf]
#### [!toc] [#NonFungibleToken-ownerOf]
<APIItemCompact
  circuitSig='ownerOf(tokenId: Uint<128>) → Either<ZswapCoinPublicKey, ContractAddress>'
  kind="circuit"
  complexity="k=10, rows=290"
  modulePrefix="NonFungibleToken"
>
  Returns the owner of the `tokenId` token.

  Requirements:

  * The contract is initialized.
  * The `tokenId` must exist.
</APIItemCompact>

#### name [toc] [#NonFungibleToken-name]
#### [!toc] [#NonFungibleToken-name]
<APIItemCompact
  circuitSig='name() → Opaque<"string">'
  kind="circuit"
  complexity="k=10, rows=36"
  modulePrefix="NonFungibleToken"
>
  Returns the token name.

  Requirements:

  * Contract is initialized.
</APIItemCompact>

#### symbol [toc] [#NonFungibleToken-symbol]
#### [!toc] [#NonFungibleToken-symbol]
<APIItemCompact
  circuitSig='symbol() → Opaque<"string">'
  kind="circuit"
  complexity="k=10, rows=36"
  modulePrefix="NonFungibleToken"
>
  Returns the symbol of the token.

  Requirements:

  * Contract is initialized.
</APIItemCompact>

#### tokenURI [toc] [#NonFungibleToken-tokenURI]
#### [!toc] [#NonFungibleToken-tokenURI]
<APIItemCompact
  circuitSig='tokenURI(tokenId: Uint<128>) → Opaque<"string">'
  kind="circuit"
  complexity="k=10, rows=296"
  modulePrefix="NonFungibleToken"
>
  Returns the token URI for the given `tokenId`.
  Returns an empty string if a tokenURI does not exist.

  Requirements:

  * The contract is initialized.
  * The `tokenId` must exist.

  <Callout type='info'>
    Native strings and string operations aren’t supported within the Compact language,
    e.g. concatenating a base URI + token ID is not possible like in other NFT implementations.
    Therefore, we propose the URI storage approach; whereby, NFTs may or may not have unique "base" URIs.
    It’s up to the implementation to decide on how to handle this.
  </Callout>
</APIItemCompact>

#### _setTokenURI [toc] [#NonFungibleToken-_setTokenURI]
#### [!toc] [#NonFungibleToken-_setTokenURI]
<APIItemCompact
  circuitSig='_setTokenURI(tokenId: Uint<128>, tokenURI: Opaque<"string">) → []'
  kind="circuit"
  complexity="k=10, rows=253"
  modulePrefix="NonFungibleToken"
>
  Sets the the URI as `tokenURI` for the given `tokenId`.

  Requirements:

  * The contract is initialized.
  * The `tokenId` must exist.
</APIItemCompact>

#### approve [toc] [#NonFungibleToken-approve]
#### [!toc] [#NonFungibleToken-approve]
<APIItemCompact
  circuitSig='approve(to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → []'
  kind="circuit"
  complexity="k=10, rows=966"
  modulePrefix="NonFungibleToken"
>
  Gives permission to `to` to transfer `tokenId` token to another account.
  The approval is cleared when the token is transferred.

  Only a single account can be approved at a time, so approving the zero address clears previous approvals.

  Requirements:

  * The contract is initialized.
  * The caller must either own the token or be an approved operator.
  * `tokenId` must exist.
</APIItemCompact>

#### getApproved [toc] [#NonFungibleToken-getApproved]
#### [!toc] [#NonFungibleToken-getApproved]
<APIItemCompact
  circuitSig='getApproved(tokenId: Uint<128>) → Either<ZswapCoinPublicKey, ContractAddress>'
  kind="circuit"
  complexity="k=10, rows=409"
  modulePrefix="NonFungibleToken"
>
  Returns the account approved for `tokenId` token.

  Requirements:

  * The contract is initialized.
  * `tokenId` must exist.
</APIItemCompact>

#### setApprovalForAll [toc] [#NonFungibleToken-setApprovalForAll]
#### [!toc] [#NonFungibleToken-setApprovalForAll]
<APIItemCompact
  circuitSig='setApprovalForAll(operator: Either<ZswapCoinPublicKey, ContractAddress>, approved: Boolean) → []'
  kind="circuit"
  complexity="k=10, rows=409"
  modulePrefix="NonFungibleToken"
>
  Approve or remove `operator` as an operator for the caller.
  Operators can call [transferFrom](#NonFungibleToken-transferFrom) for any token owned by the caller.

  Requirements:

  * The contract is initialized.
  * The `operator` cannot be the zero address.
</APIItemCompact>

#### isApprovedForAll [toc] [#NonFungibleToken-isApprovedForAll]
#### [!toc] [#NonFungibleToken-isApprovedForAll]
<APIItemCompact
  circuitSig='isApprovedForAll(owner: Either<ZswapCoinPublicKey, ContractAddress>, operator: Either<ZswapCoinPublicKey, ContractAddress>) → Boolean'
  kind="circuit"
  complexity="k=10, rows=621"
  stackParams="true"
  modulePrefix="NonFungibleToken"
>
  Returns if the `operator` is allowed to manage all of the assets of `owner`.

  Requirements:

  * The contract must have been initialized.
</APIItemCompact>

#### transferFrom [toc] [#NonFungibleToken-transferFrom]
#### [!toc] [#NonFungibleToken-transferFrom]
<APIItemCompact
  circuitSig='transferFrom(from: Either<ZswapCoinPublicKey, ContractAddress>, to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → []'
  kind="circuit"
  complexity="k=11, rows=1966"
  stackParams="true"
  modulePrefix="NonFungibleToken"
>
  Transfers `tokenId` token from `from` to `to`.

  <Callout type='info'>
    Transfers to contract addresses are currently disallowed until contract-to-contract interactions are supported in Compact.
    This restriction prevents assets from being inadvertently locked in contracts that cannot currently handle token receipt.
  </Callout>

  Requirements:

  * The contract is initialized.
  * `from` is not the zero address.
  * `to` is not the zero address.
  * `to` is not a ContractAddress.
  * `tokenId` token must be owned by `from`.
  * If the caller is not `from`, it must be approved to move this token by either [approve](#NonFungibleToken-approve) or [setApprovalForAll](#NonFungibleToken-setApprovalForAll).
</APIItemCompact>

#### _unsafeTransferFrom [toc] [#NonFungibleToken-_unsafeTransferFrom]
#### [!toc] [#NonFungibleToken-_unsafeTransferFrom]
<APIItemCompact
  circuitSig='_unsafeTransferFrom(from: Either<ZswapCoinPublicKey, ContractAddress>, to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → []'
  kind="circuit"
  complexity="k=11, rows=1963"
  stackParams="true"
  modulePrefix="NonFungibleToken"
>
  Unsafe variant of [transferFrom](#NonFungibleToken-transferFrom) which allows transfers to contract addresses.

  <Callout type='warn'>
    Transfers to contract addresses are considered unsafe because contract-to-contract calls are not currently supported.
    Tokens sent to a contract address may become irretrievable.
    Once contract-to-contract calls are supported, this circuit may be deprecated.
  </Callout>

  Requirements:

  * The contract is initialized.
  * `from` is not the zero address.
  * `to` is not the zero address.
  * `tokenId` token must be owned by `from`.
  * If the caller is not `from`, it must be approved to move this token by either [approve](#NonFungibleToken-approve) or [setApprovalForAll](#NonFungibleToken-setApprovalForAll).
</APIItemCompact>

#### _ownerOf [toc] [#NonFungibleToken-_ownerOf]
#### [!toc] [#NonFungibleToken-_ownerOf]
<APIItemCompact
  circuitSig='_ownerOf(tokenId: Uint<128>) → Either<ZswapCoinPublicKey, ContractAddress>'
  kind="circuit"
  complexity="k=10, rows=253"
  modulePrefix="NonFungibleToken"
>
  Returns the owner of the `tokenId`. Does NOT revert if token doesn’t exist

  Requirements:

  * The contract is initialized.
</APIItemCompact>

#### _getApproved [toc] [#NonFungibleToken-_getApproved]
#### [!toc] [#NonFungibleToken-_getApproved]
<APIItemCompact
  circuitSig='_getApproved(tokenId: Uint<128>) → Either<ZswapCoinPublicKey, ContractAddress>'
  kind="circuit"
  complexity="k=10, rows=253"
  modulePrefix="NonFungibleToken"
>
  Returns the approved address for `tokenId`.
  Returns the zero address if `tokenId` is not minted.

  Requirements:

  * The contract is initialized.
</APIItemCompact>

#### _isAuthorized [toc] [#NonFungibleToken-_isAuthorized]
#### [!toc] [#NonFungibleToken-_isAuthorized]
<APIItemCompact
  circuitSig='_isAuthorized(owner: Either<ZswapCoinPublicKey, ContractAddress>, spender: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → Boolean'
  kind="circuit"
  complexity="k=11, rows=1098"
  stackParams="true"
  modulePrefix="NonFungibleToken"
>
  Returns whether `spender` is allowed to manage `owner`'s tokens,
  or `tokenId` in particular (ignoring whether it is owned by `owner`).

  Requirements:

  * The contract is initialized.

  <Callout type='warn'>
    This function assumes that `owner` is the actual owner of `tokenId` and does not verify this assumption.
  </Callout>
</APIItemCompact>

#### _checkAuthorized [toc] [#NonFungibleToken-_checkAuthorized]
#### [!toc] [#NonFungibleToken-_checkAuthorized]
<APIItemCompact
  circuitSig='_checkAuthorized(owner: Either<ZswapCoinPublicKey, ContractAddress>, spender: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → []'
  kind="circuit"
  complexity="k=11, rows=1121"
  stackParams="true"
  modulePrefix="NonFungibleToken"
>
  Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.

  Requirements:

  * The contract is initialized.
  * `spender` has approval from `owner` for `tokenId` OR `spender` has approval to manage all of `owner`'s assets.

  <Callout type='warn'>
    This function assumes that `owner` is the actual owner of `tokenId` and does not verify this assumption.
  </Callout>
</APIItemCompact>

#### _update [toc] [#NonFungibleToken-_update]
#### [!toc] [#NonFungibleToken-_update]
<APIItemCompact
  circuitSig='_checkAuthorized(owner: Either<ZswapCoinPublicKey, ContractAddress>, spender: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → []'
  kind="internal"
  complexity="k=12, rows=2049"
  stackParams="true"
  modulePrefix="NonFungibleToken"
>
  Transfers `tokenId` from its current owner to `to`,
  or alternatively mints (or burns) if the current owner (or `to`) is the zero address.
  Returns the owner of the `tokenId` before the update.

  Requirements:

  * The contract is initialized.
  * If `auth` is non 0, then this function will check that `auth` is either the owner of the token,
  or approved to operate on the token (by the owner).
</APIItemCompact>

#### _mint [toc] [#NonFungibleToken-_mint]
#### [!toc] [#NonFungibleToken-_mint]
<APIItemCompact
  circuitSig='_mint(to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → []'
  kind="circuit"
  complexity="k=10, rows=1013"
  modulePrefix="NonFungibleToken"
>
  Mints `tokenId` and transfers it to `to`.

  Requirements:

  * The contract is initialized.
  * `tokenId` must not exist.
  * `to` is not the zero address.
  * `to` is not a ContractAddress.
</APIItemCompact>

#### _unsafeMint [toc] [#NonFungibleToken-_unsafeMint]
#### [!toc] [#NonFungibleToken-_unsafeMint]
<APIItemCompact
  circuitSig='_unsafeMint(account: Either<ZswapCoinPublicKey, ContractAddress>, value: Uint<128>) → []'
  kind="circuit"
  complexity="k=10, rows=1010"
  modulePrefix="NonFungibleToken"
>
  Unsafe variant of [_mint](#NonFungibleToken-_mint) which allows transfers to contract addresses.

  Requirements:

  * Contract is initialized.
  * `tokenId` must not exist.
  * `to` is not the zero address.

  <Callout type='warn'>
    Transfers to contract addresses are considered unsafe because contract-to-contract calls are not currently supported.
    Tokens sent to a contract address may become irretrievable.
    Once contract-to-contract calls are supported, this circuit may be deprecated.
  </Callout>
</APIItemCompact>

#### _burn [toc] [#NonFungibleToken-_burn]
#### [!toc] [#NonFungibleToken-_burn]
<APIItemCompact
  circuitSig='_burn(tokenId: Uint<128>) → []'
  kind="circuit"
  complexity="k=10, rows=479"
  modulePrefix="NonFungibleToken"
>
  Destroys `tokenId`.
  The approval is cleared when the token is burned.
  This circuit does not check if the sender is authorized to operate on the token.

  Requirements:

  * The contract is initialized.
  * `tokenId` must exist.
</APIItemCompact>

#### _transfer [toc] [#NonFungibleToken-_transfer]
#### [!toc] [#NonFungibleToken-_transfer]
<APIItemCompact
  circuitSig='_transfer(from: Either<ZswapCoinPublicKey, ContractAddress>, to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → []'
  kind="circuit"
  complexity="k=11, rows=1224"
  stackParams="true"
  modulePrefix="NonFungibleToken"
>
  Transfers `tokenId` from `from` to `to`. As opposed to [transferFrom](#NonFungibleToken-transferFrom),
  this imposes no restrictions on `ownPublicKey()`.

  <Callout type='info'>
    Transfers to contract addresses are currently disallowed until contract-to-contract interactions are supported in Compact.
    This restriction prevents assets from being inadvertently locked in contracts that cannot currently handle token receipt.
  </Callout>

  Requirements:

  * The contract is initialized.
  * `to` is not the zero address.
  * `to` is not a ContractAddress.
  * `tokenId` token must be owned by `from`.
</APIItemCompact>

#### _unsafeTransfer [toc] [#NonFungibleToken-_unsafeTransfer]
#### [!toc] [#NonFungibleToken-__unsafeTransfer]
<APIItemCompact
  circuitSig='_unsafeTransfer(from: Either<ZswapCoinPublicKey, ContractAddress>, to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>) → []'
  kind="circuit"
  complexity="k=11, rows=1221"
  stackParams="true"
  modulePrefix="NonFungibleToken"
>
  Unsafe variant of [_transfer](#NonFungibleToken-_transfer) which allows transfers to contract addresses.

  Transfers `tokenId` from `from` to `to`. As opposed to [_unsafeTransferFrom](#NonFungibleToken-_unsafeTransferFrom), this imposes no restrictions on `ownPublicKey()`. It does NOT check if the recipient is a `ContractAddress`.

  <Callout type='warn'>
    Transfers to contract addresses are considered unsafe because contract-to-contract calls are not currently supported.
    Tokens sent to a contract address may become irretrievable.
    Once contract-to-contract calls are supported, this circuit may be deprecated.
  </Callout>

  Requirements:

  * Contract is initialized.
  * `to` is not the zero address.
  * `tokenId` token must be owned by `from`.
</APIItemCompact>

#### _approve [toc] [#NonFungibleToken-_approve]
#### [!toc] [#NonFungibleToken-_approve]
<APIItemCompact
  circuitSig='_approve(to: Either<ZswapCoinPublicKey, ContractAddress>, tokenId: Uint<128>, auth: Either<ZswapCoinPublicKey, ContractAddress>) → []'
  kind="circuit"
  complexity="k=11, rows=1109"
  stackParams="true"
  modulePrefix="NonFungibleToken"
>
  Approve `to` to operate on `tokenId`.

  Requirements:

  * The contract is initialized.
  * If `auth` is non 0, then this function will check that `auth` is either the owner of the token,
  or approved to operate on the token (by the owner).
</APIItemCompact>

#### _setApprovalForAll [toc] [#NonFungibleToken-_setApprovalForAll]
#### [!toc] [#NonFungibleToken-_setApprovalForAll]
<APIItemCompact
  circuitSig='_setApprovalForAll(owner: Either<ZswapCoinPublicKey, ContractAddress>, operator: Either<ZswapCoinPublicKey, ContractAddress>, approved: Boolean) → []'
  kind="circuit"
  complexity="k=10, rows=524"
  stackParams="true"
  modulePrefix="NonFungibleToken"
>
  Approve `operator` to operate on all of `owner` tokens

  Requirements:

  * The contract is initialized.
  * `operator` is not the zero address.
</APIItemCompact>

#### _requireOwned [toc] [#NonFungibleToken-_requireOwned]
#### [!toc] [#NonFungibleToken-_requireOwned]
<APIItemCompact
  circuitSig='_requireOwned(tokenId: Uint<128>) → Either<ZswapCoinPublicKey, ContractAddress>'
  kind="circuit"
  complexity="k=10, rows=288"
  modulePrefix="NonFungibleToken"
>
  Reverts if the `tokenId` doesn’t have a current owner (it hasn’t been minted, or it has been burned).
  Returns the owner.

  Requirements:

  * The contract is initialized.
  * `tokenId` must exist.
</APIItemCompact>
