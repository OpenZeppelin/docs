---
title: Presets
---

Presets are ready-to-deploy contracts provided by the library. Since presets are intended to be very simple
and as generic as possible, there’s no support for custom or complex contracts such as `ERC20Pausable` or `ERC721Mintable`.

<Callout>
For contract customization and combination of modules you can use [Wizard for Cairo](https://wizard.openzeppelin.com), our code-generation tool.
</Callout>

## Available presets

List of available presets and their corresponding [Sierra class hashes](https://docs.starknet.io/architecture-and-concepts/smart-contracts/class-hash/).

<Callout>
Class hashes were computed using class-hash-cairo-version.
</Callout>

| Name | Sierra Class Hash |
| --- | --- |
| `[AccountUpgradeable](/contracts-cairo/api/account#AccountUpgradeable)` | `AccountUpgradeable-class-hash` |
| `[ERC20Upgradeable](/contracts-cairo/api/erc20#ERC20Upgradeable)` | `ERC20Upgradeable-class-hash` |
| `[ERC721Upgradeable](/contracts-cairo/api/erc721#ERC721Upgradeable)` | `ERC721Upgradeable-class-hash` |
| `[ERC1155Upgradeable](/contracts-cairo/api/erc1155#ERC1155Upgradeable)` | `ERC1155Upgradeable-class-hash` |
| `[EthAccountUpgradeable](/contracts-cairo/api/account#EthAccountUpgradeable)` | `EthAccountUpgradeable-class-hash` |
| `[UniversalDeployer](/contracts-cairo/api/udc#UniversalDeployer)` | `UniversalDeployer-class-hash` |
| `[VestingWallet](/contracts-cairo/api/finance#VestingWallet)` | `VestingWallet-class-hash` |

<Callout>
[starkli](https://book.starkli.rs/introduction) class-hash command can be used to compute the class hash from a Sierra artifact.
</Callout>

## Usage

These preset contracts are ready-to-deploy which means they should already be declared on the Sepolia network.
Simply deploy the preset class hash and add the appropriate constructor arguments.
Deploying the ERC20Upgradeable preset with [starkli](https://book.starkli.rs/introduction), for example, will look like this:

```bash
starkli deploy {ERC20Upgradeable-class-hash} \
  <CONSTRUCTOR_ARGS> \
  --network="sepolia"
```

If a class hash has yet to be declared, copy/paste the preset contract code and declare it locally.
Start by [setting up a project](#set_up_your_project) and xref:index#install the_library[installing the Contracts for Cairo library].
Copy the target preset contract from the [presets directory](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v1.0.0/packages/presets/src) and paste it in the new project’s `src/lib.cairo` like this:

```cairo
// src/lib.cairo

#[starknet::contract]
mod ERC20Upgradeable {
    use openzeppelin_access::ownable::OwnableComponent;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use openzeppelin_upgrades::UpgradeableComponent;
    use openzeppelin_upgrades::interface::IUpgradeable;
    use starknet::{ContractAddress, ClassHash};

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);
    component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    // Upgradeable
    impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
        #[substorage(v0)]
        upgradeable: UpgradeableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        ERC20Event: ERC20Component::Event,
        #[flat]
        UpgradeableEvent: UpgradeableComponent::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        fixed_supply: u256,
        recipient: ContractAddress,
        owner: ContractAddress
    ) {
        self.ownable.initializer(owner);
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, fixed_supply);
    }

    #[abi(embed_v0)]
    impl UpgradeableImpl of IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            self.ownable.assert_only_owner();
            self.upgradeable.upgrade(new_class_hash);
        }
    }
}
```

Next, compile the contract.

```bash
scarb build
```

Finally, declare the preset.

```bash
starkli declare target/dev/my_project_ERC20Upgradeable.contract_class.json \
  --network="sepolia"
```
