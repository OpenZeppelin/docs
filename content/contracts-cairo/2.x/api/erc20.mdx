---
title: ERC20
---

This module provides interfaces, presets, and utilities related to ERC20 contracts.

For an overview of ERC20, read our [ERC20 guide](../erc20).

## Interfaces

import { UMBRELLA_VERSION } from "../utils/constants.js";

### `IERC20` [toc] [#IERC20]
<APIGithubLinkHeader
    moduleName="IERC20"
    link={`https://github.com/OpenZeppelin/cairo-contracts/blob/release-v${UMBRELLA_VERSION}/packages/token/src/erc20/interface.cairo`}
/>

```rust
use openzeppelin_token::erc20::interface::IERC20;
```

Interface of the IERC20 standard as defined in [EIP-20](https://eips.ethereum.org/EIPS/eip-20).

Functions

- [`total_supply()`](#IERC20-total_supply)
- [`balance_of(account)`](#IERC20-balance_of)
- [`allowance(owner, spender)`](#IERC20-allowance)
- [`transfer(recipient, amount)`](#IERC20-transfer)
- [`transfer_from(sender, recipient, amount)`](#IERC20-transfer_from)
- [`approve(spender, amount)`](#IERC20-approve)

Events

- [`Transfer(from, to, value)`](#IERC20-Transfer)
- [`Approval(owner, spender, value)`](#IERC20-Approval)

#### Functions [!toc] [#IERC20-Functions]

<APIItem
    functionSignature="total_supply() → u256"
    id="IERC20-total_supply"
    kind="external"
>
Returns the amount of tokens in existence.
</APIItem>

<APIItem
    functionSignature="balance_of(account: ContractAddress) → u256"
    id="IERC20-balance_of"
    kind="external"
>
Returns the amount of tokens owned by `account`.
</APIItem>

<APIItem
    functionSignature="allowance(owner: ContractAddress, spender: ContractAddress) → u256"
    id="IERC20-allowance"
    kind="external"
>
Returns the remaining number of tokens that `spender` is allowed to spend on behalf of `owner` through [transfer\_from](#transfer_from). This is zero by default.

This value changes when [approve](#IERC20-approve) or [transfer\_from](#IERC20-transfer_from) are called.
</APIItem>

<APIItem
    functionSignature="transfer(recipient: ContractAddress, amount: u256) → bool"
    id="IERC20-transfer"
    kind="external"
>
Moves `amount` tokens from the caller's token balance to `to`. Returns `true` on success, reverts otherwise.

Emits a [Transfer](#IERC20-Transfer) event.
</APIItem>

<APIItem
    functionSignature="transfer_from(sender: ContractAddress, recipient: ContractAddress, amount: u256) → bool"
    id="IERC20-transfer_from"
    kind="external"
>
Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns `true` on success, reverts otherwise.

Emits a [Transfer](#IERC20-Transfer) event.
</APIItem>

<APIItem
    functionSignature="approve(spender: ContractAddress, amount: u256) → bool"
    id="IERC20-approve"
    kind="external"
>
Sets `amount` as the allowance of `spender` over the caller's tokens. Returns `true` on success, reverts otherwise.

Emits an [Approval](#ERC20-Approval) event.
</APIItem>

#### Events [!toc] [#IERC20-Events]

<APIItem
    functionSignature="Transfer(from: ContractAddress, to: ContractAddress, value: u256)"
    id="IERC20-Transfer"
    kind="event"
>
Emitted when `value` tokens are moved from one address (`from`) to another (`to`).

Note that `value` may be zero.
</APIItem>

<APIItem
    functionSignature="Approval(owner: ContractAddress, spender: ContractAddress, value: u256)"
    id="IERC20-Approval"
    kind="event"
>
Emitted when the allowance of a `spender` for an `owner` is set. `value` is the new allowance.
</APIItem>

### `IERC20Metadata` [toc] [#IERC20Metadata]
<APIGithubLinkHeader
    moduleName="IERC20Metadata"
    link={`https://github.com/OpenZeppelin/cairo-contracts/blob/release-v${UMBRELLA_VERSION}/packages/token/src/erc20/interface.cairo`}
/>

```rust
use openzeppelin_token::erc20::interface::IERC20Metadata;
```

Interface for the optional metadata functions in [EIP-20](https://eips.ethereum.org/EIPS/eip-20).

Functions

- [`name()`](#IERC20Metadata-name)
- [`symbol()`](#IERC20Metadata-symbol)
- [`decimals()`](#IERC20Metadata-decimals)

#### Functions [!toc] [#IERC20Metadata-Functions]

<APIItem
    functionSignature="name() → ByteArray"
    id="IERC20Metadata-name"
    kind="external"
>
Returns the name of the token.
</APIItem>

<APIItem
    functionSignature="symbol() → ByteArray"
    id="IERC20Metadata-symbol"
    kind="external"
>
Returns the ticker symbol of the token.
</APIItem>

<APIItem
    functionSignature="decimals() → u8"
    id="IERC20Metadata-decimals"
    kind="external"
>
Returns the number of decimals the token uses - e.g. `8` means to divide the token amount by `100000000` to get its user-readable representation.

For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`).

Tokens usually opt for a value of `18`, imitating the relationship between Ether and Wei. This is the default value returned by this function. To create a custom decimals implementation, see [Customizing decimals](../erc20#customizing_decimals).

This information is only used for *display* purposes: it in no way affects any of the arithmetic of the contract.
</APIItem>

### `IERC20Permit` [toc] [#IERC20Permit]
<APIGithubLinkHeader
    moduleName="IERC20Permit"
    link={`https://github.com/OpenZeppelin/cairo-contracts/blob/release-v${UMBRELLA_VERSION}/packages/token/src/erc20/interface.cairo`}
/>

```rust
use openzeppelin_token::erc20::interface::IERC20Permit;
```

Interface of the ERC20Permit standard to support gasless token approvals as defined in [EIP-2612](https://eips.ethereum.org/EIPS/eip-2612).

Functions

- [`permit(owner, spender, amount, deadline, signature)`](#IERC20Permit-permit)
- [`nonces(owner)`](#IERC20Permit-nonces)
- [`DOMAIN_SEPARATOR()`](#IERC20Permit-DOMAIN_SEPARATOR)

#### Functions [!toc] [#IERC20Permit-Functions]

<APIItem
    functionSignature="permit(owner: ContractAddress, spender: ContractAddress, amount: u256, deadline: u64, signature: Span<felt252>)"
    id="IERC20Permit-permit"
    kind="external"
>
Sets `amount` as the allowance of `spender` over `owner`'s tokens after validating the signature.
</APIItem>

<APIItem
    functionSignature="nonces(owner: ContractAddress) → felt252"
    id="IERC20Permit-nonces"
    kind="external"
>
Returns the current nonce of `owner`. A nonce value must be included whenever a signature for `permit` call is generated.
</APIItem>

<APIItem
    functionSignature="DOMAIN_SEPARATOR() → felt252"
    id="IERC20Permit-DOMAIN_SEPARATOR"
    kind="external"
>
Returns the domain separator used in generating a message hash for `permit` signature. The domain hashing logic follows the [SNIP12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) standard.
</APIItem>

### `IERC4626` [toc] [#IERC4626]
<APIGithubLinkHeader
    moduleName="IERC4626"
    link={`https://github.com/OpenZeppelin/cairo-contracts/blob/release-v${UMBRELLA_VERSION}/packages/token/src/extensions/erc4626/interface.cairo`}
/>

```rust
use openzeppelin_token::erc20::extensions::erc4626::interface::IERC4626;
```

Interface of the IERC4626 standard as defined in [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626).

Functions

- [`asset()`](#IERC4626-asset)
- [`total_assets()`](#IERC4626-total_assets)
- [`convert_to_shares(assets)`](#IERC4626-convert_to_shares)
- [`convert_to_assets(shares)`](#IERC4626-convert_to_assets)
- [`max_deposit(receiver)`](#IERC4626-max_deposit)
- [`preview_deposit(assets)`](#IERC4626-preview_deposit)
- [`deposit(assets, receiver)`](#IERC4626-deposit)
- [`max_mint(receiver)`](#IERC4626-max_mint)
- [`preview_mint(shares)`](#IERC4626-preview_mint)
- [`mint(shares, receiver)`](#IERC4626-mint)
- [`max_withdraw(owner)`](#IERC4626-max_withdraw)
- [`preview_withdraw(assets)`](#IERC4626-preview_withdraw)
- [`withdraw(assets, receiver, owner)`](#IERC4626-withdraw)
- [`max_redeem(owner)`](#IERC4626-max_redeem)
- [`preview_redeem(shares)`](#IERC4626-preview_redeem)
- [`redeem(shares, receiver, owner)`](#IERC4626-redeem)

Events

- [`Deposit(sender, owner, assets, shares)`](#IERC4626-Deposit)
- [`Withdraw(sender, receiver, owner, assets, shares)`](#IERC4626-Withdraw)

#### Functions [!toc] [#IERC4626-Functions]

<APIItem
    functionSignature="asset() → ContractAddress"
    id="IERC4626-asset"
    kind="external"
>
Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.

Requirements:

- MUST be an ERC20 token contract.
- MUST NOT panic.
</APIItem>

<APIItem
    functionSignature="total_assets() → u256"
    id="IERC4626-total_assets"
    kind="external"
>
Returns the total amount of the underlying asset that is "managed" by Vault.

Requirements:

- SHOULD include any compounding that occurs from yield.
- MUST be inclusive of any fees that are charged against assets in the Vault.
- MUST NOT panic.
</APIItem>

<APIItem
    functionSignature="convert_to_shares(assets: u256) → u256"
    id="IERC4626-convert_to_shares"
    kind="external"
>
Returns the amount of shares that the Vault would exchange for the amount of `assets` provided irrespective of slippage or fees.

Requirements:

- MUST NOT be inclusive of any fees that are charged against assets in the Vault.
- MUST NOT show any variations depending on the caller.
- MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.
- MUST NOT panic unless due to integer overflow caused by an unreasonably large input.
- MUST round down towards 0.

This calculation MAY NOT reflect the "per-user" price-per-share, and instead should reflect the "average-user's" price-per-share, meaning what the average user should expect to see when exchanging to and from.
</APIItem>

<APIItem
    functionSignature="convert_to_assets(shares: u256) → u256"
    id="IERC4626-convert_to_assets"
    kind="external"
>
Returns the amount of assets that the Vault would exchange for the amount of `shares` provided irrespective of slippage or fees.

Requirements:

- MUST NOT be inclusive of any fees that are charged against assets in the Vault.
- MUST NOT show any variations depending on the caller.
- MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.
- MUST NOT panic unless due to integer overflow caused by an unreasonably large input.
- MUST round down towards 0.

This calculation MAY NOT reflect the "per-user" price-per-share, and instead should reflect the "average-user's" price-per-share, meaning what the average user should expect to see when exchanging to and from.
</APIItem>

<APIItem
    functionSignature="max_deposit(receiver: ContractAddress) → u256"
    id="IERC4626-max_deposit"
    kind="external"
>
Returns the maximum amount of the underlying asset that can be deposited into the Vault for `receiver`, through a deposit call.

Requirements:

- MUST return a limited value if receiver is subject to some deposit limit.
- MUST return 2 \** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.
- MUST NOT panic.
</APIItem>

<APIItem
    functionSignature="preview_deposit(assets: u256) → u256"
    id="IERC4626-preview_deposit"
    kind="external"
>
Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given current on-chain conditions.

Requirements:

- MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit call in the same transaction i.e. [IERC4626::deposit](#IERC4626-deposit) should return the same or more shares as `preview_deposit` if called in the same transaction.
- MUST NOT account for deposit limits like those returned from [IERC4626::max\_deposit](#IERC4626-max_deposit) and should always act as though the deposit would be accepted, regardless if the user has enough tokens approved, etc.
- MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.
- MUST NOT panic.

Any unfavorable discrepancy between [IERC4626::convert\_to\_shares](#IERC4626-convert_to_shares) and `preview_deposit` SHOULD be considered slippage in share price or some other type of condition, meaning the depositor will lose assets by depositing.
</APIItem>

<APIItem
    functionSignature="deposit(assets: u256, receiver: ContractAddress) → u256"
    id="IERC4626-deposit"
    kind="external"
>
Mints Vault shares to `receiver` by depositing exactly amount of `assets`.

Requirements:

- MUST emit the [IERC4626::Deposit](#IERC4626-Deposit) event.
- MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the deposit execution, and are accounted for during deposit.
- MUST panic if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the Vault contract, etc).

Most implementations will require pre-approval of the Vault with the Vault's underlying asset token.
</APIItem>

<APIItem
    functionSignature="max_mint(receiver: ContractAddress) → u256"
    id="IERC4626-max_mint"
    kind="external"
>
Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.

Requirements:

- MUST return a limited value if receiver is subject to some mint limit.
- MUST return 2 \** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.
- MUST NOT panic.
</APIItem>

<APIItem
    functionSignature="preview_mint(shares: u256) → u256"
    id="IERC4626-preview_mint"
    kind="external"
>
Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given current on-chain conditions.

Requirements:

- MUST return as close to and no fewer than the exact amount of assets that would be deposited in a `mint` call in the same transaction. I.e. [IERC4626::mint](#IERC4626-mint) should return the same or fewer assets as `preview_mint` if called in the same transaction.
- MUST NOT account for mint limits like those returned from [IERC4626::max\_mint](#IERC4626-max_mint) and should always act as though the mint would be accepted, regardless if the user has enough tokens approved, etc.
- MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.
- MUST NOT panic.

Any unfavorable discrepancy between [IERC4626::convert\_to\_assets](#IERC4626-convert_to_assets) and `preview_mint` SHOULD be considered slippage in share price or some other type of condition, meaning the depositor will lose assets by minting.
</APIItem>

<APIItem
    functionSignature="mint(shares: u256, receiver: ContractAddress) → u256"
    id="IERC4626-mint"
    kind="external"
>
Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.

Requirements:

- MUST emit the [IERC4626::Deposit](#IERC4626-Deposit) event.
- MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint execution, and are accounted for during mint.
- MUST panic if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not approving enough underlying tokens to the Vault contract, etc).

Most implementations will require pre-approval of the Vault with the Vault's underlying asset token.
</APIItem>

<APIItem
    functionSignature="max_withdraw(owner: ContractAddress) → u256"
    id="IERC4626-max_withdraw"
    kind="external"
>
Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the Vault, through a withdraw call.

Requirements:

- MUST return a limited value if owner is subject to some withdrawal limit or timelock.
- MUST NOT panic.
</APIItem>

<APIItem
    functionSignature="preview_withdraw(assets: u256) → u256"
    id="IERC4626-preview_withdraw"
    kind="external"
>
Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block, given current on-chain conditions.

Requirements:

- MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw call in the same transaction i.e. [IERC4626::withdraw](#IERC4626-withdraw) should return the same or fewer shares as `preview_withdraw` if called in the same transaction.
- MUST NOT account for withdrawal limits like those returned from [IERC4626::max\_withdraw](#IERC4626-max_withdraw) and should always act as though the withdrawal would be accepted, regardless if the user has enough shares, etc.
- MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.
- MUST NOT panic.

Any unfavorable discrepancy between [IERC4626::convert\_to\_shares](#IERC4626-convert_to_shares) and `preview_withdraw` SHOULD be considered slippage in share price or some other type of condition, meaning the depositor will lose assets by depositing.
</APIItem>

<APIItem
    functionSignature="withdraw(assets: u256, receiver: ContractAddress, owner: ContractAddress) → u256"
    id="IERC4626-withdraw"
    kind="external"
>
Burns shares from owner and sends exactly assets of underlying tokens to receiver.

Requirements:

- MUST emit the [IERC4626::Withdraw](#IERC4626-Withdraw) event.
- MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the withdraw execution, and are accounted for during withdraw.
- MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).

Some implementations will require pre-requesting to the Vault before a withdrawal may be performed. Those methods should be performed separately.
</APIItem>

<APIItem
    functionSignature="max_redeem(owner: ContractAddress) → u256"
    id="IERC4626-max_redeem"
    kind="external"
>
Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault, through a redeem call.

Requirements:

- MUST return a limited value if owner is subject to some withdrawal limit or timelock.
- MUST return `ERC20::balance_of(owner)` if `owner` is not subject to any withdrawal limit or timelock.
- MUST NOT panic.
</APIItem>

<APIItem
    functionSignature="preview_redeem(shares: u256) → u256"
    id="IERC4626-preview_redeem"
    kind="external"
>
Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block, given current on-chain conditions.

Requirements:

- MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call in the same transaction i.e. [IERC4626::redeem](#IERC4626-redeem) should return the same or more assets as preview\_redeem if called in the same transaction.
- MUST NOT account for redemption limits like those returned from [IERC4626::max\_redeem](#IERC4626-max_redeem) and should always act as though the redemption would be accepted, regardless if the user has enough shares, etc.
- MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.
- MUST NOT panic.

Any unfavorable discrepancy between [IERC4626::convert\_to\_assets](#IERC4626-convert_to_assets) and `preview_redeem` SHOULD be considered slippage in share price or some other type of condition, meaning the depositor will lose assets by redeeming.
</APIItem>

<APIItem
    functionSignature="redeem(shares: u256, receiver: ContractAddress, owner: ContractAddress) → u256"
    id="IERC4626-redeem"
    kind="external"
>
Burns exactly shares from owner and sends assets of underlying tokens to receiver.

Requirements:

- MUST emit the [IERC4626::Withdraw](#IERC4626-Withdraw) event.
- MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the redeem execution, and are accounted for during redeem.
- MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner not having enough shares, etc).

Some implementations will require pre-requesting to the Vault before a withdrawal may be performed. Those methods should be performed separately.
</APIItem>

#### Events [!toc] [#IERC4626-Events]

<APIItem
    functionSignature="Deposit(sender: ContractAddress, owner: ContractAddress, assets: u256, shares: u256)"
    id="IERC4626-Deposit"
    kind="event"
>
Emitted when `sender` exchanges `assets` for `shares` and transfers those `shares` to `owner`.
</APIItem>

<APIItem
    functionSignature="Withdraw(sender: ContractAddress, receiver: ContractAddress, owner: ContractAddress, assets: u256, shares: u256)"
    id="IERC4626-Withdraw"
    kind="event"
>
Emitted when `sender` exchanges `shares`, owned by `owner`, for `assets` and transfers those `assets` to `receiver`.
</APIItem>

## Core

### `ERC20Component` [toc] [#ERC20Component]
<APIGithubLinkHeader
    moduleName="ERC20Component"
    link={`https://github.com/OpenZeppelin/cairo-contracts/blob/release-v${UMBRELLA_VERSION}/packages/token/src/erc20/erc20.cairo`}
/>

```rust
use openzeppelin_token::erc20::ERC20Component;
```

ERC20 component extending [IERC20](#IERC20) and [IERC20Metadata](#IERC20Metadata).

See [Hooks](#ERC20Component-Hooks) to understand how are hooks used.

Hooks

#### ERC20HooksTrait [!toc] [#ERC20Component-ERC20HooksTrait]

- [`before_update(self, from, recipient, amount)`](#ERC20Component-before_update)
- [`after_update(self, from, recipient, amount)`](#ERC20Component-after_update)

[Embeddable Mixin Implementations](../components#mixins)

#### ERC20MixinImpl [!toc] [#ERC20Component-Embeddable-Impls-ERC20MixinImpl]

- [`ERC20Impl`](#ERC20Component-Embeddable-Impls-ERC20Impl)
- [`ERC20MetadataImpl`](#ERC20Component-Embeddable-Impls-ERC20MetadataImpl)
- [`ERC20CamelOnlyImpl`](#ERC20Component-Embeddable-Impls-ERC20CamelOnlyImpl)

Embeddable Implementations

#### ERC20Impl [!toc] [#ERC20Component-Embeddable-Impls-ERC20Impl]

- [`total_supply(self)`](#ERC20Component-total_supply)
- [`balance_of(self, account)`](#ERC20Component-balance_of)
- [`allowance(self, owner, spender)`](#ERC20Component-allowance)
- [`transfer(self, recipient, amount)`](#ERC20Component-transfer)
- [`transfer_from(self, sender, recipient, amount)`](#ERC20Component-transfer_from)
- [`approve(self, spender, amount)`](#ERC20Component-approve)

#### ERC20MetadataImpl [!toc] [#ERC20Component-Embeddable-Impls-ERC20MetadataImpl]

- [`name(self)`](#ERC20Component-name)
- [`symbol(self)`](#ERC20Component-symbol)
- [`decimals(self)`](#ERC20Component-decimals)

#### ERC20CamelOnlyImpl [!toc] [#ERC20Component-Embeddable-Impls-ERC20CamelOnlyImpl]

- [`totalSupply(self)`](#ERC20Component-totalSupply)
- [`balanceOf(self, account)`](#ERC20Component-balanceOf)
- [`transferFrom(self, sender, recipient, amount)`](#ERC20Component-transferFrom)

#### ERC20PermitImpl [!toc] [#ERC20Component-Embeddable-Impls-ERC20PermitImpl]

- [`permit(self, owner, spender, amount, deadline, signature)`](#ERC20Component-permit)
- [`nonces(self, owner)`](#ERC20Component-nonces)
- [`DOMAIN_SEPARATOR(self)`](#ERC20Component-DOMAIN_SEPARATOR)

#### SNIP12MetadataExternalImpl [!toc] [#ERC20Component-Embeddable-Impls-SNIP12MetadataExternalImpl]

- [`snip12_metadata(self)`](#ERC20Component-snip12_metadata)

Internal implementations

#### InternalImpl [!toc] [#ERC20Component-InternalImpl]

- [`initializer(self, name, symbol)`](#ERC20Component-initializer)
- [`mint(self, recipient, amount)`](#ERC20Component-mint)
- [`burn(self, account, amount)`](#ERC20Component-burn)
- [`update(self, from, to, amount)`](#ERC20Component-update)
- [`_transfer(self, sender, recipient, amount)`](#ERC20Component-_transfer)
- [`_approve(self, owner, spender, amount)`](#ERC20Component-_approve)
- [`_spend_allowance(self, owner, spender, amount)`](#ERC20Component-_spend_allowance)

Events

- [`Transfer(from, to, value)`](#ERC20Component-Transfer)
- [`Approval(owner, spender, value)`](#ERC20Component-Approval)

#### Hooks [!toc] [#ERC20Component-Hooks]

Hooks are functions which implementations can extend the functionality of the component source code. Every contract using ERC20Component is expected to provide an implementation of the ERC20HooksTrait. For basic token contracts, an empty implementation with no logic must be provided.

You can use `openzeppelin_token::erc20::ERC20HooksEmptyImpl` which is already available as part of the library for this purpose.

<APIItem
    functionSignature="before_update(ref self: ContractState, from: ContractAddress, recipient: ContractAddress, amount: u256)"
    id="ERC20Component-before_update"
    kind="hook"
>
Function executed at the beginning of the [update](#ERC20Component-update) function prior to any other logic.
</APIItem>

<APIItem
    functionSignature="after_update(ref self: ContractState, from: ContractAddress, recipient: ContractAddress, amount: u256)"
    id="ERC20Component-after_update"
    kind="hook"
>
Function executed at the end of the [update](#ERC20Component-update) function.
</APIItem>

#### Embeddable functions [!toc] [#ERC20Component-Embeddable-Functions]

<APIItem
    functionSignature="total_supply(@self: ContractState) → u256"
    id="ERC20Component-total_supply"
    kind="external"
>
See [IERC20::total\_supply](#IERC20-total_supply).
</APIItem>

<APIItem
    functionSignature="balance_of(@self: ContractState, account: ContractAddress) → u256"
    id="ERC20Component-balance_of"
    kind="external"
>
See [IERC20::balance\_of](#IERC20-balance_of).
</APIItem>

<APIItem
    functionSignature="allowance(@self: ContractState, owner: ContractAddress, spender: ContractAddress) → u256"
    id="ERC20Component-allowance"
    kind="external"
>
See [IERC20::allowance](#IERC20-allowance).
</APIItem>

<APIItem
    functionSignature="transfer(ref self: ContractState, recipient: ContractAddress, amount: u256) → bool"
    id="ERC20Component-transfer"
    kind="external"
>
See [IERC20::transfer](#IERC20-transfer).

Requirements:

- `recipient` cannot be the zero address.
- The caller must have a balance of at least `amount`.
</APIItem>

<APIItem
    functionSignature="transfer_from(ref self: ContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256) → bool"
    id="ERC20Component-transfer_from"
    kind="external"
>
See [IERC20::transfer\_from](#IERC20-transfer_from).

Requirements:

- `sender` cannot be the zero address.
- `sender` must have a balance of at least `amount`.
- `recipient` cannot be the zero address.
- The caller must have allowance for `sender`'s tokens of at least `amount`.
</APIItem>

<APIItem
    functionSignature="approve(ref self: ContractState, spender: ContractAddress, amount: u256) → bool"
    id="ERC20Component-approve"
    kind="external"
>
See [IERC20::approve](#IERC20-approve).

Requirements:

- `spender` cannot be the zero address.
</APIItem>

<APIItem
    functionSignature="name() → ByteArray"
    id="ERC20Component-name"
    kind="external"
>
See [IERC20Metadata::name](#IERC20Metadata-name).
</APIItem>

<APIItem
    functionSignature="symbol() → ByteArray"
    id="ERC20Component-symbol"
    kind="external"
>
See [IERC20Metadata::symbol](#IERC20Metadata-symbol).
</APIItem>

<APIItem
    functionSignature="decimals() → u8"
    id="ERC20Component-decimals"
    kind="external"
>
See [IERC20Metadata::decimals](#IERC20Metadata-decimals).
</APIItem>

<APIItem
    functionSignature="totalSupply(self: @ContractState) → u256"
    id="ERC20Component-totalSupply"
    kind="external"
>
See [IERC20::total\_supply](#IERC20-total_supply).

Supports the Cairo v0 convention of writing external methods in camelCase as discussed [here](https://github.com/OpenZeppelin/cairo-contracts/discussions/34).
</APIItem>

<APIItem
    functionSignature="balanceOf(self: @ContractState, account: ContractAddress) → u256"
    id="ERC20Component-balanceOf"
    kind="external"
>
See [IERC20::balance\_of](#IERC20-balance_of).

Supports the Cairo v0 convention of writing external methods in camelCase as discussed [here](https://github.com/OpenZeppelin/cairo-contracts/discussions/34).
</APIItem>

<APIItem
    functionSignature="transferFrom(ref self: ContractState, sender: ContractAddress, recipient: ContractAddress) → bool"
    id="ERC20Component-transferFrom"
    kind="external"
>
See [IERC20::transfer\_from](#IERC20-transfer_from).

Supports the Cairo v0 convention of writing external methods in camelCase as discussed [here](https://github.com/OpenZeppelin/cairo-contracts/discussions/34).
</APIItem>

<APIItem
    functionSignature="permit(ref self: ContractState, owner: ContractAddress, spender: ContractAddress, amount: u256, deadline: u64, signature: Span<felt252>) → bool"
    id="ERC20Component-permit"
    kind="external"
>
Sets `amount` as the allowance of `spender` over `owner`'s tokens after validating the signature.

Requirements:

- `owner` is a deployed account contract.
- `spender` is not the zero address.
- `deadline` is not a timestamp in the past.
- `signature` is a valid signature that can be validated with a call to `owner` account.
- `signature` must use the current nonce of the `owner`.

Emits an [Approval](#ERC20-Approval) event. Every successful call increases \`owner's nonce by one.
</APIItem>

<APIItem
    functionSignature="nonces(self: @ContractState, owner: ContractAddress) → felt252"
    id="ERC20Component-nonces"
    kind="external"
>
Returns the current nonce of `owner`. A nonce value must be included whenever a signature for `permit` call is generated.
</APIItem>

<APIItem
    functionSignature="DOMAIN_SEPARATOR(self: @ContractState) → felt252"
    id="ERC20Component-DOMAIN_SEPARATOR"
    kind="external"
>
Returns the domain separator used in generating a message hash for `permit` signature. The domain hashing logic follows the [SNIP12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) standard.
</APIItem>

<APIItem
    functionSignature="snip12_metadata(self: @ContractState) → (felt252, felt252)"
    id="ERC20Component-snip12_metadata"
    kind="external"
>
Returns the domain name and version used to generate the message hash for permit signature.

The returned tuple contains:

- `t.0`: The name used in the [SNIP12Metadata](./utilities#snip12) implementation.
- `t.1`: The version used in the [SNIP12Metadata](./utilities#snip12) implementation.
</APIItem>

#### Internal functions [!toc] [#ERC20Component-Internal-Functions]

<APIItem
    functionSignature="initializer(ref self: ContractState, name: ByteArray, symbol: ByteArray)"
    id="ERC20Component-initializer"
    kind="internal"
>
Initializes the contract by setting the token name and symbol. This should be used inside of the contract's constructor.
</APIItem>

<APIItem
    functionSignature="mint(ref self: ContractState, recipient: ContractAddress, amount: u256)"
    id="ERC20Component-mint"
    kind="internal"
>
Creates an `amount` number of tokens and assigns them to `recipient`.

Emits a [Transfer](#ERC20Component-Transfer) event with `from` being the zero address.

Requirements:

- `recipient` cannot be the zero address.
</APIItem>

<APIItem
    functionSignature="burn(ref self: ContractState, account: ContractAddress, amount: u256)"
    id="ERC20Component-burn"
    kind="internal"
>
Destroys `amount` number of tokens from `account`.

Emits a [Transfer](#ERC20Component-Transfer) event with `to` set to the zero address.

Requirements:

- `account` cannot be the zero address.
</APIItem>

<APIItem
    functionSignature="update(ref self: ContractState, from: ContractAddress, to: ContractAddress, amount: u256)"
    id="ERC20Component-update"
    kind="internal"
>
Transfers an `amount` of tokens from `from` to `to`, or alternatively mints (or burns) if `from` (or `to`) is the zero address.

This function can be extended using the [ERC20HooksTrait](#ERC20Component-ERC20HooksTrait), to add functionality before and/or after the transfer, mint, or burn.

Emits a [Transfer](#ERC20Component-Transfer) event.
</APIItem>

<APIItem
    functionSignature="_transfer(ref self: ContractState, sender: ContractAddress, recipient: ContractAddress, amount: u256)"
    id="ERC20Component-_transfer"
    kind="internal"
>
Moves `amount` of tokens from `from` to `to`.

This internal function does not check for access permissions but can be useful as a building block, for example to implement automatic token fees, slashing mechanisms, etc.

Emits a [Transfer](#ERC20Component-Transfer) event.

Requirements:

- `from` cannot be the zero address.
- `to` cannot be the zero address.
- `from` must have a balance of at least `amount`.
</APIItem>

<APIItem
    functionSignature="_approve(ref self: ContractState, owner: ContractAddress, spender: ContractAddress, amount: u256)"
    id="ERC20Component-_approve"
    kind="internal"
>
Sets `amount` as the allowance of `spender` over `owner`'s tokens.

This internal function does not check for access permissions but can be useful as a building block, for example to implement automatic allowances on behalf of other addresses.

Emits an [Approval](#ERC20Component-Approval) event.

Requirements:

- `owner` cannot be the zero address.
- `spender` cannot be the zero address.
</APIItem>

<APIItem
    functionSignature="_spend_allowance(ref self: ContractState, owner: ContractAddress, spender: ContractAddress, amount: u256)"
    id="ERC20Component-_spend_allowance"
    kind="internal"
>
Updates `owner`'s allowance for `spender` based on spent `amount`.

This internal function does not update the allowance value in the case of infinite allowance.

Possibly emits an [Approval](#ERC20Component-Approval) event.
</APIItem>

#### Events [!toc] [#ERC20Component-Events]

<APIItem
    functionSignature="Transfer(from: ContractAddress, to: ContractAddress, value: u256)"
    id="ERC20Component-Transfer"
    kind="event"
>
See [IERC20::Transfer](#IERC20-Transfer).
</APIItem>

<APIItem
    functionSignature="Approval(owner: ContractAddress, spender: ContractAddress, value: u256)"
    id="ERC20Component-Approval"
    kind="event"
>
See [IERC20::Approval](#IERC20-Approval).
</APIItem>

## Extensions

### `ERC4626Component` [toc] [#ERC4626Component]
<APIGithubLinkHeader
    moduleName="ERC4626Component"
    link={`https://github.com/OpenZeppelin/cairo-contracts/blob/release-v${UMBRELLA_VERSION}/packages/token/src/erc20/extensions/erc4626/interface.cairo#L19`}
/>

```rust
use openzeppelin_token::erc20::extensions::erc4626::ERC4626Component;
```

Extension of ERC20 that implements the [IERC4626](#IERC4626) interface which allows the minting and burning of "shares" in exchange for an underlying "asset." The component leverages traits to configure fees, limits, and decimals.

[Immutable Component Config](../components#immutable-config)

#### constants [!toc] [#ERC4626Component-constants]

- [`UNDERLYING_DECIMALS`](#ERC4626Component-IC-UNDERLYING_DECIMALS)
- [`DECIMALS_OFFSET`](#ERC4626Component-IC-DECIMALS_OFFSET)

#### functions [!toc] [#ERC4626Component-functions]

- [`validate()`](#ERC4626Component-IC-validate)

Hooks

#### FeeConfigTrait [!toc] [#ERC4626Component-FeeConfigTrait]

- [`calculate_deposit_fee(self, assets, shares)`](#ERC4626Component-calculate_deposit_fee)
- [`calculate_mint_fee(self, assets, shares)`](#ERC4626Component-calculate_mint_fee)
- [`calculate_withdraw_fee(self, assets, shares)`](#ERC4626Component-calculate_withdraw_fee)
- [`calculate_redeem_fee(self, assets, shares)`](#ERC4626Component-calculate_redeem_fee)

#### LimitConfigTrait [!toc] [#ERC4626Component-LimitConfigTrait]

- [`deposit_limit(self, receiver)`](#ERC4626Component-deposit_limit)
- [`mint_limit(self, receiver)`](#ERC4626Component-mint_limit)
- [`withdraw_limit(self, owner)`](#ERC4626Component-withdraw_limit)
- [`redeem_limit(self, owner)`](#ERC4626Component-redeem_limit)

#### ERC4626HooksTrait [!toc] [#ERC4626Component-ERC4626HooksTrait]

- [`before_deposit(self, caller, receiver, assets, shares, fee)`](#ERC4626Component-before_deposit)
- [`after_deposit(self, caller, receiver, assets, shares, fee)`](#ERC4626Component-after_deposit)
- [`before_withdraw(self, caller, receiver, owner, assets, shares, fee)`](#ERC4626Component-before_withdraw)
- [`after_withdraw(self, caller, receiver, owner, assets, shares, fee)`](#ERC4626Component-after_withdraw)

#### AssetsManagementTrait [!toc] [#ERC4626Component-AssetsManagementTrait]

- [`get_total_assets(self)`](#ERC4626Component-get_total_assets)
- [`transfer_assets_in(self, from, assets)`](#ERC4626Component-transfer_assets_in)
- [`transfer_assets_out(self, to, assets)`](#ERC4626Component-transfer_assets_out)

Embeddable Implementations

#### ERC4626Impl [!toc] [#ERC4626Component-Embeddable-Impls-ERC4626Impl]

- [`asset(self)`](#ERC4626Component-asset)
- [`total_assets(self)`](#ERC4626Component-total_assets)
- [`convert_to_shares(self, assets)`](#ERC4626Component-convert_to_shares)
- [`convert_to_assets(self, shares)`](#ERC4626Component-convert_to_assets)
- [`max_deposit(self, receiver)`](#ERC4626Component-max_deposit)
- [`preview_deposit(self, assets)`](#ERC4626Component-preview_deposit)
- [`deposit(self, assets, receiver)`](#ERC4626Component-deposit)
- [`max_mint(self, receiver)`](#ERC4626Component-max_mint)
- [`preview_mint(self, shares)`](#ERC4626Component-preview_mint)
- [`mint(self, shares, receiver)`](#ERC4626Component-mint)
- [`max_withdraw(self, owner)`](#ERC4626Component-max_withdraw)
- [`preview_withdraw(self, assets)`](#ERC4626Component-preview_withdraw)
- [`withdraw(self, assets, receiver, owner)`](#ERC4626Component-withdraw)
- [`max_redeem(self, owner)`](#ERC4626Component-max_redeem)
- [`preview_redeem(self, shares)`](#ERC4626Component-preview_redeem)
- [`redeem(self, shares, receiver, owner)`](#ERC4626Component-redeem)

#### ERC20Impl [!toc] [#ERC4626Component-Embeddable-Impls-ERC20Impl]

- [`total_supply(self)`](#ERC20Component-total_supply)
- [`balance_of(self, account)`](#ERC20Component-balance_of)
- [`allowance(self, owner, spender)`](#ERC20Component-allowance)
- [`transfer(self, recipient, amount)`](#ERC20Component-transfer)
- [`transfer_from(self, sender, recipient, amount)`](#ERC20Component-transfer_from)
- [`approve(self, spender, amount)`](#ERC20Component-approve)

#### ERC4626MetadataImpl [!toc] [#ERC4626Component-Embeddable-Impls-ERC4626MetadataImpl]

- [`name(self)`](#ERC4626Component-name)
- [`symbol(self)`](#ERC4626Component-symbol)
- [`decimals(self)`](#ERC4626Component-decimals)

Internal functions

#### InternalImpl [!toc] [#ERC4626Component-InternalImpl]

- [`initializer(self, asset_address)`](#ERC4626Component-initializer)
- [`_deposit(self, caller, receiver, assets, shares)`](#ERC4626Component-_deposit)
- [`_withdraw(self, caller, receiver, owner, assets, shares)`](#ERC4626Component-_withdraw)
- [`_convert_to_shares(self, assets, rounding)`](#ERC4626Component-_convert_to_shares)
- [`_convert_to_assets(self, shares, rounding)`](#ERC4626Component-_convert_to_assets)

#### Immutable Config [!toc] [#ERC4626Component-Immutable-Config]

<APIItem
    functionSignature="UNDERLYING_DECIMALS: u128"
    id="ERC4626Component-IC-UNDERLYING_DECIMALS"
    kind="constant"
>
Should match the underlying asset's decimals. The default value is `18`.
</APIItem>

<APIItem
    functionSignature="DECIMALS_OFFSET: u128"
    id="ERC4626Component-IC-DECIMALS_OFFSET"
    kind="constant"
>
Corresponds to the representational offset between `UNDERLYING_DECIMALS` and the vault decimals. The greater the offset, the more expensive it is for attackers to execute an inflation attack.
</APIItem>

<APIItem
    functionSignature="validate()"
    id="ERC4626Component-IC-validate"
    kind="internal"
>
Validates the given implementation of the contract's configuration.

Requirements:

- `UNDERLYING_DECIMALS` + `DECIMALS_OFFSET` cannot exceed 255 (max u8).

This function is called by the contract's initializer.
</APIItem>

#### Hooks [!toc] [#ERC4626Component-Hooks]

Hooks are functions which implementations can extend the functionality of the component source code. Every contract using ERC4626Component is expected to provide an implementation of the ERC4626HooksTrait. For basic token contracts, an empty implementation with no logic must be provided.

You can use `openzeppelin_token::erc20::extensions::erc4626::ERC4626EmptyHooks` which is already available as part of the library for this purpose.

#### FeeConfigTrait [!toc] [#ERC4626Component-FeeConfigTrait]

The logic for calculating entry and exit fees is expected to be defined at the contract level. Defaults to no entry or exit fees.

The FeeConfigTrait hooks directly into the preview methods of the ERC4626 component. The preview methods must return as close to the exact amount of shares or assets as possible if the actual (previewed) operation occurred in the same transaction (according to [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec). All operations use their corresponding preview method as the value of assets or shares being moved to or from the user. The fees calculated in FeeConfigTrait are used to adjust the final asset and share amounts used in both the preview and the actual operations.

To transfer fees, this trait needs to be coordinated with `ERC4626Component::ERC4626Hooks`.

See implementation examples:

- Contract charging fees in assets: [ERC4626AssetsFeesMock](https://github.com/OpenZeppelin/cairo-contracts/tree/main/packages/test_common/src/mocks/erc4626.cairo#L253)
- Contract charging fees in shares: [ERC4626SharesFeesMock](https://github.com/OpenZeppelin/cairo-contracts/tree/main/packages/test_common/src/mocks/erc4626.cairo#L426)

<APIItem
    functionSignature="calculate_deposit_fee(self: @ContractState, assets: u256, shares: u256) → Option<Fee>"
    id="ERC4626Component-calculate_deposit_fee"
    kind="hook"
>
Calculates the entry fee for a deposit during [preview\_deposit](#ERC4626Component-preview_deposit). The returned fee affects the final asset and share amounts. Fees are not transferred automatically and must be handled in the [after\_deposit](#ERC4626Component-after_deposit) hook: asset fees should be transferred from the vault's management to the fee recipient, while share fees should be minted to the fee recipient.
</APIItem>

<APIItem
    functionSignature="calculate_mint_fee(self: @ContractState, assets: u256, shares: u256) → Option<Fee>"
    id="ERC4626Component-calculate_mint_fee"
    kind="hook"
>
Calculates the entry fee for a mint during [preview\_mint](#ERC4626Component-preview_mint). The returned fee affects the final asset and share amounts. Fees are not transferred automatically and must be handled in the [after\_deposit](#ERC4626Component-after_deposit) hook: asset fees should be transferred from the vault's management to the fee recipient, while share fees should be minted to the fee recipient.
</APIItem>

<APIItem
    functionSignature="calculate_withdraw_fee(self: @ContractState, assets: u256, shares: u256) → Option<Fee>"
    id="ERC4626Component-calculate_withdraw_fee"
    kind="hook"
>
Calculates the exit fee for a withdraw during [preview\_withdraw](#ERC4626Component-preview_withdraw). The returned fee affects the final asset and share amounts. Fees are not transferred automatically and must be handled in the [before\_withdraw](#ERC4626Component-before_withdraw) hook: asset fees should be transferred from the vault's management to the fee recipient, while share fees should be transferred from the owner to the fee recipient.
</APIItem>

<APIItem
    functionSignature="calculate_redeem_fee(self: @ContractState, assets: u256, shares: u256) → Option<Fee>"
    id="ERC4626Component-calculate_redeem_fee"
    kind="hook"
>
Calculates the exit fee for a redeem during [preview\_redeem](#ERC4626Component-preview_redeem). The returned fee affects the final asset and share amounts. Fees are not transferred automatically and must be handled in the [before\_withdraw](#ERC4626Component-before_withdraw) hook: asset fees should be transferred from the vault's management to the fee recipient, while share fees should be transferred from the owner to the fee recipient.
</APIItem>

#### LimitConfigTrait [!toc] [#ERC4626Component-LimitConfigTrait]

Sets limits to the target exchange type and is expected to be defined at the contract level. These limits correspond directly to the `max_<OPERATION>` i.e. `deposit_limit` → `max_deposit`.

The [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec states that the `max_<OPERATION>` methods must take into account all global and user-specific limits. If an operation is disabled (even temporarily), the corresponding limit MUST be `0` and MUST NOT panic.

<APIItem
    functionSignature="deposit_limit(ref self: ContractState, receiver: ContractAddress) → Option<u256>"
    id="ERC4626Component-deposit_limit"
    kind="hook"
>
The max deposit allowed.

Defaults (`Option::None`) to 2 \** 256 - 1.
</APIItem>

<APIItem
    functionSignature="mint_limit(ref self: ContractState, receiver: ContractAddress) → Option<u256>"
    id="ERC4626Component-mint_limit"
    kind="hook"
>
The max mint allowed.

Defaults (`Option::None`) to 2 \** 256 - 1.
</APIItem>

<APIItem
    functionSignature="withdraw_limit(ref self: ContractState, owner: ContractAddress) → Option<u256>"
    id="ERC4626Component-withdraw_limit"
    kind="hook"
>
The max withdraw allowed.

Defaults (`Option::None`) to the full asset balance of `owner` converted from shares.
</APIItem>

<APIItem
    functionSignature="redeem_limit(ref self: ContractState, owner: ContractAddress) → Option<u256>"
    id="ERC4626Component-redeem_limit"
    kind="hook"
>
The max redeem allowed.

Defaults (`Option::None`) to the full asset balance of `owner`.
</APIItem>

#### ERC4626HooksTrait [!toc] [#ERC4626Component-ERC4626HooksTrait]

Allows contracts to hook logic into deposit and withdraw transactions. This is where contracts can transfer fees.

ERC4626 preview methods must be inclusive of any entry or exit fees. Fees are calculated using [FeeConfigTrait](#ERC4626Component-FeeConfigTrait) methods and automatically adjust the final asset and share amounts. Fee transfers are handled in `ERC4626HooksTrait` methods.

Special care must be taken when calling external contracts in these hooks. In that case, consider implementing reentrancy protections. For example, in the `withdraw` flow, the `withdraw_limit` is checked **before** the `before_withdraw` hook is invoked. If this hook performs a reentrant call that invokes `withdraw` again, the subsequent check on `withdraw_limit` will be done before the first withdrawal's core logic (e.g., burning shares and transferring assets) is executed. This could lead to bypassing withdrawal constraints or draining funds.

See the [ERC4626AssetsFeesMock](https://github.com/OpenZeppelin/cairo-contracts/tree/main/packages/test_common/src/mocks/erc4626.cairo#L253) and [ERC4626SharesFeesMock](https://github.com/OpenZeppelin/cairo-contracts/tree/main/packages/test_common/src/mocks/erc4626.cairo#L426) examples.

<APIItem
    functionSignature="before_deposit(ref self: ContractState, caller: ContractAddress, receiver: ContractAddress, assets: u256, shares: u256, fee: Option<Fee>)"
    id="ERC4626Component-before_deposit"
    kind="hook"
>
Hooks into [\_deposit](#ERC4626Component-_deposit).

Executes logic before transferring assets and minting shares. The fee is calculated via [FeeConfigTrait](#ERC4626Component-FeeConfigTrait). Assets and shares represent the actual amounts the user will spend and receive, respectively. Asset fees are included in assets; share fees are excluded from shares.
</APIItem>

<APIItem
    functionSignature="after_deposit(ref self: ContractState, caller: ContractAddress, receiver: ContractAddress, assets: u256, shares: u256, fee: Option<Fee>)"
    id="ERC4626Component-after_deposit"
    kind="hook"
>
Hooks into [\_deposit](#ERC4626Component-_deposit).

Executes logic after transferring assets and minting shares. The fee is calculated via [FeeConfigTrait](#ERC4626Component-FeeConfigTrait). Assets and shares represent the actual amounts the user will spend and receive, respectively. Asset fees are included in assets; share fees are excluded from shares.
</APIItem>

<APIItem
    functionSignature="before_withdraw(ref self: ContractState, caller: ContractAddress, receiver: ContractAddress, owner: ContractAddress, assets: u256, shares: u256, fee: Option<Fee>)"
    id="ERC4626Component-before_withdraw"
    kind="hook"
>
Hooks into [\_withdraw](#ERC4626Component-_withdraw).

Executes logic before burning shares and transferring assets. The fee is calculated via [FeeConfigTrait](#ERC4626Component-FeeConfigTrait). Assets and shares represent the actual amounts the user will receive and spend, respectively. Asset fees are excluded from assets; share fees are included in shares.
</APIItem>

<APIItem
    functionSignature="after_withdraw(ref self: ContractState, caller: ContractAddress, receiver: ContractAddress, owner: ContractAddress, assets: u256, shares: u256, fee: Option<Fee>)"
    id="ERC4626Component-after_withdraw"
    kind="hook"
>
Hooks into [\_withdraw](#ERC4626Component-_withdraw).

Executes logic after burning shares and transferring assets. The fee is calculated via [FeeConfigTrait](#ERC4626Component-FeeConfigTrait). Assets and shares represent the actual amounts the user will receive and spend, respectively. Asset fees are excluded from assets; share fees are included in shares.
</APIItem>

#### AssetsManagementTrait [!toc] [#ERC4626Component-AssetsManagementTrait]

Defines how the ERC4626 vault manages its underlying assets. This trait provides the core asset management functionality for the vault, abstracting the actual storage and transfer mechanisms. It enables two primary implementation patterns:

1. **Self-managed assets**: The vault contract holds assets directly on its own address. This is the default behavior provided by `ERC4626SelfAssetsManagement` implementation.
2. **External vault**: Assets are managed by an external contract, allowing for more complex asset management strategies. The exact implementation is expected to be defined by the contract implementing the ERC4626 component.

The trait methods are called during deposit, withdrawal, and total assets calculations, ensuring that the vault's share pricing remains accurate regardless of the underlying asset management strategy.

Implementations must ensure that `get_total_assets` returns the actual amount of assets that can be withdrawn by users. Inaccurate reporting can lead to incorrect share valuations and potential economic attacks.

See implementation examples:

- Self-managed vault: [ERC4626SelfAssetsManagement](https://github.com/OpenZeppelin/cairo-contracts/tree/main/packages/token/src/erc20/extensions/erc4626/erc4626.cairo#L760).
- External vault: [ERC4626ExternalAssetsManagement](https://github.com/OpenZeppelin/cairo-contracts/tree/main/packages/test_common/src/mocks/erc4626.cairo#L92).

<APIItem
    functionSignature="get_total_assets(self: @ContractState) → u256"
    id="ERC4626Component-get_total_assets"
    kind="hook"
>
Returns the total amount of underlying assets under the vault's management. Used for share price calculations and determining the vault's total value.

This method should return the actual amount of assets that the vault controls and that can be used to satisfy withdrawal requests. For self-managed vaults, this is typically the vault contract's token balance. For external vaults, this should include any assets deposited in external protocols, minus any that are locked or unredeemable.

The accuracy of this method is critical for proper vault operation: - Overreporting can lead to share dilution and user losses. - Underreporting can lead to share inflation and potential economic attacks.
</APIItem>

<APIItem
    functionSignature="transfer_assets_in(ref self: ContractState, from: ContractAddress, assets: u256)"
    id="ERC4626Component-transfer_assets_in"
    kind="hook"
>
Transfers assets from an external address into the vault's management. Called during `deposit` and `mint` operations.

This method should handle the actual transfer of underlying assets from the `from` address into the vault's control. For self-managed vaults, this typically means transferring tokens to the vault contract's address. For external vaults, this might involve transferring into an external contract.

Requirements:

- MUST transfer exactly `assets` amount of the underlying token.
- SHOULD revert if the transfer fails or insufficient allowance/balance.
</APIItem>

<APIItem
    functionSignature="transfer_assets_out(ref self: ContractState, to: ContractAddress, assets: u256)"
    id="ERC4626Component-transfer_assets_out"
    kind="hook"
>
Transfers assets from the vault's management to an external address. Called during withdraw and redeem operations.

This method should handle the actual transfer of underlying assets from the vault's control to the `to` address. For self-managed vaults, this typically means transferring tokens from the vault contract's address. For external vaults, this might involve withdrawing from an external contract first.

Requirements:

- MUST transfer exactly `assets` amount of the underlying token.
- SHOULD revert if insufficient assets are available or transfer fails.
</APIItem>

#### Embeddable functions [!toc] [#ERC4626Component-Embeddable-Functions]

<APIItem
    functionSignature="asset(self: @ContractState) → ContractAddress"
    id="ERC4626Component-asset"
    kind="external"
>
Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.
</APIItem>

<APIItem
    functionSignature="total_assets(self: @ContractState) → u256"
    id="ERC4626Component-total_assets"
    kind="external"
>
Returns the total amount of the underlying asset that is "managed" by Vault.
</APIItem>

<APIItem
    functionSignature="convert_to_shares(self: @ContractState, assets: u256) → u256"
    id="ERC4626Component-convert_to_shares"
    kind="external"
>
Returns the amount of shares that the Vault would exchange for the amount of assets provided irrespective of slippage or fees.

As per the [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec, this may panic *only* if there's an overflow from an unreasonably large input.
</APIItem>

<APIItem
    functionSignature="convert_to_assets(self: @ContractState, shares: u256) → u256"
    id="ERC4626Component-convert_to_assets"
    kind="external"
>
Returns the amount of assets that the Vault would exchange for the amount of shares provided irrespective of slippage or fees.

As per the [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec, this may panic *only* if there's an overflow from an unreasonably large input.
</APIItem>

<APIItem
    functionSignature="max_deposit(self: @ContractState, receiver: ContractAddress) → u256"
    id="ERC4626Component-max_deposit"
    kind="external"
>
Returns the maximum amount of the underlying asset that can be deposited into the Vault for the `receiver`, through a [deposit](#ERC4626Component-deposit) call.

The default max deposit value is 2 \** 256 - 1.

This can be changed in the implementing contract by defining custom logic in [LimitConfigTrait::deposit\_limit](#ERC4626Component-deposit_limit).
</APIItem>

<APIItem
    functionSignature="preview_deposit(self: @ContractState, assets: u256) → u256"
    id="ERC4626Component-preview_deposit"
    kind="external"
>
Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given current on-chain conditions.

The default deposit preview value is the full amount of shares. This can be changed to account for fees, for example, in the implementing contract by defining custom logic in [FeeConfigTrait::calculate\_deposit\_fee](#ERC4626Component-calculate_deposit_fee).

This method must be inclusive of entry fees to be compliant with the [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec.
</APIItem>

<APIItem
    functionSignature="deposit(ref self: ContractState, assets: u256, receiver: ContractAddress) → u256"
    id="ERC4626Component-deposit"
    kind="external"
>
Mints Vault shares to `receiver` by depositing exactly `assets` of underlying tokens. Returns the amount of newly-minted shares.

Requirements:

- `assets` is less than or equal to the max deposit amount for `receiver`.

Emits a [Deposit](#IERC4626-Deposit) event.
</APIItem>

<APIItem
    functionSignature="max_mint(self: @ContractState, receiver: ContractAddress) → u256"
    id="ERC4626Component-max_mint"
    kind="external"
>
Returns the maximum amount of the Vault shares that can be minted for `receiver` through a [mint](#ERC4626Component-mint) call.

The default max mint value is 2 \** 256 - 1.

This can be changed in the implementing contract by defining custom logic in [LimitConfigTrait::mint\_limit](#ERC4626Component-mint_limit).
</APIItem>

<APIItem
    functionSignature="preview_mint(self: @ContractState, shares: u256) → u256"
    id="ERC4626Component-preview_mint"
    kind="external"
>
Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given current on-chain conditions.

The default mint preview value is the full amount of assets. This can be changed to account for fees, for example, in the implementing contract by defining custom logic in [FeeConfigTrait::calculate\_mint\_fee](#ERC4626Component-calculate_mint_fee).

This method must be inclusive of entry fees to be compliant with the [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec.
</APIItem>

<APIItem
    functionSignature="mint(self: @ContractState, shares: u256, receiver: ContractAddress) → u256"
    id="ERC4626Component-mint"
    kind="external"
>
Mints exactly Vault `shares` to `receiver` by depositing amount of underlying tokens. Returns the amount deposited assets.

Requirements:

- `shares` is less than or equal to the max shares amount for `receiver`.

Emits a [Deposit](#IERC4626-Deposit) event.
</APIItem>

<APIItem
    functionSignature="max_withdraw(self: @ContractState, owner: ContractAddress) → u256"
    id="ERC4626Component-max_withdraw"
    kind="external"
>
Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the Vault, through a [withdraw](#ERC4626Component-withdraw) call.

The default max withdraw value is the full balance of assets for `owner` (converted from shares). This can be changed in the implementing contract by defining custom logic in [LimitConfigTrait::withdraw\_limit](#ERC4626Component-withdraw_limit).

With customized limits, the maximum withdraw amount will either be the custom limit itself or `owner`'s total asset balance, whichever value is less.
</APIItem>

<APIItem
    functionSignature="preview_withdraw(self: @ContractState, assets: u256) → u256"
    id="ERC4626Component-preview_withdraw"
    kind="external"
>
Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block, given current on-chain conditions.

The default withdraw preview value is the full amount of shares. This can be changed to account for fees, for example, in the implementing contract by defining custom logic in [FeeConfigTrait::calculate\_withdraw\_fee](#ERC4626Component-calculate_withdraw_fee).

This method must be inclusive of exit fees to be compliant with the [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec.
</APIItem>

<APIItem
    functionSignature="withdraw(self: @ContractState, assets: u256, receiver: ContractAddress, owner: ContractAddress) → u256"
    id="ERC4626Component-withdraw"
    kind="external"
>
Burns shares from `owner` and sends exactly `assets` of underlying tokens to `receiver`.

Requirements:

- `assets` is less than or equal to the max withdraw amount of `owner`.

Emits a [Withdraw](#IERC4626-Withdraw) event.
</APIItem>

<APIItem
    functionSignature="max_redeem(self: @ContractState, owner: ContractAddress) → u256"
    id="ERC4626Component-max_redeem"
    kind="external"
>
Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault, through a [redeem](#ERC4626Component-redeem) call.

The default max redeem value is the full balance of assets for `owner`. This can be changed in the implementing contract by defining custom logic in [LimitConfigTrait::redeem\_limit](#ERC4626Component-redeem_limit).

With customized limits, the maximum redeem amount will either be the custom limit itself or `owner`'s total asset balance, whichever value is less.
</APIItem>

<APIItem
    functionSignature="preview_redeem(self: @ContractState, shares: u256) → u256"
    id="ERC4626Component-preview_redeem"
    kind="external"
>
Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block, given current on-chain conditions.

The default redeem preview value is the full amount of assets. This can be changed to account for fees, for example, in the implementing contract by defining custom logic in [FeeConfigTrait::calculate\_redeem\_fee](#ERC4626Component-calculate_redeem_fee).

This method must be inclusive of exit fees to be compliant with the [EIP-4626](https://eips.ethereum.org/EIPS/eip-4626) spec.
</APIItem>

<APIItem
    functionSignature="redeem(self: @ContractState, shares: u256, receiver: ContractAddress, owner: ContractAddress) → u256"
    id="ERC4626Component-redeem"
    kind="external"
>
Burns exactly `shares` from `owner` and sends assets of underlying tokens to `receiver`.

Requirements:

- `shares` is less than or equal to the max redeem amount of `owner`.

Emits a [Withdraw](#IERC4626-Withdraw) event.
</APIItem>

<APIItem
    functionSignature="name(self: @ContractState) → ByteArray"
    id="ERC4626Component-name"
    kind="external"
>
Returns the name of the token.
</APIItem>

<APIItem
    functionSignature="symbol(self: @ContractState) → ByteArray"
    id="ERC4626Component-symbol"
    kind="external"
>
Returns the ticker symbol of the token, usually a shorter version of the name.
</APIItem>

<APIItem
    functionSignature="decimals(self: @ContractState) → u8"
    id="ERC4626Component-decimals"
    kind="external"
>
Returns the cumulative number of decimals which includes both `UNDERLYING_DECIMALS` and `OFFSET_DECIMALS`. Both of which must be defined in the [ImmutableConfig](#ERC4626Component-Immutable-Config) inside the implementing contract.
</APIItem>

#### Internal functions [!toc] [#ERC4626Component-Internal-Functions]

<APIItem
    functionSignature="initializer(ref self: ContractState, asset_address: ContractAddress)"
    id="ERC4626Component-initializer"
    kind="internal"
>
Validates the [ImmutableConfig](#ERC4626Component-Immutable-Config) constants and sets the `asset_address` to the vault. This should be set in the contract's constructor.

Requirements:

- `asset_address` cannot be the zero address.
</APIItem>

<APIItem
    functionSignature="_deposit(ref self: ContractState, caller: ContractAddress, receiver: ContractAddress, assets: u256, shares: u256)"
    id="ERC4626Component-_deposit"
    kind="internal"
>
Internal logic for [deposit](#ERC4626Component-deposit) and [mint](#ERC4626Component-mint).

Transfers `assets` from `caller` to the Vault contract then mints `shares` to `receiver`. Fees can be transferred in the `ERC4626Hooks::after_deposit` hook which is executed after assets are transferred and shares are minted.

Requirements:

- [ERC20::transfer\_from](#ERC20Component-transfer_from) must return true.

Emits two [ERC20::Transfer](#ERC20Component-Transfer) events (`ERC20::mint` and `ERC20::transfer_from`).

Emits a [Deposit](#IERC4626-Deposit) event.
</APIItem>

<APIItem
    functionSignature="_withdraw(ref self: ContractState, caller: ContractAddress, receiver: ContractAddress, owner: ContractAddress, assets: u256, shares: u256)"
    id="ERC4626Component-_withdraw"
    kind="internal"
>
Internal logic for [withdraw](#ERC4626Component-withdraw) and [redeem](#ERC4626Component-redeem).

Burns `shares` from `owner` and then transfers `assets` to `receiver`. Fees can be transferred in the `ERC4626Hooks::before_withdraw` hook which is executed before shares are burned and assets are transferred.

Requirements:

- [ERC20::transfer](#ERC20Component-transfer) must return true.

Emits two [ERC20::Transfer](#ERC20Component-Transfer) events (`ERC20::burn` and `ERC20::transfer`).

Emits a [Withdraw](#IERC4626-Withdraw) event.
</APIItem>

<APIItem
    functionSignature="_convert_to_shares(self: @ContractState, assets: u256, rounding: Rounding) -> u256"
    id="ERC4626Component-_convert_to_shares"
    kind="internal"
>
Internal conversion function (from assets to shares) with support for `rounding` direction.
</APIItem>

<APIItem
    functionSignature="_convert_to_assets(self: @ContractState, shares: u256, rounding: Rounding) -> u256"
    id="ERC4626Component-_convert_to_assets"
    kind="internal"
>
Internal conversion function (from shares to assets) with support for `rounding` direction.
</APIItem>

## Presets

### `ERC20Upgradeable` [toc] [#ERC20Upgradeable]
<APIGithubLinkHeader
    moduleName="ERC20Upgradeable"
    link={`https://github.com/OpenZeppelin/cairo-contracts/blob/release-v${UMBRELLA_VERSION}/packages/presets/src/erc20.cairo`}
/>

```rust
use openzeppelin_presets::ERC20Upgradeable;
```

Upgradeable ERC20 contract leveraging [ERC20Component](#ERC20Component) with a fixed-supply mechanism for token distribution.

[Sierra class hash](../presets)

```text
{{ERC20UpgradeableClassHash}}
```

Constructor

- [`constructor(self, name, symbol, fixed_supply, recipient, owner)`](#ERC20Upgradeable-constructor)

Embedded Implementations

#### ERC20MixinImpl [!toc] [#ERC20Upgradeable-Embedded-Impls-ERC20MixinImpl]

- [`ERC20MixinImpl`](#ERC20Component-Embeddable-Mixin-Impl)

#### OwnableMixinImpl [!toc] [#ERC20Upgradeable-Embedded-Impls-OwnableMixinImpl]

- [`OwnableMixinImpl`](./access#OwnableComponent-Mixin-Impl)

External Functions

- [`upgrade(self, new_class_hash)`](#ERC20Upgradeable-upgrade)

#### Constructor [!toc] [#ERC20Upgradeable-Constructor]

<APIItem
    functionSignature="constructor(ref self: ContractState, name: ByteArray, symbol: ByteArray, fixed_supply: u256, recipient: ContractAddress, owner: ContractAddress)"
    id="ERC20Upgradeable-constructor"
    kind="constructor"
>
Sets the `name` and `symbol` and mints `fixed_supply` tokens to `recipient`. Assigns `owner` as the contract owner with permissions to upgrade.
</APIItem>

#### External functions [!toc] [#ERC20Upgradeable-External-Functions]

<APIItem
    functionSignature="upgrade(ref self: ContractState, new_class_hash: ClassHash)"
    id="ERC20Upgradeable-upgrade"
    kind="external"
>
Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

- The caller is the contract owner.
- `new_class_hash` cannot be zero.
</APIItem>
