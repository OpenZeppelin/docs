---
title: ERC721
---

This module provides interfaces, presets, and utilities related to ERC721 contracts.

For an overview of ERC721, read our [ERC721 guide](../erc721).

## Interfaces

import { UMBRELLA_VERSION } from "../utils/constants.js";

### `IERC721` [toc] [#IERC721]
<APIGithubLinkHeader
    moduleName="IERC721"
    link={`https://github.com/OpenZeppelin/cairo-contracts/blob/release-v${UMBRELLA_VERSION}/packages/token/src/erc721/interface.cairo`}
/>

```rust
use openzeppelin_token::erc721::interface::IERC721;
```

Interface of the IERC721 standard as defined in [EIP721](https://eips.ethereum.org/EIPS/eip-721).

[SRC5 ID](./introspection#ISRC5)

```text
0x33eb2f84c309543403fd69f0d0f363781ef06ef6faeb0131ff16ea3175bd943
```

Functions

- [`balance_of(account)`](#IERC721-balance_of)
- [`owner_of(token_id)`](#IERC721-owner_of)
- [`safe_transfer_from(from, to, token_id, data)`](#IERC721-safe_transfer_from)
- [`transfer_from(from, to, token_id)`](#IERC721-transfer_from)
- [`approve(to, token_id)`](#IERC721-approve)
- [`set_approval_for_all(operator, approved)`](#IERC721-set_approval_for_all)
- [`get_approved(token_id)`](#IERC721-get_approved)
- [`is_approved_for_all(owner, operator)`](#IERC721-is_approved_for_all)

Events

- [`Approval(owner, approved, token_id)`](#IERC721-Approval)
- [`ApprovalForAll(owner, operator, approved)`](#IERC721-ApprovalForAll)
- [`Transfer(from, to, token_id)`](#IERC721-Transfer)

#### Functions [!toc] [#IERC721-Functions]

<APIItem
    functionSignature="balance_of(account: ContractAddress) → u256"
    id="IERC721-balance_of"
    kind="external"
>
Returns the number of NFTs owned by `account`.
</APIItem>

<APIItem
    functionSignature="owner_of(token_id: u256) → ContractAddress"
    id="IERC721-owner_of"
    kind="external"
>
Returns the owner address of `token_id`.
</APIItem>

<APIItem
    functionSignature="safe_transfer_from(from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)"
    id="IERC721-safe_transfer_from"
    kind="external"
>
Transfer ownership of `token_id` from `from` to `to`, checking first that `to` is aware of the ERC721 protocol to prevent tokens being locked forever. For information regarding how contracts communicate their awareness of the ERC721 protocol, see [Receiving Tokens](../erc721#receiving_tokens).

Emits a [Transfer](#IERC721-Transfer) event.
</APIItem>

<APIItem
    functionSignature="transfer_from(from: ContractAddress, to: ContractAddress, token_id: u256)"
    id="IERC721-transfer_from"
    kind="external"
>
Transfer ownership of `token_id` from `from` to `to`.

Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721 transfers or else they may be permanently lost. Usage of [IERC721::safe\_transfer\_from](#IERC721-safe_transfer_from) prevents loss, though the caller must understand this adds an external call which potentially creates a reentrancy vulnerability.

Emits a [Transfer](#IERC721-Transfer) event.
</APIItem>

<APIItem
    functionSignature="approve(to: ContractAddress, token_id: u256)"
    id="IERC721-approve"
    kind="external"
>
Change or reaffirm the approved address for an NFT.

Emits an [Approval](#IERC721-Approval) event.
</APIItem>

<APIItem
    functionSignature="set_approval_for_all(operator: ContractAddress, approved: bool)"
    id="IERC721-set_approval_for_all"
    kind="external"
>
Enable or disable approval for `operator` to manage all of the caller's assets.

Emits an [ApprovalForAll](#IERC721-ApprovalForAll) event.
</APIItem>

<APIItem
    functionSignature="get_approved(token_id: u256) -> u256"
    id="IERC721-get_approved"
    kind="external"
>
Returns the address approved for `token_id`.
</APIItem>

<APIItem
    functionSignature="is_approved_for_all(owner: ContractAddress, operator: ContractAddress) -> bool"
    id="IERC721-is_approved_for_all"
    kind="external"
>
Query if `operator` is an authorized operator for `owner`.
</APIItem>

#### Events [!toc] [#IERC721-Events]

<APIItem
    functionSignature="Approval(owner: ContractAddress, approved: ContractAddress, token_id: u256)"
    id="IERC721-Approval"
    kind="event"
>
Emitted when `owner` enables `approved` to manage the `token_id` token.
</APIItem>

<APIItem
    functionSignature="ApprovalForAll(owner: ContractAddress, operator: ContractAddress, approved: bool)"
    id="IERC721-ApprovalForAll"
    kind="event"
>
Emitted when `owner` enables or disables `operator` to manage the `token_id` token.
</APIItem>

<APIItem
    functionSignature="Transfer(from: ContractAddress, to: ContractAddress, token_id: u256)"
    id="IERC721-Transfer"
    kind="event"
>
Emitted when `token_id` token is transferred from `from` to `to`.
</APIItem>

### `IERC721Metadata` [toc] [#IERC721Metadata]
<APIGithubLinkHeader
    moduleName="IERC721Metadata"
    link={`https://github.com/OpenZeppelin/cairo-contracts/blob/release-v${UMBRELLA_VERSION}/packages/token/src/erc721/interface.cairo`}
/>

```rust
use openzeppelin_token::erc721::interface::IERC721Metadata;
```

Interface for the optional metadata functions in [EIP721](https://eips.ethereum.org/EIPS/eip-721).

[SRC5 ID](./introspection#ISRC5)

```text
0xabbcd595a567dce909050a1038e055daccb3c42af06f0add544fa90ee91f25
```

Functions

- [`name()`](#IERC721Metadata-name)
- [`symbol()`](#IERC721Metadata-symbol)
- [`token_uri(token_id)`](#IERC721Metadata-token_uri)

#### Functions [!toc] [#IERC721Metadata-Functions]

<APIItem
    functionSignature="name() -> ByteArray"
    id="IERC721Metadata-name"
    kind="external"
>
Returns the NFT name.
</APIItem>

<APIItem
    functionSignature="symbol() -> ByteArray"
    id="IERC721Metadata-symbol"
    kind="external"
>
Returns the NFT ticker symbol.
</APIItem>

<APIItem
    functionSignature="token_uri(token_id: u256) -> ByteArray"
    id="IERC721Metadata-token_uri"
    kind="external"
>
Returns the Uniform Resource Identifier (URI) for the `token_id` token. If the URI is not set for `token_id`, the return value will be an empty `ByteArray`.
</APIItem>

### `IERC721Receiver` [toc] [#IERC721Receiver]
<APIGithubLinkHeader
    moduleName="IERC721Receiver"
    link={`https://github.com/OpenZeppelin/cairo-contracts/blob/release-v${UMBRELLA_VERSION}/packages/token/src/erc721/interface.cairo`}
/>

```rust
use openzeppelin_token::erc721::interface::IERC721Receiver;
```

Interface for contracts that support receiving `safe_transfer_from` transfers.

[SRC5 ID](./introspection#ISRC5)

```text
0x3a0dff5f70d80458ad14ae37bb182a728e3c8cdda0402a5daa86620bdf910bc
```

Functions

- [`on_erc721_received(operator, from, token_id, data)`](#IERC721Receiver-on_erc721_received)

#### Functions [!toc] [#IERC721Receiver-Functions]

<APIItem
    functionSignature="on_erc721_received(operator: ContractAddress, from: ContractAddress, token_id: u256, data: Span<felt252>) -> felt252"
    id="IERC721Receiver-on_erc721_received"
    kind="external"
>
Whenever an IERC721 `token_id` token is transferred to this non-account contract via [IERC721::safe\_transfer\_from](#IERC721-safe_transfer_from) by `operator` from `from`, this function is called.
</APIItem>

### `IERC721Enumerable` [toc] [#IERC721Enumerable]
<APIGithubLinkHeader
    moduleName="IERC721Enumerable"
    link={`https://github.com/OpenZeppelin/cairo-contracts/blob/release-v${UMBRELLA_VERSION}/packages/token/src/erc721/extensions/erc721_enumerable/interface.cairo`}
/>

Interface for the optional enumerable functions in [EIP721](https://eips.ethereum.org/EIPS/eip-721).

[SRC5 ID](./introspection#ISRC5)

```text
0x16bc0f502eeaf65ce0b3acb5eea656e2f26979ce6750e8502a82f377e538c87
```

Functions

- [`total_supply()`](#IERC721Enumerable-total_supply)
- [`token_by_index(index)`](#IERC721Enumerable-token_by_index)
- [`token_of_owner_by_index(owner, index)`](#IERC721Enumerable-token_of_owner_by_index)

#### Functions [!toc] [#IERC721Enumerable-Functions]

<APIItem
    functionSignature="total_supply() -> u256"
    id="IERC721Enumerable-total_supply"
    kind="external"
>
Returns the total amount of tokens stored by the contract.
</APIItem>

<APIItem
    functionSignature="token_by_index(index: u256) -> u256"
    id="IERC721Enumerable-token_by_index"
    kind="external"
>
Returns a token id at a given `index` of all the tokens stored by the contract. Use along with [IERC721Enumerable::total\_supply](#IERC721Enumerable-total_supply) to enumerate all tokens.
</APIItem>

<APIItem
    functionSignature="token_of_owner_by_index(owner: ContractAddress, index: u256) -> u256"
    id="IERC721Enumerable-token_of_owner_by_index"
    kind="external"
>
Returns the token id owned by `owner` at a given `index` of its token list. Use along with [IERC721::balance\_of](#IERC721-balance_of) to enumerate all of `owner`'s tokens.
</APIItem>

## Core

### `ERC721Component` [toc] [#ERC721Component]
<APIGithubLinkHeader
    moduleName="ERC721Component"
    link={`https://github.com/OpenZeppelin/cairo-contracts/blob/release-v${UMBRELLA_VERSION}/packages/token/src/erc721/erc721.cairo`}
/>

```rust
use openzeppelin_token::erc721::ERC721Component;
```

ERC721 component implementing [IERC721](#IERC721) and [IERC721Metadata](#IERC721Metadata).

Implementing [SRC5Component](./introspection#SRC5Component) is a requirement for this component to be implemented.

See [Hooks](#ERC721Component-Hooks) to understand how are hooks used.

Hooks

#### ERC721HooksTrait [!toc] [#ERC721Component-ERC721HooksTrait]

- [`before_update(self, to, token_id, auth)`](#ERC721Component-before_update)
- [`after_update(self, to, token_id, auth)`](#ERC721Component-after_update)

[Embeddable Mixin Implementations](../components#mixins)

#### ERC721MixinImpl [!toc] [#ERC721Component-Embeddable-Impls-ERC721MixinImpl]

- [`ERC721Impl`](#ERC721Component-Embeddable-Impls-ERC721Impl)
- [`ERC721MetadataImpl`](#ERC721Component-Embeddable-Impls-ERC721MetadataImpl)
- [`ERC721CamelOnlyImpl`](#ERC721Component-Embeddable-Impls-ERC721CamelOnlyImpl)
- [`ERC721MetadataCamelOnlyImpl`](#ERC721Component-Embeddable-Impls-ERC721MetadataCamelOnlyImpl)
- [`SRC5Impl`](./introspection#SRC5Component-Embeddable-Impls)

Embeddable Implementations

#### ERC721Impl [!toc] [#ERC721Component-Embeddable-Impls-ERC721Impl]

- [`balance_of(self, account)`](#ERC721Component-balance_of)
- [`owner_of(self, token_id)`](#ERC721Component-owner_of)
- [`safe_transfer_from(self, from, to, token_id, data)`](#ERC721Component-safe_transfer_from)
- [`transfer_from(self, from, to, token_id)`](#ERC721Component-transfer_from)
- [`approve(self, to, token_id)`](#ERC721Component-approve)
- [`set_approval_for_all(self, operator, approved)`](#ERC721Component-set_approval_for_all)
- [`get_approved(self, token_id)`](#ERC721Component-get_approved)
- [`is_approved_for_all(self, owner, operator)`](#ERC721Component-is_approved_for_all)

#### ERC721MetadataImpl [!toc] [#ERC721Component-Embeddable-Impls-ERC721MetadataImpl]

- [`name(self)`](#ERC721Component-name)
- [`symbol(self)`](#ERC721Component-symbol)
- [`token_uri(self, token_id)`](#ERC721Component-token_uri)

#### ERC721CamelOnlyImpl [!toc] [#ERC721Component-Embeddable-Impls-ERC721CamelOnlyImpl]

- [`balanceOf(self, account)`](#ERC721Component-balanceOf)
- [`ownerOf(self, tokenId)`](#ERC721Component-ownerOf)
- [`safeTransferFrom(self, from, to, tokenId, data)`](#ERC721Component-safeTransferFrom)
- [`transferFrom(self, from, to, tokenId)`](#ERC721Component-transferFrom)
- [`setApprovalForAll(self, operator, approved)`](#ERC721Component-setApprovalForAll)
- [`getApproved(self, tokenId)`](#ERC721Component-getApproved)
- [`isApprovedForAll(self, owner, operator)`](#ERC721Component-isApprovedForAll)

#### ERC721MetadataCamelOnlyImpl [!toc] [#ERC721Component-Embeddable-Impls-ERC721MetadataCamelOnlyImpl]

- [`tokenURI(self, tokenId)`](#ERC721Component-tokenURI)

#### SRC5Impl [!toc] [#ERC721Component-Embeddable-Impls-SRC5Impl]

- [`supports_interface(self, interface_id: felt252)`](./introspection#ISRC5-supports_interface)

Internal functions

#### InternalImpl [!toc] [#ERC721Component-InternalImpl]

- [`initializer(self, name, symbol, base_uri)`](#ERC721Component-initializer)
- [`initializer_no_metadata(self)`](#ERC721Component-initializer_no_metadata)
- [`exists(self, token_id)`](#ERC721Component-exists)
- [`transfer(self, from, to, token_id)`](#ERC721Component-transfer)
- [`mint(self, to, token_id)`](#ERC721Component-mint)
- [`safe_transfer(self, from, to, token_id, data)`](#ERC721Component-safe_transfer)
- [`safe_mint(self, to, token_id, data)`](#ERC721Component-safe_mint)
- [`burn(self, token_id)`](#ERC721Component-burn)
- [`update(self, to, token_id, auth)`](#ERC721Component-update)
- [`_owner_of(self, token_id)`](#ERC721Component-_owner_of)
- [`_require_owned(self, token_id)`](#ERC721Component-_require_owned)
- [`_approve(self, to, token_id, auth)`](#ERC721Component-_approve)
- [`_approve_with_optional_event(self, to, token_id, auth, emit_event)`](#ERC721Component-_approve_with_optional_event)
- [`_set_approval_for_all(self, owner, operator, approved)`](#ERC721Component-_set_approval_for_all)
- [`_set_base_uri(self, base_uri)`](#ERC721Component-_set_base_uri)
- [`_base_uri(self)`](#ERC721Component-_base_uri)
- [`_is_authorized(self, owner, spender, token_id)`](#ERC721Component-_is_authorized)
- [`_check_authorized(self, owner, spender, token_id)`](#ERC721Component-_check_authorized)

Events

IERC721

- [`Approval(owner, approved, token_id)`](#ERC721Component-Approval)
- [`ApprovalForAll(owner, operator, approved)`](#ERC721Component-ApprovalForAll)
- [`Transfer(from, to, token_id)`](#ERC721Component-Transfer)

#### Hooks [!toc] [#ERC721Component-Hooks]

Hooks are functions which implementations can extend the functionality of the component source code. Every contract using ERC721Component is expected to provide an implementation of the ERC721HooksTrait. For basic token contracts, an empty implementation with no logic must be provided.

You can use `openzeppelin_token::erc721::ERC721HooksEmptyImpl` which is already available as part of the library for this purpose.

<APIItem
  functionSignature="before_update(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)"
  id="ERC721Component-before_update"
  kind="hook"
>
Function executed at the beginning of the [update](#ERC721Component-update) function prior to any other logic.
</APIItem>

<APIItem
  functionSignature="after_update(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)"
  id="ERC721Component-after_update"
  kind="hook"
>
Function executed at the end of the [update](#ERC721Component-update) function.
</APIItem>

#### [](#embeddable_functions)Embeddable functions [!toc] [#embeddable_functions]

<APIItem
  functionSignature="balance_of(self: @ContractState, account: ContractAddress) → u256"
  id="ERC721Component-balance_of"
  kind="external"
>
See [IERC721::balance\_of](#IERC721-balance_of).
</APIItem>

<APIItem
  functionSignature="owner_of(self: @ContractState, token_id: u256) → ContractAddress"
  id="ERC721Component-owner_of"
  kind="external"
>
See [IERC721::owner\_of](#IERC721-owner_of).

Requirements:

- `token_id` exists.
</APIItem>

<APIItem
  functionSignature="safe_transfer_from(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)"
  id="ERC721Component-safe_transfer_from"
  kind="external"
>
See [IERC721::safe\_transfer\_from](#IERC721-safe_transfer_from).

Requirements:

- Caller is either approved or the `token_id` owner.
- `to` is not the zero address.
- `from` is not the zero address.
- `token_id` exists.
- `to` is either an account contract or supports the [IERC721Receiver](#IERC721Receiver) interface.
</APIItem>

<APIItem
  functionSignature="transfer_from(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256)"
  id="ERC721Component-transfer_from"
  kind="external"
>
See [IERC721::transfer\_from](#IERC721-transfer_from).

Requirements:

- Caller either approved or the `token_id` owner.
- `to` is not the zero address.
- `from` is not the zero address.
- `token_id` exists.
</APIItem>

<APIItem
  functionSignature="approve(ref self: ContractState, to: ContractAddress, token_id: u256)"
  id="ERC721Component-approve"
  kind="external"
>
See [IERC721::approve](#IERC721-approve).

Requirements:

- The caller is either an approved operator or the `token_id` owner.
- `to` cannot be the token owner or the zero address.
- `token_id` exists.
</APIItem>

<APIItem
  functionSignature="set_approval_for_all(ref self: ContractState, operator: ContractAddress, approved: bool)"
  id="ERC721Component-set_approval_for_all"
  kind="external"
>
See [IERC721::set\_approval\_for\_all](#IERC721-set_approval_for_all).

Requirements:

- `operator` is not the zero address.
</APIItem>

<APIItem
  functionSignature="get_approved(self: @ContractState, token_id: u256) -> u256"
  id="ERC721Component-get_approved"
  kind="external"
>
See [IERC721::get\_approved](#IERC721-get_approved).

Requirements:

- `token_id` exists.
</APIItem>

<APIItem
  functionSignature="is_approved_for_all(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool"
  id="ERC721Component-is_approved_for_all"
  kind="external"
>
See [IERC721::is\_approved\_for\_all](#IERC721-is_approved_for_all).
</APIItem>

<APIItem
  functionSignature="name(self: @ContractState) -> ByteArray"
  id="ERC721Component-name"
  kind="external"
>
See [IERC721Metadata::name](#IERC721Metadata-name).
</APIItem>

<APIItem
  functionSignature="symbol(self: @ContractState) -> ByteArray"
  id="ERC721Component-symbol"
  kind="external"
>
See [IERC721Metadata::symbol](#IERC721Metadata-symbol).
</APIItem>

<APIItem
  functionSignature="token_uri(self: @ContractState, token_id: u256) -> ByteArray"
  id="ERC721Component-token_uri"
  kind="external"
>
Returns the Uniform Resource Identifier (URI) for the `token_id` token. If a base URI is set, the resulting URI for each token will be the concatenation of the base URI and the token ID. For example, the base URI `https://token-cdn-domain/` would be returned as `https://token-cdn-domain/123` for token ID `123`.

If the URI is not set for `token_id`, the return value will be an empty `ByteArray`.
</APIItem>

<APIItem
  functionSignature="balanceOf(self: @ContractState, account: ContractAddress) -> u256"
  id="ERC721Component-balanceOf"
  kind="external"
>
See [ERC721Component::balance\_of](#ERC721Component-balance_of).
</APIItem>

<APIItem
  functionSignature="ownerOf(self: @ContractState, tokenId: u256) -> ContractAddress"
  id="ERC721Component-ownerOf"
  kind="external"
>
See [ERC721Component::owner\_of](#ERC721Component-owner_of).
</APIItem>

<APIItem
  functionSignature="safeTransferFrom(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256, data: Span<felt252>)"
  id="ERC721Component-safeTransferFrom"
  kind="external"
>
See [ERC721Component::safe\_transfer\_from](#ERC721Component-safe_transfer_from).
</APIItem>

<APIItem
  functionSignature="transferFrom(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256)"
  id="ERC721Component-transferFrom"
  kind="external"
>
See [ERC721Component::transfer\_from](#ERC721Component-transfer_from).
</APIItem>

<APIItem
  functionSignature="setApprovalForAll(ref self: ContractState, operator: ContractAddress, approved: bool)"
  id="ERC721Component-setApprovalForAll"
  kind="external"
>
See [ERC721Component::set\_approval\_for\_all](#ERC721Component-set_approval_for_all).
</APIItem>

<APIItem
  functionSignature="getApproved(self: @ContractState, tokenId: u256) -> ContractAddress"
  id="ERC721Component-getApproved"
  kind="external"
>
See [ERC721Component::get\_approved](#ERC721Component-get_approved).
</APIItem>

<APIItem
  functionSignature="isApprovedForAll(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool"
  id="ERC721Component-isApprovedForAll"
  kind="external"
>
See [ERC721Component::is\_approved\_for\_all](#ERC721Component-is_approved_for_all).
</APIItem>

<APIItem
  functionSignature="tokenURI(self: @ContractState, tokenId: u256) -> ByteArray"
  id="ERC721Component-tokenURI"
  kind="external"
>
See [ERC721Component::token\_uri](#ERC721Component-token_uri).
</APIItem>

#### [](#internal_functions)Internal functions [!toc] [#internal_functions]

<APIItem
  functionSignature="initializer(ref self: ContractState, name: ByteArray, symbol: ByteArray, base_uri: ByteArray)"
  id="ERC721Component-initializer"
  kind="internal"
>
Initializes the contract by setting the token name and symbol. This should be used inside the contract's constructor.

Most ERC721 contracts expose the [IERC721Metadata](#IERC721Metadata) interface which is what this initializer is meant to support. If the contract DOES NOT expose the [IERC721Metadata](#IERC721Metadata) interface, meaning the token does not have a name, symbol, or URI, the contract must instead use [initializer\_no\_metadata](#ERC721Component-initializer_no_metadata) in the constructor. Failure to abide by these instructions can lead to unexpected issues especially with UIs.
</APIItem>

<APIItem
  functionSignature="initializer_no_metadata(ref self: ContractState)"
  id="ERC721Component-initializer_no_metadata"
  kind="internal"
>
Initializes the contract with no metadata by registering only the IERC721 interface.

This initializer should ONLY be used during construction in the very specific instance when the contract does NOT expose the [IERC721Metadata](#IERC721Metadata) interface. Initializing a contract with this initializer means that tokens will not have a name, symbol, or URI.
</APIItem>

<APIItem
  functionSignature="exists(self: @ContractState, token_id: u256) -> bool"
  id="ERC721Component-exists"
  kind="internal"
>
Internal function that returns whether `token_id` exists.

Tokens start existing when they are minted ([mint](#ERC721-mint)), and stop existing when they are burned ([burn](#ERC721-burn)).
</APIItem>

<APIItem
  functionSignature="transfer(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256)"
  id="ERC721Component-transfer"
  kind="internal"
>
Transfers `token_id` from `from` to `to`.

Internal function without access restriction.

This method may lead to the loss of tokens if `to` is not aware of the ERC721 protocol.

Requirements:

- `to` is not the zero address.
- `from` is the token owner.
- `token_id` exists.

Emits a [Transfer](#IERC721-Transfer) event.
</APIItem>

<APIItem
  functionSignature="mint(ref self: ContractState, to: ContractAddress, token_id: u256)"
  id="ERC721Component-mint"
  kind="internal"
>
Mints `token_id` and transfers it to `to`. Internal function without access restriction.

This method may lead to the loss of tokens if `to` is not aware of the ERC721 protocol.

Requirements:

- `to` is not the zero address.
- `token_id` does not exist.

Emits a [Transfer](#IERC721-Transfer) event.
</APIItem>

<APIItem
  functionSignature="safe_transfer(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)"
  id="ERC721Component-safe_transfer"
  kind="internal"
>
Transfers ownership of `token_id` from `from` if `to` is either an account or `IERC721Receiver`.

`data` is additional data, it has no specified format and is forwarded in `IERC721Receiver::on_erc721_received` to `to`.

This method makes an external call to the recipient contract, which can lead to reentrancy vulnerabilities.

Requirements:

- `to` cannot be the zero address.
- `from` must be the token owner.
- `token_id` exists.
- `to` is either an account contract or supports the `IERC721Receiver` interface.

Emits a [Transfer](#IERC721-Transfer) event.
</APIItem>

<APIItem
  functionSignature="safe_mint(ref self: ContractState, to: ContractAddress, token_id: u256, data: Span<felt252>)"
  id="ERC721Component-safe_mint"
  kind="internal"
>
Mints `token_id` if `to` is either an account or `IERC721Receiver`.

`data` is additional data, it has no specified format and is forwarded in `IERC721Receiver::on_erc721_received` to `to`.

This method makes an external call to the recipient contract, which can lead to reentrancy vulnerabilities.

Requirements:

- `token_id` does not exist.
- `to` is either an account contract or supports the `IERC721Receiver` interface.

Emits a [Transfer](#IERC721-Transfer) event.
</APIItem>

<APIItem
  functionSignature="burn(ref self: ContractState, token_id: u256)"
  id="ERC721Component-burn"
  kind="internal"
>
Destroys `token_id`. The approval is cleared when the token is burned.

This internal function does not check if the caller is authorized to operate on the token.

Requirements:

- `token_id` exists.

Emits a [Transfer](#IERC721-Transfer) event.
</APIItem>

<APIItem
  functionSignature="update(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)"
  id="ERC721Component-update"
  kind="internal"
>
Transfers `token_id` from its current owner to `to`, or alternatively mints (or burns) if the current owner (or `to`) is the zero address. Returns the owner of the `token_id` before the update.

The `auth` argument is optional. If the value passed is non-zero, then this function will check that `auth` is either the owner of the token, or approved to operate on the token (by the owner).

Emits a [Transfer](#IERC721-Transfer) event.

This function can be extended using the `ERC721HooksTrait`, to add functionality before and/or after the transfer, mint, or burn.
</APIItem>

<APIItem
  functionSignature="_owner_of(self: @ContractState, token_id: felt252) -> ContractAddress"
  id="ERC721Component-_owner_of"
  kind="internal"
>
Internal function that returns the owner address of `token_id`.
</APIItem>

<APIItem
  functionSignature="_require_owned(self: @ContractState, token_id: felt252) -> ContractAddress"
  id="ERC721Component-_require_owned"
  kind="internal"
>
Version of [\_owner\_of](#ERC721Component-_owner_of) that panics if owner is the zero address.
</APIItem>

<APIItem
  functionSignature="_approve(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)"
  id="ERC721Component-_approve"
  kind="internal"
>
Approve `to` to operate on `token_id`

The `auth` argument is optional. If the value passed is non-zero, then this function will check that `auth` is either the owner of the token, or approved to operate on all tokens held by this owner.

Emits an [Approval](#IERC721-Approval) event.
</APIItem>

<APIItem
  functionSignature="_approve_with_optional_event(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress, emit_event: bool)"
  id="ERC721Component-_approve_with_optional_event"
  kind="internal"
>
Variant of [\_approve](#ERC721Component-_approve) with an optional flag to enable or disable the `Approval` event. The event is not emitted in the context of transfers.

If `auth` is zero and `emit_event` is false, this function will not check that the token exists.

Requirements:

- if `auth` is non-zero, it must be either the owner of the token or approved to operate on all of its tokens.

May emit an [Approval](#IERC721-Approval) event.
</APIItem>

<APIItem
  functionSignature="_set_approval_for_all(ref self: ContractState, owner: ContractAddress, operator: ContractAddress, approved: bool)"
  id="ERC721Component-_set_approval_for_all"
  kind="internal"
>
Enables or disables approval for `operator` to manage all of the `owner` assets.

Requirements:

- `operator` is not the zero address.

Emits an [Approval](#IERC721-Approval) event.
</APIItem>

<APIItem
  functionSignature="_set_base_uri(ref self: ContractState, base_uri: ByteArray)"
  id="ERC721Component-_set_base_uri"
  kind="internal"
>
Internal function that sets the `base_uri`.
</APIItem>

<APIItem
  functionSignature="_base_uri(self: @ContractState) -> ByteArray"
  id="ERC721Component-_base_uri"
  kind="internal"
>
Base URI for computing [token\_uri](#IERC721Metadata-token_uri).

If set, the resulting URI for each token will be the concatenation of the base URI and the token ID. Returns an empty `ByteArray` if not set.
</APIItem>

<APIItem
  functionSignature="_is_authorized(self: @ContractState, owner: ContractAddress, spender: ContractAddress, token_id: u256) -> bool"
  id="ERC721Component-_is_authorized"
  kind="internal"
>
Returns whether `spender` is allowed to manage `owner`'s tokens, or `token_id` in particular (ignoring whether it is owned by `owner`).

This function assumes that `owner` is the actual owner of `token_id` and does not verify this assumption.
</APIItem>

<APIItem
  functionSignature="_check_authorized(self: @ContractState, owner: ContractAddress, spender: ContractAddress, token_id: u256) -> bool"
  id="ERC721Component-_check_authorized"
  kind="internal"
>
Checks if `spender` can operate on `token_id`, assuming the provided `owner` is the actual owner.

Requirements:

- `owner` cannot be the zero address.
- `spender` cannot be the zero address.
- `spender` must be the owner of `token_id` or be approved to operate on it.

This function assumes that `owner` is the actual owner of `token_id` and does not verify this assumption.
</APIItem>

#### [](#events_2)Events [!toc] [#events_2]

<APIItem
  functionSignature="Approval(owner: ContractAddress, approved: ContractAddress, token_id: u256)"
  id="ERC721Component-Approval"
  kind="event"
>
See [IERC721::Approval](#IERC721-Approval).
</APIItem>

<APIItem
  functionSignature="ApprovalForAll(owner: ContractAddress, operator: ContractAddress, approved: bool)"
  id="ERC721Component-ApprovalForAll"
  kind="event"
>
See [IERC721::ApprovalForAll](#IERC721-ApprovalForAll).
</APIItem>

<APIItem
  functionSignature="Transfer(from: ContractAddress, to: ContractAddress, token_id: u256)"
  id="ERC721Component-Transfer"
  kind="event"
>
See [IERC721::Transfer](#IERC721-Transfer).
</APIItem>

### `ERC721ReceiverComponent` [toc] [#ERC721ReceiverComponent]
<APIGithubLinkHeader
  moduleName="ERC721ReceiverComponent"
  link={`https://github.com/OpenZeppelin/cairo-contracts/blob/${UMBRELLA_VERSION}/packages/token/src/erc721/erc721_receiver.cairo`}
/>

```rust
use openzeppelin_token::erc721::ERC721ReceiverComponent;
```

ERC721Receiver component implementing [IERC721Receiver](#IERC721Receiver).

Implementing [SRC5Component](./introspection#SRC5Component) is a requirement for this component to be implemented.

[Embeddable Mixin Implementations](../components#mixins)

#### ERCReceiverMixinImpl [!toc] [#ERC721ReceiverComponent-Embeddable-Impls-ERCReceiverMixinImpl]

- [`ERC721ReceiverImpl`](#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverImpl)
- [`ERC721ReceiverCamelImpl`](#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverCamelImpl)
- [`SRC5Impl`](./introspection#SRC5Component-Embeddable-Impls)

Embeddable Implementations

#### ERC721ReceiverImpl [!toc] [#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverImpl]

- [`on_erc721_received(self, operator, from, token_id, data)`](#ERC721ReceiverComponent-on_erc721_received)

#### ERC721ReceiverCamelImpl [!toc] [#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverCamelImpl]

- [`onERC721Received(self, operator, from, tokenId, data)`](#ERC721ReceiverComponent-onERC721Received)

Internal Functions

#### InternalImpl [!toc] [#ERC721ReceiverComponent-InternalImpl]

- [`initializer(self)`](#ERC721ReceiverComponent-initializer)

#### [](#embeddable_functions_2)Embeddable functions [!toc] [#embeddable_functions_2]

<APIItem
  functionSignature="on_erc721_received(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, data Span<felt252>) -> felt252"
  id="ERC721ReceiverComponent-on_erc721_received"
  kind="external"
>
Returns the `IERC721Receiver` interface ID.
</APIItem>

<APIItem
  functionSignature="onERC721Received(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, data Span<felt252>) -> felt252"
  id="ERC721ReceiverComponent-onERC721Received"
  kind="external"
>
See [ERC721ReceiverComponent::on\_erc721\_received](#ERC721ReceiverComponent-on_erc721_received).
</APIItem>

#### [](#internal_functions_2)Internal functions [!toc] [#internal_functions_2]

<APIItem
  functionSignature="initializer(ref self: ContractState)"
  id="ERC721ReceiverComponent-initializer"
  kind="internal"
>
Registers the `IERC721Receiver` interface ID as supported through introspection.
</APIItem>

## Extensions

### `ERC721EnumerableComponent` [toc] [#ERC721EnumerableComponent]
<APIGithubLinkHeader
  moduleName="ERC721EnumerableComponent"
  link={`https://github.com/OpenZeppelin/cairo-contracts/blob/${UMBRELLA_VERSION}/packages/token/src/erc721/extensions/erc721_enumerable.cairo`}
/>

```rust
use openzeppelin_token::erc721::extensions::ERC721EnumerableComponent;
```

Extension of ERC721 as defined in the EIP that adds enumerability of all the token ids in the contract as well as all token ids owned by each account. This extension allows contracts to publish their entire list of NFTs and make them discoverable.

Implementing [ERC721Component](#ERC721Component) is a requirement for this component to be implemented.

To properly track token ids, this extension requires that the [ERC721EnumerableComponent::before\_update](#ERC721EnumerableComponent-before_update) function is called before every transfer, mint, or burn operation. For this, the [ERC721HooksTrait::before\_update](#ERC721Component-before_update) hook must be used. Here's how the hook should be implemented in a contract:

```[
#[starknet::contract]
mod ERC721EnumerableContract {
    (...)

    component!(path: ERC721Component, storage: erc721, event: ERC721Event);
    component!(path: ERC721EnumerableComponent, storage: erc721_enumerable, event: ERC721EnumerableEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    impl ERC721HooksImpl of ERC721Component::ERC721HooksTrait<ContractState> {
        fn before_update(
            ref self: ERC721Component::ComponentState<ContractState>,
            to: ContractAddress,
            token_id: u256,
            auth: ContractAddress
        ) {
            let mut contract_state = self.get_contract_mut();
            contract_state.erc721_enumerable.before_update(to, token_id);
        }
    }
}
```

Embeddable Implementations

#### ERC721EnumerableImpl [!toc] [#ERC721EnumerableComponent-Embeddable-Impls-ERC721EnumerableImpl]

- [`total_supply(self)`](#ERC721EnumerableComponent-total_supply)
- [`token_by_index(self, index)`](#ERC721EnumerableComponent-token_by_index)
- [`token_of_owner_by_index(self, address, index)`](#ERC721EnumerableComponent-token_of_owner_by_index)

Internal functions

#### InternalImpl [!toc] [#ERC721EnumerableComponent-InternalImpl]

- [`initializer(self)`](#ERC721EnumerableComponent-initializer)
- [`before_update(self, to, token_id)`](#ERC721EnumerableComponent-before_update)
- [`all_tokens_of_owner(self, owner)`](#ERC721EnumerableComponent-all_tokens_of_owner)
- [`_add_token_to_owner_enumeration(self, to, token_id)`](#ERC721EnumerableComponent-_add_token_to_owner_enumeration)
- [`_add_token_to_all_tokens_enumeration(self, token_id)`](#ERC721EnumerableComponent-_add_token_to_all_tokens_enumeration)
- [`_remove_token_from_owner_enumeration(self, from, token_id)`](#ERC721EnumerableComponent-_remove_token_from_owner_enumeration)
- [`_remove_token_from_all_tokens_enumeration(self, token_id)`](#ERC721EnumerableComponent-_remove_token_from_all_tokens_enumeration)

#### [](#ERC721EnumerableComponent-Embeddable-functions)Embeddable functions [!toc] [#ERC721EnumerableComponent-Embeddable-functions]

<APIItem
  functionSignature="total_supply(self: @ContractState) → u256"
  id="ERC721EnumerableComponent-total_supply"
  kind="external"
>
Returns the current amount of votes that `account` has.
</APIItem>

<APIItem
  functionSignature="token_by_index(self: @ContractState, index: u256) → u256"
  id="ERC721EnumerableComponent-token_by_index"
  kind="external"
>
See [IERC721Enumerable::token\_by\_index](#IERC721Enumerable-token_by_index).

Requirements:

- `index` is less than the total token supply.
</APIItem>

<APIItem
  functionSignature="token_of_owner_by_index(self: @ContractState, owner: ContractAddress, index: u256) → u256"
  id="ERC721EnumerableComponent-token_of_owner_by_index"
  kind="external"
>
See [IERC721Enumerable::token\_of\_owner\_by\_index](#IERC721Enumerable-token_of_owner_by_index).

Requirements:

- `index` is less than `owner`'s token balance.
- `owner` is not the zero address.
</APIItem>

#### [](#ERC721EnumerableComponent-Internal-functions)Internal functions [!toc] [#ERC721EnumerableComponent-Internal-functions]

<APIItem
  functionSignature="initializer(ref self: ContractState)"
  id="ERC721EnumerableComponent-initializer"
  kind="internal"
>
Registers the `IERC721Enumerable` interface ID as supported through introspection.
</APIItem>

<APIItem
  functionSignature="before_update(ref self: ContractState, to: ContractAddress, token_id: u256)"
  id="ERC721EnumerableComponent-before_update"
  kind="internal"
>
Updates the ownership and token-tracking data structures.

When a token is minted (or burned), `token_id` is added to (or removed from) the token-tracking structures.

When a token is transferred, minted, or burned, the ownership-tracking data structures reflect the change in ownership of `token_id`.

This must be added to the implementing contract's [ERC721HooksTrait::before\_update](#ERC721Component-before_update) hook.
</APIItem>

<APIItem
  functionSignature="all_tokens_of_owner(self: @ContractState, owner: ContractAddress) → Span<u256>"
  id="ERC721EnumerableComponent-all_tokens_of_owner"
  kind="internal"
>
Returns a list of all token ids owned by the specified `owner`. This function provides a more efficient alternative to calling `ERC721::balance_of` and iterating through tokens with `ERC721Enumerable::token_of_owner_by_index`.

Requirements:

- `owner` is not the zero address.
</APIItem>

<APIItem
  functionSignature="_add_token_to_owner_enumeration(ref self: ContractState, to: ContractAddress, token_id: u256)"
  id="ERC721EnumerableComponent-_add_token_to_owner_enumeration"
  kind="internal"
>
Adds token to this extension's ownership-tracking data structures.
</APIItem>

<APIItem
  functionSignature="_add_token_to_all_tokens_enumeration(ref self: ContractState, token_id: u256)"
  id="ERC721EnumerableComponent-_add_token_to_all_tokens_enumeration"
  kind="internal"
>
Adds token to this extension's token-tracking data structures.
</APIItem>

<APIItem
  functionSignature="_remove_token_from_owner_enumeration(ref self: ContractState, from: ContractAddress, token_id: u256)"
  id="ERC721EnumerableComponent-_remove_token_from_owner_enumeration"
  kind="internal"
>
Removes a token from this extension's ownership-tracking data structures.

This has 0(1) time complexity but alters the indexed order of owned tokens by swapping `token_id` and the index thereof with the last token id and the index thereof e.g. removing `1` from `[1, 2, 3, 4]` results in `[4, 2, 3]`.
</APIItem>

<APIItem
  functionSignature="_remove_token_from_all_tokens_enumeration(ref self: ContractState, token_id: u256)"
  id="ERC721EnumerableComponent-_remove_token_from_all_tokens_enumeration"
  kind="internal"
>
Removes `token_id` from this extension's token-tracking data structures.

This has 0(1) time complexity but alters the indexed order by swapping `token_id` and the index thereof with the last token id and the index thereof e.g. removing `1` from `[1, 2, 3, 4]` results in `[4, 2, 3]`.
</APIItem>

## Presets

### `ERC721Upgradeable` [toc] [#ERC721Upgradeable]
<APIGithubLinkHeader
  moduleName="ERC721Upgradeable"
  link={`https://github.com/OpenZeppelin/cairo-contracts/blob/${UMBRELLA_VERSION}/packages/presets/src/erc721.cairo`}
/>

```rust
use openzeppelin_presets::ERC721Upgradeable;
```

Upgradeable ERC721 contract leveraging [ERC721Component](#ERC721Component).

[Sierra class hash](../presets)

```text
{{ERC721UpgradeableClassHash}}
```

Constructor

- [`constructor(self, name, symbol, recipient, token_ids, base_uri, owner)`](#ERC721Upgradeable-constructor)

Embedded Implementations

ERC721MixinImpl

- [`ERC721MixinImpl`](#ERC721Component-Embeddable-Mixin-Impl)

OwnableMixinImpl

- [`OwnableMixinImpl`](./access#OwnableComponent-Mixin-Impl)

External Functions

- [`upgrade(self, new_class_hash)`](#ERC721Upgradeable-upgrade)

#### [](#ERC721Upgradeable-constructor-section)Constructor [!toc] [#ERC721Upgradeable-constructor-section]

<APIItem
  functionSignature="constructor(ref self: ContractState, name: ByteArray, symbol: ByteArray, recipient: ContractAddress, token_ids: Span<u256>, base_uri: ByteArray, owner: ContractAddress)"
  id="ERC721Upgradeable-constructor"
  kind="constructor"
>
Sets the `name` and `symbol`. Mints `token_ids` tokens to `recipient` and sets the `base_uri`. Assigns `owner` as the contract owner with permissions to upgrade.
</APIItem>

#### [](#ERC721Upgradeable-external-functions)External functions [!toc] [#ERC721Upgradeable-external-functions]

<APIItem
  functionSignature="upgrade(ref self: ContractState, new_class_hash: ClassHash)"
  id="ERC721Upgradeable-upgrade"
  kind="external"
>
Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

- The caller is the contract owner.
- `new_class_hash` cannot be zero.
</APIItem>
