---
title: Presets
---

Presets are ready-to-deploy contracts provided by the library. Since presets are intended to be very simple
and as generic as possible, there’s no support for custom or complex contracts such as `ERC20Pausable` or `ERC721Mintable`.

<Callout>
For contract customization and combination of modules you can use [Wizard for Cairo](https://wizard.openzeppelin.com), our code-generation tool.
</Callout>

## Available presets

List of available presets and their corresponding [Sierra class hashes](https://docs.starknet.io/architecture-and-concepts/smart-contracts/class-hash/). Like Contracts for Cairo,
use of preset contracts are subject to the terms of the
[MIT License](https://github.com/OpenZeppelin/cairo-contracts?tab=MIT-1-ov-file#readme).

<Callout>
Class hashes were computed using class-hash-cairo-version and the `scarb --release` profile.
</Callout>

<Callout type='warn'>
Before version 3.0.0, class hashes were computed using the `scarb --dev` profile.
</Callout>

| Name | Sierra Class Hash |
| --- | --- |
| [`AccountUpgradeable`](/contracts-cairo/api/account#AccountUpgradeable) | `{{AccountUpgradeableClassHash}}` |
| [`ERC20Upgradeable`](/contracts-cairo/api/erc20#ERC20Upgradeable) | `{{ERC20UpgradeableClassHash}}` |
| [`ERC721Upgradeable`](/contracts-cairo/api/erc721#ERC721Upgradeable) | `{{ERC721UpgradeableClassHash}}` |
| [`ERC1155Upgradeable`](/contracts-cairo/api/erc1155#ERC1155Upgradeable) | `{{ERC1155UpgradeableClassHash}}` |
| [`EthAccountUpgradeable`](/contracts-cairo/api/account#EthAccountUpgradeable) | `{{EthAccountUpgradeableClassHash}}` |
| [`UniversalDeployer`](/contracts-cairo/api/udc#UniversalDeployer) | `{{UniversalDeployerClassHash}}` |
| [`VestingWallet`](/contracts-cairo/api/finance#VestingWallet) | `{{VestingWalletClassHash}}` |

<Callout>
[starkli](https://book.starkli.rs/introduction) class-hash command can be used to compute the class hash from a Sierra artifact.
</Callout>

## Usage

These preset contracts are ready-to-deploy which means they should already be declared on the Sepolia network.
Simply deploy the preset class hash and add the appropriate constructor arguments.
Deploying the ERC20Upgradeable preset with [starkli](https://book.starkli.rs/introduction), for example, will look like this:

```bash
starkli deploy {ERC20Upgradeable-class-hash} \
  <CONSTRUCTOR_ARGS> \
  --network="sepolia"
```

If a class hash has yet to be declared, copy/paste the preset contract code and declare it locally.
Start by [setting up a project](/contracts-cairo#set-up-your-project) and [installing the Contracts for Cairo library](/contracts-cairo#install-the-library).
Copy the target preset contract from the [presets directory](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v{{umbrella_version}}/packages/presets/src)
and paste it in the new project’s `src/lib.cairo` like this:

```rust
// src/lib.cairo

#[starknet::contract]
mod ERC20Upgradeable {
    use openzeppelin_access::ownable::OwnableComponent;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use openzeppelin_upgrades::UpgradeableComponent;
    use openzeppelin_upgrades::interface::IUpgradeable;
    use starknet::{ContractAddress, ClassHash};

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);
    component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    // Upgradeable
    impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
        #[substorage(v0)]
        upgradeable: UpgradeableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        ERC20Event: ERC20Component::Event,
        #[flat]
        UpgradeableEvent: UpgradeableComponent::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        fixed_supply: u256,
        recipient: ContractAddress,
        owner: ContractAddress
    ) {
        self.ownable.initializer(owner);
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, fixed_supply);
    }

    #[abi(embed_v0)]
    impl UpgradeableImpl of IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            self.ownable.assert_only_owner();
            self.upgradeable.upgrade(new_class_hash);
        }
    }
}
```

Next, compile the contract.

```bash
scarb build
```

Finally, declare the preset.

```bash
starkli declare target/dev/my_project_ERC20Upgradeable.contract_class.json \
  --network="sepolia"
```
