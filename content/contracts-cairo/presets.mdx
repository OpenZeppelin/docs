---
title: Presets
---

Presets are ready-to-deploy contracts provided by the library. Since presets are intended to be very simple
and as generic as possible, there’s no support for custom or complex contracts such as `ERC20Pausable` or `ERC721Mintable`.

<Callout>
For contract customization and combination of modules you can use [Wizard for Cairo](https://wizard.openzeppelin.com), our code-generation tool.
</Callout>

## Available presets

List of available presets and their corresponding [Sierra class hashes](https://docs.starknet.io/architecture-and-concepts/smart-contracts/class-hash/). Like Contracts for Cairo,
use of preset contracts are subject to the terms of the
[MIT License](https://github.com/OpenZeppelin/cairo-contracts?tab=MIT-1-ov-file#readme).

<Callout>
Class hashes were computed using class-hash-cairo-version and the `scarb --release` profile.
</Callout>

<Callout type='warn'>
Before version 3.0.0, class hashes were computed using the `scarb --dev` profile.
</Callout>

| Name | Sierra Class Hash |
| --- | --- |
| [`AccountUpgradeable`](/api/account#AccountUpgradeable) | `0x002de258cce5b9e160bf83956b09f982059582469f7e6fad07b438128317d029` |
| [`ERC20Upgradeable`](/api/erc20#ERC20Upgradeable) | `0x07802658d99373a4002434cbdc8897d1936c6b1beea48af0cc3b5574707f8d92` |
| [`ERC721Upgradeable`](/api/erc721#ERC721Upgradeable) | `0x04080084ac1ba5a26b4638ac7ca2ff009a9a9b86bf6db5df05e96c90aa143df5` |
| [`ERC1155Upgradeable`](/api/erc1155#ERC1155Upgradeable) | `0x06c8912d4397bb25c73a571bced14cedb959a7caa40b76fb0ce19a57d4a7a9c0` |
| [`EthAccountUpgradeable`](/api/account#EthAccountUpgradeable) | `0x07f54a43da3f7beb5099c87f5627b7fba5f31c7a704cce57f8fb73287c1ea3be` |
| [`UniversalDeployer`](/api/udc#UniversalDeployer) | `0x037f5901deb2b20bf5b2ddb04f6c770a7c5581edd68aa49f199cf74dfaf03c06` |
| [`VestingWallet`](/api/finance#VestingWallet) | `0x062050f8eb6942d067d9d6fc6c2d01aaedbee284f339e58196d5a3bd3d4d6c6f` |

<Callout>
[starkli](https://book.starkli.rs/introduction) class-hash command can be used to compute the class hash from a Sierra artifact.
</Callout>

## Usage

These preset contracts are ready-to-deploy which means they should already be declared on the Sepolia network.
Simply deploy the preset class hash and add the appropriate constructor arguments.
Deploying the ERC20Upgradeable preset with [starkli](https://book.starkli.rs/introduction), for example, will look like this:

```bash
starkli deploy {ERC20Upgradeable-class-hash} \
  <CONSTRUCTOR_ARGS> \
  --network="sepolia"
```

If a class hash has yet to be declared, copy/paste the preset contract code and declare it locally.
Start by [setting up a project](/contracts-cairo#set-up-your-project) and [installing the Contracts for Cairo library](/contracts-cairo#install-the-library).
Copy the target preset contract from the [presets directory](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v{{umbrella_version}}/packages/presets/src)
and paste it in the new project’s `src/lib.cairo` like this:

```rust
// src/lib.cairo

#[starknet::contract]
mod ERC20Upgradeable {
    use openzeppelin_access::ownable::OwnableComponent;
    use openzeppelin_token::erc20::{ERC20Component, ERC20HooksEmptyImpl};
    use openzeppelin_upgrades::UpgradeableComponent;
    use openzeppelin_interfaces::upgrades::IUpgradeable;
    use starknet::{ContractAddress, ClassHash};

    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: ERC20Component, storage: erc20, event: ERC20Event);
    component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);

    // Ownable Mixin
    #[abi(embed_v0)]
    impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;

    // ERC20 Mixin
    #[abi(embed_v0)]
    impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;
    impl ERC20InternalImpl = ERC20Component::InternalImpl<ContractState>;

    // Upgradeable
    impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        erc20: ERC20Component::Storage,
        #[substorage(v0)]
        upgradeable: UpgradeableComponent::Storage
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        ERC20Event: ERC20Component::Event,
        #[flat]
        UpgradeableEvent: UpgradeableComponent::Event
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        name: ByteArray,
        symbol: ByteArray,
        fixed_supply: u256,
        recipient: ContractAddress,
        owner: ContractAddress
    ) {
        self.ownable.initializer(owner);
        self.erc20.initializer(name, symbol);
        self.erc20.mint(recipient, fixed_supply);
    }

    #[abi(embed_v0)]
    impl UpgradeableImpl of IUpgradeable<ContractState> {
        fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {
            self.ownable.assert_only_owner();
            self.upgradeable.upgrade(new_class_hash);
        }
    }
}
```

Next, compile the contract.

```bash
scarb build
```

Finally, declare the preset.

```bash
starkli declare target/dev/my_project_ERC20Upgradeable.contract_class.json \
  --network="sepolia"
```
