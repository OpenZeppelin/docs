---
title: ERC1155
---

import { UMBRELLA_VERSION } from "../utils/constants.js";

This module provides interfaces, presets, and utilities related to ERC1155 contracts.

For an overview of ERC1155, read our [ERC1155 guide](../erc1155).

## [](#interfaces)Interfaces

<Callout type='info'>
Starting from version `3.x.x`, the interfaces are no longer part of the `openzeppelin_access` package. The references
documented here are contained in the `openzeppelin_interfaces` package version `{{openzeppelin_interfaces_version}}`.
</Callout>

### `IERC1155` [toc] [#IERC1155]

<APIGithubLinkHeader
  moduleName="IERC1155"
  link={`https://github.com/OpenZeppelin/cairo-contracts/blob/${UMBRELLA_VERSION}/packages/interfaces/src/token/erc1155.cairo`}
/>

```rust
use openzeppelin_interfaces::erc1155::IERC1155;
```

Interface of the IERC1155 standard as defined in [EIP1155](https://eips.ethereum.org/EIPS/eip-1155).

[SRC5 ID](introspection#ISRC5)

```text
0x6114a8f75559e1b39fcba08ce02961a1aa082d9256a158dd3e64964e4b1b52
```

Functions

- [`balance_of(account, token_id)`](#IERC1155-balance_of)
- [`balance_of_batch(accounts, token_ids)`](#IERC1155-balance_of_batch)
- [`safe_transfer_from(from, to, token_id, value, data)`](#IERC1155-safe_transfer_from)
- [`safe_batch_transfer_from(from, to, token_ids, values, data)`](#IERC1155-safe_batch_transfer_from)
- [`set_approval_for_all(operator, approved)`](#IERC1155-set_approval_for_all)
- [`is_approved_for_all(owner, operator)`](#IERC1155-is_approved_for_all)

Events

- [`TransferSingle(operator, from, to, id, value)`](#IERC1155-TransferSingle)
- [`TransferBatch(operator, from, to, ids, values)`](#IERC1155-TransferBatch)
- [`ApprovalForAll(owner, operator, approved)`](#IERC1155-ApprovalForAll)
- [`URI(value, id)`](#IERC1155-URI)

#### Functions [!toc] [#functions]

<APIItem
  functionSignature="balance_of(account: ContractAddress, token_id: u256) → u256"
  id="IERC1155-balance_of"
  kind="external"
>
Returns the amount of `token_id` tokens owned by `account`.
</APIItem>

<APIItem
  functionSignature="balance_of_batch(accounts: Span<ContractAddress>, token_ids: Span<u256>) → Span<u256>"
  id="IERC1155-balance_of_batch"
  kind="external"
>
Returns a list of balances derived from the `accounts` and `token_ids` pairs.
</APIItem>

<APIItem
  functionSignature="safe_transfer_from(from: ContractAddress, to: ContractAddress, token_id: u256, value: u256, data: Span<felt252>)"
  id="IERC1155-safe_transfer_from"
  kind="external"
>
Transfers ownership of `value` amount of `token_id` from `from` if `to` is either `IERC1155Receiver` or an account.

`data` is additional data, it has no specified format and it is passed to `to`.

Emits a [TransferSingle](#IERC1155-TransferSingle) event.
</APIItem>

<APIItem
  functionSignature="safe_batch_transfer_from(from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)"
  id="IERC1155-safe_batch_transfer_from"
  kind="external"
>
Transfers ownership of `token_ids` and `values` pairs from `from` if `to` is either `IERC1155Receiver` or an account.

`data` is additional data, it has no specified format and it is passed to `to`.

Emits a [TransferBatch](#IERC1155-TransferBatch) event.
</APIItem>

<APIItem
  functionSignature="set_approval_for_all(operator: ContractAddress, approved: bool)"
  id="IERC1155-set_approval_for_all"
  kind="external"
>
Enables or disables approval for `operator` to manage all of the caller's assets.

Emits an [ApprovalForAll](#IERC1155-ApprovalForAll) event.
</APIItem>

<APIItem
  functionSignature="is_approved_for_all(owner: ContractAddress, operator: ContractAddress) -> bool"
  id="IERC1155-is_approved_for_all"
  kind="external"
>
Queries if `operator` is an authorized operator for `owner`.
</APIItem>

#### Events [!toc] [#events]

<APIItem
  functionSignature="TransferSingle(operator: ContractAddress, from: ContractAddress, to: ContractAddress, id: u256, value: u256)"
  id="IERC1155-TransferSingle"
  kind="event"
>
Emitted when `value` amount of `id` token is transferred from `from` to `to` through `operator`.
</APIItem>

<APIItem
  functionSignature="TransferBatch(operator: ContractAddress, from: ContractAddress, to: ContractAddress, ids: Span<u256>, values: Span<u256>)"
  id="IERC1155-TransferBatch"
  kind="event"
>
Emitted when a batch of `values` amount of `ids` tokens are transferred from `from` to `to` through `operator`.
</APIItem>

<APIItem
  functionSignature="ApprovalForAll(owner: ContractAddress, operator: ContractAddress, approved: bool)"
  id="IERC1155-ApprovalForAll"
  kind="event"
>
Emitted when `owner` enables or disables `operator` to manage all of the owner's assets.
</APIItem>

<APIItem
  functionSignature="URI(value: ByteArray, id: u256)"
  id="IERC1155-URI"
  kind="event"
>
Emitted when the token URI is updated to `value` for the `id` token.
</APIItem>

### `IERC1155MetadataURI` [toc] [#IERC1155MetadataURI]

<APIGithubLinkHeader
  moduleName="IERC1155MetadataURI"
  link={`https://github.com/OpenZeppelin/cairo-contracts/blob/${UMBRELLA_VERSION}/packages/interfaces/src/token/erc1155.cairo`}
/>

```rust
use openzeppelin_interfaces::erc1155::IERC1155MetadataURI;
```

Interface for the optional metadata function in [EIP1155](https://eips.ethereum.org/EIPS/eip-1155#metadata).

[SRC5 ID](introspection#ISRC5)

```text
0xcabe2400d5fe509e1735ba9bad205ba5f3ca6e062da406f72f113feb889ef7
```

Functions

- [`uri(token_id)`](#IERC1155MetadataURI-uri)

#### Functions [!toc] [#functions_2]

<APIItem
  functionSignature="uri(token_id: u256) -> ByteArray"
  id="IERC1155MetadataURI-uri"
  kind="external"
>
Returns the Uniform Resource Identifier (URI) for the `token_id` token.
</APIItem>

### `IERC1155Receiver` [toc] [#IERC1155Receiver]

<APIGithubLinkHeader
  moduleName="IERC1155Receiver"
  link={`https://github.com/OpenZeppelin/cairo-contracts/blob/${UMBRELLA_VERSION}/packages/interfaces/src/token/erc1155.cairo`}
/>

```rust
use openzeppelin_interfaces::erc1155::IERC1155Receiver;
```

Interface for contracts that support receiving token transfers from `ERC1155` contracts.

[SRC5 ID](introspection#ISRC5)

```text
0x15e8665b5af20040c3af1670509df02eb916375cdf7d8cbaf7bd553a257515e
```

Functions

- [`on_erc1155_received(operator, from, token_id, value, data)`](#IERC1155Receiver-on_erc1155_received)
- [`on_erc1155_batch_received(operator, from, token_ids, values, data)`](#IERC1155Receiver-on_erc1155_batch_received)

#### Functions [!toc] [#functions_3]

<APIItem
  functionSignature="on_erc1155_received(operator: ContractAddress, from: ContractAddress, token_id: u256, value: u256, data Span<felt252>) -> felt252"
  id="IERC1155Receiver-on_erc1155_received"
  kind="external"
>
This function is called whenever an ERC1155 `token_id` token is transferred to this `IERC1155Receiver` implementer via [IERC1155::safe\_transfer\_from](#IERC1155-safe_transfer_from) by `operator` from `from`.
</APIItem>

<APIItem
  functionSignature="on_erc1155_batch_received(operator: ContractAddress, from: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data Span<felt252>) -> felt252"
  id="IERC1155Receiver-on_erc1155_batch_received"
  kind="external"
>
This function is called whenever multiple ERC1155 `token_ids` tokens are transferred to this `IERC1155Receiver` implementer via [IERC1155::safe\_batch\_transfer\_from](#IERC1155-safe_batch_transfer_from) by `operator` from `from`.
</APIItem>

## [](#core)Core

### `ERC1155Component` [toc] [#ERC1155Component]

<APIGithubLinkHeader
  moduleName="ERC1155Component"
  link={`https://github.com/OpenZeppelin/cairo-contracts/blob/${UMBRELLA_VERSION}/packages/token/src/erc1155/erc1155.cairo`}
/>

```rust
use openzeppelin_token::erc1155::ERC1155Component;
```

ERC1155 component implementing [IERC1155](#IERC1155) and [IERC1155MetadataURI](#IERC1155MetadataURI).

Implementing [SRC5Component](introspection#SRC5Component) is a requirement for this component to be implemented.

See [Hooks](#ERC1155Component-Hooks) to understand how are hooks used.

#### Hooks [!toc] [#ERC1155Component-Hooks]

#### ERC1155HooksTrait [!toc] [#ERC1155Component-ERC1155HooksTrait]

- [`before_update(self, from, to, token_ids, values)`](#ERC1155Component-before_update)
- [`after_update(self, from, to, token_ids, values)`](#ERC1155Component-after_update)

[Embeddable Mixin Implementations](../components#mixins)

#### ERC1155MixinImpl [!toc] [#ERC1155Component-Embeddable-Impls-ERC1155MixinImpl]

- [`ERC1155Impl`](#ERC1155Component-Embeddable-Impls-ERC1155Impl)
- [`ERC1155MetadataURIImpl`](#ERC1155Component-Embeddable-Impls-ERC1155MetadataURIImpl)
- [`ERC1155CamelImpl`](#ERC1155Component-Embeddable-Impls-ERC1155CamelImpl)
- [`SRC5Impl`](introspection#SRC5Component-Embeddable-Impls-SRC5Impl)

Embeddable Implementations

#### ERC1155Impl [!toc] [#ERC1155Component-Embeddable-Impls-ERC1155Impl]

- [`balance_of(self, account, token_id)`](#ERC1155Component-balance_of)
- [`balance_of_batch(self, accounts, token_ids)`](#ERC1155Component-balance_of_batch)
- [`safe_transfer_from(self, from, to, token_id, value, data)`](#ERC1155Component-safe_transfer_from)
- [`safe_batch_transfer_from(self, from, to, token_ids, values, data)`](#ERC1155Component-safe_batch_transfer_from)
- [`set_approval_for_all(self, operator, approved)`](#ERC1155Component-set_approval_for_all)
- [`is_approved_for_all(self, owner, operator)`](#ERC1155Component-is_approved_for_all)

#### ERC1155MetadataURIImpl [!toc] [#ERC1155Component-Embeddable-Impls-ERC1155MetadataURIImpl]

- [`uri(self, token_id)`](#ERC1155Component-uri)

#### ERC1155CamelImpl [!toc] [#ERC1155Component-Embeddable-Impls-ERC1155CamelImpl]

- [`balanceOf(self, account, tokenId)`](#ERC1155Component-balanceOf)
- [`balanceOfBatch(self, accounts, tokenIds)`](#ERC1155Component-balanceOfBatch)
- [`safeTransferFrom(self, from, to, tokenId, value, data)`](#ERC1155Component-safeTransferFrom)
- [`safeBatchTransferFrom(self, from, to, tokenIds, values, data)`](#ERC1155Component-safeBatchTransferFrom)
- [`setApprovalForAll(self, operator, approved)`](#ERC1155Component-setApprovalForAll)
- [`isApprovedForAll(self, owner, operator)`](#ERC1155Component-isApprovedForAll)

Internal Functions

#### InternalImpl [!toc] [#ERC1155Component-InternalImpl]

- [`initializer(self, base_uri)`](#ERC1155Component-initializer)
- [`initializer_no_metadata(self)`](#ERC1155Component-initializer_no_metadata)
- [`mint_with_acceptance_check(self, to, token_id, value, data)`](#ERC1155Component-mint_with_acceptance_check)
- [`batch_mint_with_acceptance_check(self, to, token_ids, values, data)`](#ERC1155Component-batch_mint_with_acceptance_check)
- [`burn(self, from, token_id, value)`](#ERC1155Component-burn)
- [`batch_burn(self, from, token_ids, values)`](#ERC1155Component-batch_burn)
- [`update_with_acceptance_check(self, from, to, token_ids, values, data)`](#ERC1155Component-update_with_acceptance_check)
- [`update(self, from, to, token_ids, values)`](#ERC1155Component-update)
- [`_set_base_uri(self, base_uri)`](#ERC1155Component-_set_base_uri)

Events

IERC1155

- [`TransferSingle(operator, from, to, id, value)`](#ERC1155Component-TransferSingle)
- [`TransferBatch(operator, from, to, ids, values)`](#ERC1155Component-TransferBatch)
- [`ApprovalForAll(owner, operator, approved)`](#ERC1155Component-ApprovalForAll)
- [`URI(value, id)`](#ERC1155Component-URI)

Hooks are functions which implementations can extend the functionality of the component source code. Every contract using ERC1155Component is expected to provide an implementation of the ERC1155HooksTrait. For basic token contracts, an empty implementation with no logic must be provided.

You can use `openzeppelin_token::erc1155::ERC1155HooksEmptyImpl` which is already available as part of the library for this purpose.

<APIItem
  functionSignature="before_update(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>)"
  id="ERC1155Component-before_update"
  kind="hook"
>
Function executed at the beginning of the [update](#ERC1155Component-update) function prior to any other logic.
</APIItem>

<APIItem
  functionSignature="after_update(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>)"
  id="ERC1155Component-after_update"
  kind="hook"
>
Function executed at the end of the [update](#ERC1155Component-update) function.
</APIItem>

#### Embeddable functions [!toc] [#embeddable_functions]

<APIItem
  functionSignature="balance_of(self: @ContractState, account: ContractAddress, token_id: u256) → u256"
  id="ERC1155Component-balance_of"
  kind="external"
>
Returns the amount of `token_id` tokens owned by `account`.
</APIItem>

<APIItem
  functionSignature="balance_of_batch(self: @ContractState, accounts: Span<ContractAddress>, token_ids: Span<u256>) → Span<u256>"
  id="ERC1155Component-balance_of_batch"
  kind="external"
>
Returns a list of balances derived from the `accounts` and `token_ids` pairs.

Requirements:

- `token_ids` and `accounts` must have the same length.
</APIItem>

<APIItem
  functionSignature="safe_transfer_from(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, value: u256, data: Span<felt252>)"
  id="ERC1155Component-safe_transfer_from"
  kind="external"
>
Transfers ownership of `value` amount of `token_id` from `from` if `to` is either an account or `IERC1155Receiver`.

`data` is additional data, it has no specified format and it is passed to `to`.

This function can potentially allow a reentrancy attack when transferring tokens to an untrusted contract, when invoking `on_ERC1155_received` on the receiver. Ensure to follow the checks-effects-interactions pattern and consider employing reentrancy guards when interacting with untrusted contracts.

Requirements:

- Caller is either approved or the `token_id` owner.
- `from` is not the zero address.
- `to` is not the zero address.
- If `to` refers to a non-account contract, it must implement `IERC1155Receiver::on_ERC1155_received` and return the required magic value.

Emits a [TransferSingle](#ERC1155Component-TransferSingle) event.
</APIItem>

<APIItem
  functionSignature="safe_batch_transfer_from(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)"
  id="ERC1155Component-safe_batch_transfer_from"
  kind="external"
>
Transfers ownership of `values` and `token_ids` pairs from `from` if `to` is either an account or `IERC1155Receiver`.

`data` is additional data, it has no specified format and it is passed to `to`.

This function can potentially allow a reentrancy attack when transferring tokens to an untrusted contract, when invoking `on_ERC1155_batch_received` on the receiver. Ensure to follow the checks-effects-interactions pattern and consider employing reentrancy guards when interacting with untrusted contracts.

Requirements:

- Caller is either approved or the `token_id` owner.
- `from` is not the zero address.
- `to` is not the zero address.
- `token_ids` and `values` must have the same length.
- If `to` refers to a non-account contract, it must implement `IERC1155Receiver::on_ERC1155_batch_received` and return the acceptance magic value.

Emits a [TransferSingle](#ERC1155Component-TransferSingle) event if the arrays contain one element, and [TransferBatch](#ERC1155Component-TransferBatch) otherwise.
</APIItem>

<APIItem
  functionSignature="set_approval_for_all(ref self: ContractState, operator: ContractAddress, approved: bool)"
  id="ERC1155Component-set_approval_for_all"
  kind="external"
>
Enables or disables approval for `operator` to manage all of the callers assets.

Requirements:

- `operator` cannot be the caller.

Emits an [ApprovalForAll](#ERC1155Component-ApprovalForAll) event.
</APIItem>

<APIItem
  functionSignature="is_approved_for_all(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool"
  id="ERC1155Component-is_approved_for_all"
  kind="external"
>
Queries if `operator` is an authorized operator for `owner`.
</APIItem>

<APIItem
  functionSignature="uri(self: @ContractState, token_id: u256) -> ByteArray"
  id="ERC1155Component-uri"
  kind="external"
>

This implementation returns the same URI for **all** token types. It relies on the token type ID substitution mechanism [specified in the EIP](https://eips.ethereum.org/EIPS/eip-1155#metadata).

Clients calling this function must replace the `id` substring with the actual token type ID.
</APIItem>

<APIItem
  functionSignature="balanceOf(self: @ContractState, account: ContractAddress, tokenId: u256) → u256"
  id="ERC1155Component-balanceOf"
  kind="external"
>
See [ERC1155Component::balance\_of](#ERC1155Component-balance_of).
</APIItem>

<APIItem
  functionSignature="balanceOfBatch(self: @ContractState, accounts: Span<ContractAddress>, tokenIds: Span<u256>) → Span<u256>"
  id="ERC1155Component-balanceOfBatch"
  kind="external"
>
See [ERC1155Component::balance\_of\_batch](#ERC1155Component-balance_of_batch).
</APIItem>

<APIItem
  functionSignature="safeTransferFrom(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256, value: u256, data: Span<felt252>)"
  id="ERC1155Component-safeTransferFrom"
  kind="external"
>
See [ERC1155Component::safe\_transfer\_from](#ERC1155Component-safe_transfer_from).
</APIItem>

<APIItem
  functionSignature="safeBatchTransferFrom(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenIds: Span<u256>, values: Span<u256>, data: Span<felt252>)"
  id="ERC1155Component-safeBatchTransferFrom"
  kind="external"
>
See [ERC1155Component::safe\_batch\_transfer\_from](#ERC1155Component-safe_batch_transfer_from).
</APIItem>

<APIItem
  functionSignature="setApprovalForAll(ref self: ContractState, operator: ContractAddress, approved: bool)"
  id="ERC1155Component-setApprovalForAll"
  kind="external"
>
See [ERC1155Component::set\_approval\_for\_all](#ERC1155Component-set_approval_for_all).
</APIItem>

<APIItem
  functionSignature="isApprovedForAll(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool"
  id="ERC1155Component-isApprovedForAll"
  kind="external"
>
See [ERC1155Component::is\_approved\_for\_all](#ERC1155Component-is_approved_for_all).
</APIItem>

#### Internal functions [!toc] [#internal_functions]

<APIItem
  functionSignature="initializer(ref self: ContractState, base_uri: ByteArray)"
  id="ERC1155Component-initializer"
  kind="internal"
>
Initializes the contract by setting the token's base URI as `base_uri`, and registering the supported interfaces. This should only be used inside the contract's constructor.

Most ERC1155 contracts expose the [IERC1155MetadataURI](#IERC1155MetadataURI) interface which is what this initializer is meant to support. If the contract DOES NOT expose the [IERC1155MetadataURI](#IERC1155MetadataURI) interface, meaning tokens do not have a URI, the contract must instead use [initializer\_no\_metadata](#ERC1155Component-initializer_no_metadata) in the constructor. Failure to abide by these instructions can lead to unexpected issues especially with UIs.
</APIItem>

<APIItem
  functionSignature="initializer_no_metadata(ref self: ContractState)"
  id="ERC1155Component-initializer_no_metadata"
  kind="internal"
>
Initializes the contract with no metadata by registering only the IERC1155 interface.

This initializer should ONLY be used during construction in the very specific instance when the contract does NOT expose the [IERC1155MetadataURI](#IERC1155MetadataURI) interface. Initializing a contract with this initializer means that tokens will not have a URI.
</APIItem>

<APIItem
  functionSignature="mint_with_acceptance_check(ref self: ContractState, to: ContractAddress, token_id: u256, value: u256, data: Span<felt252>)"
  id="ERC1155Component-mint_with_acceptance_check"
  kind="internal"
>
Creates a `value` amount of tokens of type `token_id`, and assigns them to `to`.

Requirements:

- `to` cannot be the zero address.
- If `to` refers to a smart contract, it must implement `IERC1155Receiver::on_ERC1155_received` and return the acceptance magic value.

Emits a [TransferSingle](#ERC1155Component-TransferSingle) event.
</APIItem>

<APIItem
  functionSignature="batch_mint_with_acceptance_check(ref self: ContractState, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)"
  id="ERC1155Component-batch_mint_with_acceptance_check"
  kind="internal"
>
Batched version of [mint\_with\_acceptance\_check](#ERC1155Component-mint_with_acceptance_check).

Requirements:

- `to` cannot be the zero address.
- `token_ids` and `values` must have the same length.
- If `to` refers to a smart contract, it must implement `IERC1155Receiver::on_ERC1155_batch_received` and return the acceptance magic value.

Emits a [TransferBatch](#ERC1155Component-TransferBatch) event.
</APIItem>

<APIItem
  functionSignature="burn(ref self: ContractState, from: ContractAddress, token_id: u256, value: u256)"
  id="ERC1155Component-burn"
  kind="internal"
>
Destroys a `value` amount of tokens of type `token_id` from `from`.

Requirements:

- `from` cannot be the zero address.
- `from` must have at least `value` amount of tokens of type `token_id`.

Emits a [TransferSingle](#ERC1155Component-TransferSingle) event.
</APIItem>

<APIItem
  functionSignature="batch_burn(ref self: ContractState, from: ContractAddress, token_ids: Span<u256>, values: Span<u256>)"
  id="ERC1155Component-batch_burn"
  kind="internal"
>
Batched version of [burn](#ERC1155Component-burn).

Requirements:

- `from` cannot be the zero address.
- `from` must have at least `value` amount of tokens of type `token_id`.
- `token_ids` and `values` must have the same length.

Emits a [TransferBatch](#ERC1155Component-TransferBatch) event.
</APIItem>

<APIItem
  functionSignature="update_with_acceptance_check(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data: Span<felt252>)"
  id="ERC1155Component-update_with_acceptance_check"
  kind="internal"
>
Version of `update` that performs the token acceptance check by calling `onERC1155Received` or `onERC1155BatchReceived` in the receiver if it implements `IERC1155Receiver`, otherwise by checking if it is an account.

Requirements:

- `to` is either an account contract or supports the `IERC1155Receiver` interface.
- `token_ids` and `values` must have the same length.

Emits a [TransferSingle](#ERC1155Component-TransferSingle) event if the arrays contain one element, and [TransferBatch](#ERC1155Component-TransferBatch) otherwise.
</APIItem>

<APIItem
  functionSignature="update(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_ids: Span<u256>, values: Span<u256>)"
  id="ERC1155Component-update"
  kind="internal"
>
Transfers a `value` amount of tokens of type `id` from `from` to `to`. Will mint (or burn) if `from` (or `to`) is the zero address.

Requirements:

- `token_ids` and `values` must have the same length.

Emits a [TransferSingle](#ERC1155Component-TransferSingle) event if the arrays contain one element, and [TransferBatch](#ERC1155Component-TransferBatch) otherwise.

This function can be extended using the [ERC1155HooksTrait](#ERC1155Component-ERC1155HooksTrait), to add functionality before and/or after the transfer, mint, or burn.

The ERC1155 acceptance check is not performed in this function. See [update\_with\_acceptance\_check](#ERC1155Component-update_with_acceptance_check) instead.
</APIItem>

<APIItem
  functionSignature="_set_base_uri(ref self: ContractState, base_uri: ByteArray)"
  id="ERC1155Component-_set_base_uri"
  kind="internal"
>
Sets a new URI for all token types, by relying on the token type ID substitution mechanism [specified in the EIP](https://eips.ethereum.org/EIPS/eip-1155#metadata).

By this mechanism, any occurrence of the `id` substring in either the URI or any of the values in the JSON file at said URI will be replaced by clients with the token type ID.

For example, the `https://token-cdn-domain/\id\.json` URI would be interpreted by clients as `https://token-cdn-domain/000000000000...000000000000004cce0.json` for token type ID `0x4cce0`.

Because these URIs cannot be meaningfully represented by the `URI` event, this function emits no events.
</APIItem>

#### Events [!toc] [#events_2]

<APIItem
  functionSignature="TransferSingle(operator: ContractAddress, from: ContractAddress, to: ContractAddress, id: u256, value: u256)"
  id="ERC1155Component-TransferSingle"
  kind="event"
>
See [IERC1155::TransferSingle](#IERC1155-TransferSingle).
</APIItem>

<APIItem
  functionSignature="TransferBatch(operator: ContractAddress, from: ContractAddress, to: ContractAddress, ids: Span<u256>, values: Span<u256>)"
  id="ERC1155Component-TransferBatch"
  kind="event"
>
See [IERC1155::TransferBatch](#IERC1155-TransferBatch).
</APIItem>

<APIItem
  functionSignature="ApprovalForAll(owner: ContractAddress, operator: ContractAddress, approved: bool)"
  id="ERC1155Component-ApprovalForAll"
  kind="event"
>
See [IERC1155::ApprovalForAll](#IERC1155-ApprovalForAll).
</APIItem>

<APIItem
  functionSignature="URI(value: ByteArray, id: u256)"
  id="ERC1155Component-URI"
  kind="event"
>

See [IERC1155::URI](#IERC1155-URI).
</APIItem>

### `ERC1155ReceiverComponent` [toc] [#ERC1155ReceiverComponent]

<APIGithubLinkHeader
  moduleName="ERC1155ReceiverComponent"
  link={`https://github.com/OpenZeppelin/cairo-contracts/blob/${UMBRELLA_VERSION}/packages/token/src/erc1155/erc1155_receiver.cairo`}
/>

```rust
use openzeppelin_token::erc1155::ERC1155ReceiverComponent;
```

ERC1155Receiver component implementing [IERC1155Receiver](#IERC1155Receiver).

Implementing [SRC5Component](introspection#SRC5Component) is a requirement for this component to be implemented.

[Embeddable Mixin Implementations](../components#mixins)

#### ERC1155MixinImpl [!toc] [#ERC1155ReceiverComponent-Embeddable-Impls-ERC1155MixinImpl]

- [`ERC1155ReceiverImpl`](#ERC1155ReceiverComponent-Embeddable-Impls-ERC1155ReceiverImpl)
- [`ERC1155ReceiverCamelImpl`](#ERC1155ReceiverComponent-Embeddable-Impls-ERC1155ReceiverCamelImpl)
- [`SRC5Impl`](introspection#SRC5Component-Embeddable-Impls-SRC5Impl)

Embeddable Implementations

#### ERC1155ReceiverImpl [!toc] [#ERC1155ReceiverComponent-Embeddable-Impls-ERC1155ReceiverImpl]

- [`on_erc1155_received(self, operator, from, token_id, value, data)`](#ERC1155ReceiverComponent-on_erc1155_received)
- [`on_erc1155_batch_received(self, operator, from, token_ids, values, data)`](#ERC1155ReceiverComponent-on_erc1155_batch_received)

#### ERC1155ReceiverCamelImpl [!toc] [#ERC1155ReceiverComponent-Embeddable-Impls-ERC1155ReceiverCamelImpl]

- [`onERC1155Received(self, operator, from, tokenId, value, data)`](#ERC1155ReceiverComponent-onERC1155Received)
- [`onERC1155BatchReceived(self, operator, from, tokenIds, values, data)`](#ERC1155ReceiverComponent-onERC1155BatchReceived)

Internal Functions

#### InternalImpl [!toc] [#ERC1155ReceiverComponent-InternalImpl]

- [`initializer(self)`](#ERC1155ReceiverComponent-initializer)

#### Embeddable functions [!toc] [#embeddable_functions_2]

<APIItem
  functionSignature="on_erc1155_received(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, value: u256, data Span<felt252>) -> felt252"
  id="ERC1155ReceiverComponent-on_erc1155_received"
  kind="external"
>
Returns the `IERC1155Receiver` interface ID.
</APIItem>

<APIItem
  functionSignature="on_erc1155_batch_received(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_ids: Span<u256>, values: Span<u256>, data Span<felt252>) -> felt252"
  id="ERC1155ReceiverComponent-on_erc1155_batch_received"
  kind="external"
>
Returns the `IERC1155Receiver` interface ID.
</APIItem>

<APIItem
  functionSignature="onERC1155Received(self: @ContractState, operator: ContractAddress, from: ContractAddress, tokenId: u256, value: u256, data Span<felt252>) -> felt252"
  id="ERC1155ReceiverComponent-onERC1155Received"
  kind="external"
>
See [ERC1155ReceiverComponent::on\_erc1155\_received](#ERC1155ReceiverComponent-on_erc1155_received).
</APIItem>

<APIItem
  functionSignature="onERC1155BatchReceived(self: @ContractState, operator: ContractAddress, from: ContractAddress, tokenIds: Span<u256>, values: Span<u256>, data Span<felt252>) -> felt252"
  id="ERC1155ReceiverComponent-onERC1155BatchReceived"
  kind="external"
>
See [ERC1155ReceiverComponent::on\_erc1155\_batch\_received](#ERC1155ReceiverComponent-on_erc1155_batch_received).
</APIItem>

#### Internal functions [!toc] [#internal_functions_2]

<APIItem
  functionSignature="initializer(ref self: ContractState)"
  id="ERC1155ReceiverComponent-initializer"
  kind="internal"
>
Registers the `IERC1155Receiver` interface ID as supported through introspection.
</APIItem>

## [](#presets)Presets

### `ERC1155Upgradeable` [toc] [#ERC1155Upgradeable]

<APIGithubLinkHeader
  moduleName="ERC1155Upgradeable"
  link={`https://github.com/OpenZeppelin/cairo-contracts/blob/${UMBRELLA_VERSION}/packages/presets/src/erc1155.cairo`}
/>

```rust
use openzeppelin_presets::ERC1155;
```

Upgradeable ERC1155 contract leveraging [ERC1155Component](#ERC1155Component).

[Sierra class hash](../presets)

```text
{{ERC1155UpgradeableClassHash}}
```

Constructor

- [`constructor(self, base_uri, recipient, token_ids, values, owner)`](#ERC1155Upgradeable-constructor)

Embedded Implementations

ERC1155Component

- [`ERC1155MixinImpl`](#ERC1155Component-Embeddable-Mixin-Impl)

OwnableMixinImpl

- [`OwnableMixinImpl`](access#OwnableComponent-Mixin-Impl)

External Functions

- [`upgrade(self, new_class_hash)`](#ERC1155Upgradeable-upgrade)

#### Constructor [!toc] [#ERC1155Upgradeable-constructor-section]

<APIItem
  functionSignature="constructor(ref self: ContractState, base_uri: ByteArray, recipient: ContractAddress, token_ids: Span<u256>, values: Span<u256>, owner: ContractAddress)"
  id="ERC1155Upgradeable-constructor"
  kind="constructor"
>
Sets the `base_uri` for all tokens and registers the supported interfaces. Mints the `values` for `token_ids` tokens to `recipient`. Assigns `owner` as the contract owner with permissions to upgrade.

Requirements:

- `to` is either an account contract (supporting ISRC6) or supports the `IERC1155Receiver` interface.
- `token_ids` and `values` must have the same length.
</APIItem>

#### External Functions [!toc] [#ERC1155Upgradeable-external-functions]

<APIItem
  functionSignature="upgrade(ref self: ContractState, new_class_hash: ClassHash)"
  id="ERC1155Upgradeable-upgrade"
  kind="external"
>
Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

- The caller is the contract owner.
- `new_class_hash` cannot be zero.
</APIItem>
