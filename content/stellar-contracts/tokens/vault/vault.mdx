---
title: Fungible Token Vault
---

[Source Code](https://github.com/OpenZeppelin/stellar-contracts/tree/main/packages/tokens/src/vault)

The Fungible Token Vault extends the [Fungible Token](/stellar-contracts/tokens/fungible/fungible) and implements the ERC-4626 tokenized vault standard,
enabling fungible tokens to represent shares in an underlying asset pool. The tokenized vault standard
is the formalized interface for yield-bearing vaults that hold underlying assets. Vault shares enable
hyperfungible collaterals in DeFi and remain fully compatible with standard fungible token operations.

This module allows users to deposit underlying assets in exchange for vault shares, and later redeem
those shares for the underlying assets. The vault maintains a dynamic conversion rate between shares and
assets based on the total supply of shares and total assets held by the vault contract.

## Overview

The [Vault](https://github.com/OpenZeppelin/stellar-contracts/tree/main/packages/tokens/src/vault) module provides a complete implementation of tokenized vaults following the ERC-4626 standard. Vaults are useful for:

- **Yield-bearing tokens**: Represent shares in a yield-generating strategy
- **Liquidity pools**: Pool assets together with automatic share calculation
- **Asset management**: Manage a pool of assets with proportional ownership
- **Wrapped tokens**: Create wrapped versions of tokens with additional features

The vault automatically handles:
- Share-to-asset conversion with configurable precision
- Deposit and withdrawal operations
- Minting and redemption of shares
- Preview functions for simulating operations

## Key Concepts

### Shares vs Assets

- **Assets**: The underlying token that the vault manages (e.g., USDC, XLM)
- **Shares**: The Token Vaults that represent proportional ownership of the assets

When assets are deposited into a vault, shares are minted to the depositor.
The number of shares minted depends on the current exchange rate, which is determined by:

```
shares = (assets × totalSupply) / totalAssets
```

When withdrawing or redeeming, the reverse calculation applies:

```
assets = (shares × totalAssets) / totalSupply
```

### Virtual Decimals Offset

The vault uses a "virtual decimals offset" to add extra precision to share calculations.
This helps prevent rounding errors and improves the accuracy of share-to-asset conversions,
especially when the vault has few assets or shares. It's also a key defense mechanism against
[inflation attacks](#inflation-precision-attacks).

The offset adds virtual shares and assets to the conversion formula:

```
shares = (assets × (totalSupply + 10^offset)) / (totalAssets + 1)
```

The offset is bounded to a maximum of 10 with both security and UX taken into account.
Values higher than 10 provide minimal practical benefits and may cause overflow errors.

## Rounding Behavior

The vault implements specific rounding behavior to protect against being drained through repeated rounding exploits.
Without proper rounding, an attacker could exploit precision loss to extract more assets than they deposited by
performing many small operations where rounding errors accumulate in their favor.

To prevent this:

- **Deposit/Redeem**: Rounds **down** (depositor receives slightly fewer shares/assets)
- **Mint/Withdraw**: Rounds **up** (depositor provides slightly more assets/shares)

This ensures the vault always retains a slight advantage in conversions, making such attacks unprofitable.

| Operation  | Input  | Output | Rounding Direction           |
| ---------- | ------ | ------ | ---------------------------- |
| `deposit`  | assets | shares | Down (fewer shares)          |
| `mint`     | shares | assets | Up (more assets required)    |
| `withdraw` | assets | shares | Up (more shares burned)      |
| `redeem`   | shares | assets | Down (fewer assets received) |

## Security Considerations

### Initialization

The vault **MUST** be properly initialized before use:

1. Call `Vault::set_asset(e, asset)` to set the underlying asset
2. Call `Vault::set_decimals_offset(e, offset)` to set the decimals offset
3. Initialize metadata with `Base::set_metadata()`

These should typically be done in the constructor. Once set, the asset address and decimals offset are **immutable**.

### Decimal Offset Limits

The decimals offset is limited to a maximum of 10 to prevent:
- Overflow errors in calculations
- Excessive precision that provides no practical benefit
- Poor user experience with unnecessarily large numbers

If a higher offset is required, a custom version of `set_decimals_offset()` must be implemented.

### Inflation (Precision) Attacks

The virtual decimals offset helps protect against inflation attacks where an attacker:
1. Deposits 1 stroop to get the first share (becoming the sole shareholder)
2. **Donates** (not deposits) an enormous amount of assets directly to the vault contract via a direct transfer, without receiving any shares in return. This inflates the vault's total assets while keeping total shares at 1, making that single share worth an enormous amount
3. When a legitimate user tries to deposit (e.g., 1000 stroops), the share calculation rounds down to 0 shares because their deposit is negligible compared to the inflated vault balance. The user loses their deposit while receiving nothing

For example: If the attacker donates 1,000,000 stroops after their initial 1 stroop deposit, the vault has 1,000,001 total assets and 1 total share. A user depositing 1000 stroops would receive `(1000 × 1) / 1,000,001 = 0.000999` shares, which rounds down to 0.

The offset adds virtual shares and assets to the conversion formula, making such attacks economically infeasible by ensuring the denominator is never so small that legitimate deposits round to zero.

For more details about the mechanics of this attack, see the [OpenZeppelin ERC-4626 security documentation](https://docs.openzeppelin.com/contracts/5.x/erc4626#security-concern-inflation-attack).

### Custom Authorization

Custom authorization logic can be implemented as needed:

```rust
fn deposit(
    e: &Env,
    assets: i128,
    receiver: Address,
    from: Address,
    operator: Address,
) -> i128 {
    // Custom authorization: only allow deposits from whitelisted addresses
    if !is_whitelisted(e, &from) {
        panic_with_error!(e, Error::NotWhitelisted);
    }

    operator.require_auth();
    Vault::deposit(e, assets, receiver, from, operator)
}
```

## Compatibility and Compliance

The vault module implements the ERC-4626 tokenized vault standard with one minor deviation (see Security Considerations).

### ERC-4626 Deviation

<Callout type="warning">
**DEVIATION FROM ERC-4626**: The `query_asset()` function will panic if the asset address is not set, whereas ERC-4626 requires it to never revert.

**Rationale**: Soroban doesn't have a "zero address" concept like EVM. Returning `Option<Address>` would break ERC-4626 compatibility.

**Mitigation**: Always initialize the vault properly in the constructor. Once initialized, `query_asset()` will never panic during normal operations.
</Callout>

Aside from this deviation, the vault implementation for Soroban provides:

- **Cross-ecosystem familiarity**: Ethereum developers will recognize the interface
- **Standard compliance**: Compatible with ERC-4626 tooling and integrations
- **Stellar optimizations**: Leverages Soroban's unique capabilities
