---
title: ERC721
---

This module provides interfaces, presets, and utilities related to ERC721 contracts.

For an overview of ERC721, read our [ERC721 guide](../erc721).

## [](#interfaces)Interfaces

Starting from version `3.x.x`, the interfaces are no longer part of the `openzeppelin_token` package. The references documented here are contained in the `openzeppelin_interfaces` package version `v2.1.0`.

### [](#IERC721)`IERC721`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/interfaces/src/token/erc721.cairo)

```cairo
use openzeppelin_interfaces::erc721::IERC721;
```

Interface of the IERC721 standard as defined in [EIP721](https://eips.ethereum.org/EIPS/eip-721).

[SRC5 ID](introspection#ISRC5)

0x33eb2f84c309543403fd69f0d0f363781ef06ef6faeb0131ff16ea3175bd943

Functions

- [`balance_of(account)`](#IERC721-balance_of)
- [`owner_of(token_id)`](#IERC721-owner_of)
- [`safe_transfer_from(from, to, token_id, data)`](#IERC721-safe_transfer_from)
- [`transfer_from(from, to, token_id)`](#IERC721-transfer_from)
- [`approve(to, token_id)`](#IERC721-approve)
- [`set_approval_for_all(operator, approved)`](#IERC721-set_approval_for_all)
- [`get_approved(token_id)`](#IERC721-get_approved)
- [`is_approved_for_all(owner, operator)`](#IERC721-is_approved_for_all)

Events

- [`Approval(owner, approved, token_id)`](#IERC721-Approval)
- [`ApprovalForAll(owner, operator, approved)`](#IERC721-ApprovalForAll)
- [`Transfer(from, to, token_id)`](#IERC721-Transfer)

#### [](#functions)Functions

#### [](#IERC721-balance_of)`balance_of(account: ContractAddress) → u256` external

Returns the number of NFTs owned by `account`.

#### [](#IERC721-owner_of)`owner_of(token_id: u256) → ContractAddress` external

Returns the owner address of `token_id`.

#### [](#IERC721-safe_transfer_from)`safe_transfer_from(from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)` external

Transfer ownership of `token_id` from `from` to `to`, checking first that `to` is aware of the ERC721 protocol to prevent tokens being locked forever. For information regarding how contracts communicate their awareness of the ERC721 protocol, see [Receiving Tokens](../erc721#receiving_tokens).

Emits a [Transfer](#IERC721-Transfer) event.

#### [](#IERC721-transfer_from)`transfer_from(from: ContractAddress, to: ContractAddress, token_id: u256)` external

Transfer ownership of `token_id` from `from` to `to`.

Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721 transfers or else they may be permanently lost. Usage of [IERC721::safe\_transfer\_from](#IERC721-safe_transfer_from) prevents loss, though the caller must understand this adds an external call which potentially creates a reentrancy vulnerability.

Emits a [Transfer](#IERC721-Transfer) event.

#### [](#IERC721-approve)`approve(to: ContractAddress, token_id: u256)` external

Change or reaffirm the approved address for an NFT.

Emits an [Approval](#IERC721-Approval) event.

#### [](#IERC721-set_approval_for_all)`set_approval_for_all(operator: ContractAddress, approved: bool)` external

Enable or disable approval for `operator` to manage all of the caller’s assets.

Emits an [ApprovalForAll](#IERC721-ApprovalForAll) event.

#### [](#IERC721-get_approved)`get_approved(token_id: u256) -> u256` external

Returns the address approved for `token_id`.

#### [](#IERC721-is_approved_for_all)`is_approved_for_all(owner: ContractAddress, operator: ContractAddress) -> bool` external

Query if `operator` is an authorized operator for `owner`.

#### [](#events)Events

#### [](#IERC721-Approval)`Approval(owner: ContractAddress, approved: ContractAddress, token_id: u256)` event

Emitted when `owner` enables `approved` to manage the `token_id` token.

#### [](#IERC721-ApprovalForAll)`ApprovalForAll(owner: ContractAddress, operator: ContractAddress, approved: bool)` event

Emitted when `owner` enables or disables `operator` to manage the `token_id` token.

#### [](#IERC721-Transfer)`Transfer(from: ContractAddress, to: ContractAddress, token_id: u256)` event

Emitted when `token_id` token is transferred from `from` to `to`.

### [](#IERC721Metadata)`IERC721Metadata`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/interfaces/src/token/erc721.cairo)

```cairo
use openzeppelin_interfaces::erc721::IERC721Metadata;
```

Interface for the optional metadata functions in [EIP721](https://eips.ethereum.org/EIPS/eip-721).

[SRC5 ID](introspection#ISRC5)

0xabbcd595a567dce909050a1038e055daccb3c42af06f0add544fa90ee91f25

Functions

- [`name()`](#IERC721Metadata-name)
- [`symbol()`](#IERC721Metadata-symbol)
- [`token_uri(token_id)`](#IERC721Metadata-token_uri)

#### [](#functions_2)Functions

#### [](#IERC721Metadata-name)`name() -> ByteArray` external

Returns the NFT name.

#### [](#IERC721Metadata-symbol)`symbol() -> ByteArray` external

Returns the NFT ticker symbol.

#### [](#IERC721Metadata-token_uri)`token_uri(token_id: u256) -> ByteArray` external

Returns the Uniform Resource Identifier (URI) for the `token_id` token. If the URI is not set for `token_id`, the return value will be an empty `ByteArray`.

### [](#IERC721Receiver)`IERC721Receiver`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/interfaces/src/token/erc721.cairo)

```cairo
use openzeppelin_interfaces::erc721::IERC721Receiver;
```

Interface for contracts that support receiving `safe_transfer_from` transfers.

[SRC5 ID](introspection#ISRC5)

0x3a0dff5f70d80458ad14ae37bb182a728e3c8cdda0402a5daa86620bdf910bc

Functions

- [`on_erc721_received(operator, from, token_id, data)`](#IERC721Receiver-on_erc721_received)

#### [](#functions_3)Functions

#### [](#IERC721Receiver-on_erc721_received)`on_erc721_received(operator: ContractAddress, from: ContractAddress, token_id: u256, data: Span<felt252>) -> felt252` external

Whenever an IERC721 `token_id` token is transferred to this non-account contract via [IERC721::safe\_transfer\_from](#IERC721-safe_transfer_from) by `operator` from `from`, this function is called.

### [](#IERC721Enumerable)`IERC721Enumerable`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/interfaces/src/token/erc721.cairo)

Interface for the optional enumerable functions in [EIP721](https://eips.ethereum.org/EIPS/eip-721).

[SRC5 ID](introspection#ISRC5)

0x16bc0f502eeaf65ce0b3acb5eea656e2f26979ce6750e8502a82f377e538c87

Functions

- [`total_supply()`](#IERC721Enumerable-total_supply)
- [`token_by_index(index)`](#IERC721Enumerable-token_by_index)
- [`token_of_owner_by_index(owner, index)`](#IERC721Enumerable-token_of_owner_by_index)

#### [](#functions_4)Functions

#### [](#IERC721Enumerable-total_supply)`total_supply() -> u256` external

Returns the total amount of tokens stored by the contract.

#### [](#IERC721Enumerable-token_by_index)`token_by_index(index: u256) -> u256` external

Returns a token id at a given `index` of all the tokens stored by the contract. Use along with [IERC721Enumerable::total\_supply](#IERC721Enumerable-total_supply) to enumerate all tokens.

#### [](#IERC721Enumerable-token_of_owner_by_index)`token_of_owner_by_index(owner: ContractAddress, index: u256) -> u256` external

Returns the token id owned by `owner` at a given `index` of its token list. Use along with [IERC721::balance\_of](#IERC721-balance_of) to enumerate all of `owner`'s tokens.

## [](#core)Core

### [](#ERC721Component)`ERC721Component`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/token/src/erc721/erc721.cairo)

```cairo
use openzeppelin_token::erc721::ERC721Component;
```

ERC721 component implementing [IERC721](#IERC721) and [IERC721Metadata](#IERC721Metadata).

Implementing [SRC5Component](introspection#SRC5Component) is a requirement for this component to be implemented.

See [Hooks](#ERC721Component-Hooks) to understand how are hooks used.

Hooks

ERC721HooksTrait

- [`before_update(self, to, token_id, auth)`](#ERC721Component-before_update)
- [`after_update(self, to, token_id, auth)`](#ERC721Component-after_update)

[Embeddable Mixin Implementations](../components#mixins)

ERC721MixinImpl

- [`ERC721Impl`](#ERC721Component-Embeddable-Impls-ERC721Impl)
- [`ERC721MetadataImpl`](#ERC721Component-Embeddable-Impls-ERC721MetadataImpl)
- [`ERC721CamelOnlyImpl`](#ERC721Component-Embeddable-Impls-ERC721CamelOnlyImpl)
- [`ERC721MetadataCamelOnlyImpl`](#ERC721Component-Embeddable-Impls-ERC721MetadataCamelOnlyImpl)
- [`SRC5Impl`](introspection#SRC5Component-Embeddable-Impls)

Embeddable Implementations

ERC721Impl

- [`balance_of(self, account)`](#ERC721Component-balance_of)
- [`owner_of(self, token_id)`](#ERC721Component-owner_of)
- [`safe_transfer_from(self, from, to, token_id, data)`](#ERC721Component-safe_transfer_from)
- [`transfer_from(self, from, to, token_id)`](#ERC721Component-transfer_from)
- [`approve(self, to, token_id)`](#ERC721Component-approve)
- [`set_approval_for_all(self, operator, approved)`](#ERC721Component-set_approval_for_all)
- [`get_approved(self, token_id)`](#ERC721Component-get_approved)
- [`is_approved_for_all(self, owner, operator)`](#ERC721Component-is_approved_for_all)

ERC721MetadataImpl

- [`name(self)`](#ERC721Component-name)
- [`symbol(self)`](#ERC721Component-symbol)
- [`token_uri(self, token_id)`](#ERC721Component-token_uri)

ERC721CamelOnlyImpl

- [`balanceOf(self, account)`](#ERC721Component-balanceOf)
- [`ownerOf(self, tokenId)`](#ERC721Component-ownerOf)
- [`safeTransferFrom(self, from, to, tokenId, data)`](#ERC721Component-safeTransferFrom)
- [`transferFrom(self, from, to, tokenId)`](#ERC721Component-transferFrom)
- [`setApprovalForAll(self, operator, approved)`](#ERC721Component-setApprovalForAll)
- [`getApproved(self, tokenId)`](#ERC721Component-getApproved)
- [`isApprovedForAll(self, owner, operator)`](#ERC721Component-isApprovedForAll)

ERC721MetadataCamelOnlyImpl

- [`tokenURI(self, tokenId)`](#ERC721Component-tokenURI)

SRC5Impl

- [`supports_interface(self, interface_id: felt252)`](introspection#ISRC5-supports_interface)

Internal functions

InternalImpl

- [`initializer(self, name, symbol, base_uri)`](#ERC721Component-initializer)
- [`initializer_no_metadata(self)`](#ERC721Component-initializer_no_metadata)
- [`exists(self, token_id)`](#ERC721Component-exists)
- [`transfer(self, from, to, token_id)`](#ERC721Component-transfer)
- [`mint(self, to, token_id)`](#ERC721Component-mint)
- [`safe_transfer(self, from, to, token_id, data)`](#ERC721Component-safe_transfer)
- [`safe_mint(self, to, token_id, data)`](#ERC721Component-safe_mint)
- [`burn(self, token_id)`](#ERC721Component-burn)
- [`update(self, to, token_id, auth)`](#ERC721Component-update)
- [`_owner_of(self, token_id)`](#ERC721Component-_owner_of)
- [`_require_owned(self, token_id)`](#ERC721Component-_require_owned)
- [`_approve(self, to, token_id, auth)`](#ERC721Component-_approve)
- [`_approve_with_optional_event(self, to, token_id, auth, emit_event)`](#ERC721Component-_approve_with_optional_event)
- [`_set_approval_for_all(self, owner, operator, approved)`](#ERC721Component-_set_approval_for_all)
- [`_set_base_uri(self, base_uri)`](#ERC721Component-_set_base_uri)
- [`_base_uri(self)`](#ERC721Component-_base_uri)
- [`_is_authorized(self, owner, spender, token_id)`](#ERC721Component-_is_authorized)
- [`_check_authorized(self, owner, spender, token_id)`](#ERC721Component-_check_authorized)

Events

IERC721

- [`Approval(owner, approved, token_id)`](#ERC721Component-Approval)
- [`ApprovalForAll(owner, operator, approved)`](#ERC721Component-ApprovalForAll)
- [`Transfer(from, to, token_id)`](#ERC721Component-Transfer)

#### [](#ERC721Component-Hooks)Hooks

Hooks are functions which implementations can extend the functionality of the component source code. Every contract using ERC721Component is expected to provide an implementation of the ERC721HooksTrait. For basic token contracts, an empty implementation with no logic must be provided.

You can use `openzeppelin_token::erc721::ERC721HooksEmptyImpl` which is already available as part of the library for this purpose.

#### [](#ERC721Component-before_update)`before_update(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)` hook

Function executed at the beginning of the [update](#ERC721Component-update) function prior to any other logic.

#### [](#ERC721Component-after_update)`after_update(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)` hook

Function executed at the end of the [update](#ERC721Component-update) function.

#### [](#embeddable_functions)Embeddable functions

#### [](#ERC721Component-balance_of)`balance_of(self: @ContractState, account: ContractAddress) → u256` external

See [IERC721::balance\_of](#IERC721-balance_of).

#### [](#ERC721Component-owner_of)`owner_of(self: @ContractState, token_id: u256) → ContractAddress` external

See [IERC721::owner\_of](#IERC721-owner_of).

Requirements:

- `token_id` exists.

#### [](#ERC721Component-safe_transfer_from)`safe_transfer_from(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)` external

See [IERC721::safe\_transfer\_from](#IERC721-safe_transfer_from).

Requirements:

- Caller is either approved or the `token_id` owner.
- `to` is not the zero address.
- `from` is not the zero address.
- `token_id` exists.
- `to` is either an account contract or supports the [IERC721Receiver](#IERC721Receiver) interface.

#### [](#ERC721Component-transfer_from)`transfer_from(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256)` external

See [IERC721::transfer\_from](#IERC721-transfer_from).

Requirements:

- Caller either approved or the `token_id` owner.
- `to` is not the zero address.
- `from` is not the zero address.
- `token_id` exists.

#### [](#ERC721Component-approve)`approve(ref self: ContractState, to: ContractAddress, token_id: u256)` external

See [IERC721::approve](#IERC721-approve).

Requirements:

- The caller is either an approved operator or the `token_id` owner.
- `to` cannot be the token owner or the zero address.
- `token_id` exists.

#### [](#ERC721Component-set_approval_for_all)`set_approval_for_all(ref self: ContractState, operator: ContractAddress, approved: bool)` external

See [IERC721::set\_approval\_for\_all](#IERC721-set_approval_for_all).

Requirements:

- `operator` is not the zero address.

#### [](#ERC721Component-get_approved)`get_approved(self: @ContractState, token_id: u256) -> u256` external

See [IERC721::get\_approved](#IERC721-get_approved).

Requirements:

- `token_id` exists.

#### [](#ERC721Component-is_approved_for_all)`is_approved_for_all(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool` external

See [IERC721::is\_approved\_for\_all](#IERC721-is_approved_for_all).

#### [](#ERC721Component-name)`name(self: @ContractState) -> ByteArray` external

See [IERC721Metadata::name](#IERC721Metadata-name).

#### [](#ERC721Component-symbol)`symbol(self: @ContractState) -> ByteArray` external

See [IERC721Metadata::symbol](#IERC721Metadata-symbol).

#### [](#ERC721Component-token_uri)`token_uri(self: @ContractState, token_id: u256) -> ByteArray` external

Returns the Uniform Resource Identifier (URI) for the `token_id` token. If a base URI is set, the resulting URI for each token will be the concatenation of the base URI and the token ID. For example, the base URI `https://token-cdn-domain/` would be returned as `https://token-cdn-domain/123` for token ID `123`.

If the URI is not set for `token_id`, the return value will be an empty `ByteArray`.

#### [](#ERC721Component-balanceOf)`balanceOf(self: @ContractState, account: ContractAddress) -> u256` external

See [ERC721Component::balance\_of](#ERC721Component-balance_of).

#### [](#ERC721Component-ownerOf)`ownerOf(self: @ContractState, tokenId: u256) -> ContractAddress` external

See [ERC721Component::owner\_of](#ERC721Component-owner_of).

#### [](#ERC721Component-safeTransferFrom)`safeTransferFrom(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256, data: Span<felt252>)` external

See [ERC721Component::safe\_transfer\_from](#ERC721Component-safe_transfer_from).

#### [](#ERC721Component-transferFrom)`transferFrom(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256)` external

See [ERC721Component::transfer\_from](#ERC721Component-transfer_from).

#### [](#ERC721Component-setApprovalForAll)`setApprovalForAll(ref self: ContractState, operator: ContractAddress, approved: bool)` external

See [ERC721Component::set\_approval\_for\_all](#ERC721Component-set_approval_for_all).

#### [](#ERC721Component-getApproved)`getApproved(self: @ContractState, tokenId: u256) -> ContractAddress` external

See [ERC721Component::get\_approved](#ERC721Component-get_approved).

#### [](#ERC721Component-isApprovedForAll)`isApprovedForAll(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool` external

See [ERC721Component::is\_approved\_for\_all](#ERC721Component-is_approved_for_all).

#### [](#ERC721Component-tokenURI)`tokenURI(self: @ContractState, tokenId: u256) -> ByteArray` external

See [ERC721Component::token\_uri](#ERC721Component-token_uri).

#### [](#internal_functions)Internal functions

#### [](#ERC721Component-initializer)`initializer(ref self: ContractState, name: ByteArray, symbol: ByteArray, base_uri: ByteArray)` internal

Initializes the contract by setting the token name and symbol. This should be used inside the contract’s constructor.

Most ERC721 contracts expose the [IERC721Metadata](#IERC721Metadata) interface which is what this initializer is meant to support. If the contract DOES NOT expose the [IERC721Metadata](#IERC721Metadata) interface, meaning the token does not have a name, symbol, or URI, the contract must instead use [initializer\_no\_metadata](#ERC721Component-initializer_no_metadata) in the constructor. Failure to abide by these instructions can lead to unexpected issues especially with UIs.

#### [](#ERC721Component-initializer_no_metadata)`initializer_no_metadata(ref self: ContractState)` internal

Initializes the contract with no metadata by registering only the IERC721 interface.

This initializer should ONLY be used during construction in the very specific instance when the contract does NOT expose the [IERC721Metadata](#IERC721Metadata) interface. Initializing a contract with this initializer means that tokens will not have a name, symbol, or URI.

#### [](#ERC721Component-exists)`exists(self: @ContractState, token_id: u256) -> bool` internal

Internal function that returns whether `token_id` exists.

Tokens start existing when they are minted ([mint](#ERC721-mint)), and stop existing when they are burned ([burn](#ERC721-burn)).

#### [](#ERC721Component-transfer)`transfer(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256)` internal

Transfers `token_id` from `from` to `to`.

Internal function without access restriction.

This method may lead to the loss of tokens if `to` is not aware of the ERC721 protocol.

Requirements:

- `to` is not the zero address.
- `from` is the token owner.
- `token_id` exists.

Emits a [Transfer](#IERC721-Transfer) event.

#### [](#ERC721Component-mint)`mint(ref self: ContractState, to: ContractAddress, token_id: u256)` internal

Mints `token_id` and transfers it to `to`. Internal function without access restriction.

This method may lead to the loss of tokens if `to` is not aware of the ERC721 protocol.

Requirements:

- `to` is not the zero address.
- `token_id` does not exist.

Emits a [Transfer](#IERC721-Transfer) event.

#### [](#ERC721Component-safe_transfer)`safe_transfer(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)` internal

Transfers ownership of `token_id` from `from` if `to` is either an account or `IERC721Receiver`.

`data` is additional data, it has no specified format and is forwarded in `IERC721Receiver::on_erc721_received` to `to`.

This method makes an external call to the recipient contract, which can lead to reentrancy vulnerabilities.

Requirements:

- `to` cannot be the zero address.
- `from` must be the token owner.
- `token_id` exists.
- `to` is either an account contract or supports the `IERC721Receiver` interface.

Emits a [Transfer](#IERC721-Transfer) event.

#### [](#ERC721Component-safe_mint)`safe_mint(ref self: ContractState, to: ContractAddress, token_id: u256, data: Span<felt252>)` internal

Mints `token_id` if `to` is either an account or `IERC721Receiver`.

`data` is additional data, it has no specified format and is forwarded in `IERC721Receiver::on_erc721_received` to `to`.

This method makes an external call to the recipient contract, which can lead to reentrancy vulnerabilities.

Requirements:

- `token_id` does not exist.
- `to` is either an account contract or supports the `IERC721Receiver` interface.

Emits a [Transfer](#IERC721-Transfer) event.

#### [](#ERC721Component-burn)`burn(ref self: ContractState, token_id: u256)` internal

Destroys `token_id`. The approval is cleared when the token is burned.

This internal function does not check if the caller is authorized to operate on the token.

Requirements:

- `token_id` exists.

Emits a [Transfer](#IERC721-Transfer) event.

#### [](#ERC721Component-update)`update(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)` internal

Transfers `token_id` from its current owner to `to`, or alternatively mints (or burns) if the current owner (or `to`) is the zero address. Returns the owner of the `token_id` before the update.

The `auth` argument is optional. If the value passed is non-zero, then this function will check that `auth` is either the owner of the token, or approved to operate on the token (by the owner).

Emits a [Transfer](#IERC721-Transfer) event.

This function can be extended using the `ERC721HooksTrait`, to add functionality before and/or after the transfer, mint, or burn.

#### [](#ERC721Component-_owner_of)`_owner_of(self: @ContractState, token_id: felt252) -> ContractAddress` internal

Internal function that returns the owner address of `token_id`.

#### [](#ERC721Component-_require_owned)`_require_owned(self: @ContractState, token_id: felt252) -> ContractAddress` internal

Version of [\_owner\_of](#ERC721Component-_owner_of) that panics if owner is the zero address.

#### [](#ERC721Component-_approve)`_approve(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)` internal

Approve `to` to operate on `token_id`

The `auth` argument is optional. If the value passed is non-zero, then this function will check that `auth` is either the owner of the token, or approved to operate on all tokens held by this owner.

Emits an [Approval](#IERC721-Approval) event.

#### [](#ERC721Component-_approve_with_optional_event)`_approve_with_optional_event(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress, emit_event: bool)` internal

Variant of [\_approve](#ERC721Component-_approve) with an optional flag to enable or disable the `Approval` event. The event is not emitted in the context of transfers.

If `auth` is zero and `emit_event` is false, this function will not check that the token exists.

Requirements:

- if `auth` is non-zero, it must be either the owner of the token or approved to operate on all of its tokens.

May emit an [Approval](#IERC721-Approval) event.

#### [](#ERC721Component-_set_approval_for_all)`_set_approval_for_all(ref self: ContractState, owner: ContractAddress, operator: ContractAddress, approved: bool)` internal

Enables or disables approval for `operator` to manage all of the `owner` assets.

Requirements:

- `operator` is not the zero address.

Emits an [Approval](#IERC721-Approval) event.

#### [](#ERC721Component-_set_base_uri)`_set_base_uri(ref self: ContractState, base_uri: ByteArray)` internal

Internal function that sets the `base_uri`.

#### [](#ERC721Component-_base_uri)`_base_uri(self: @ContractState) -> ByteArray` internal

Base URI for computing [token\_uri](#IERC721Metadata-token_uri).

If set, the resulting URI for each token will be the concatenation of the base URI and the token ID. Returns an empty `ByteArray` if not set.

#### [](#ERC721Component-_is_authorized)`_is_authorized(self: @ContractState, owner: ContractAddress, spender: ContractAddress, token_id: u256) -> bool` internal

Returns whether `spender` is allowed to manage `owner`'s tokens, or `token_id` in particular (ignoring whether it is owned by `owner`).

This function assumes that `owner` is the actual owner of `token_id` and does not verify this assumption.

#### [](#ERC721Component-_check_authorized)`_check_authorized(self: @ContractState, owner: ContractAddress, spender: ContractAddress, token_id: u256) -> bool` internal

Checks if `spender` can operate on `token_id`, assuming the provided `owner` is the actual owner.

Requirements:

- `owner` cannot be the zero address.
- `spender` cannot be the zero address.
- `spender` must be the owner of `token_id` or be approved to operate on it.

This function assumes that `owner` is the actual owner of `token_id` and does not verify this assumption.

#### [](#events_2)Events

#### [](#ERC721Component-Approval)`Approval(owner: ContractAddress, approved: ContractAddress, token_id: u256)` event

See [IERC721::Approval](#IERC721-Approval).

#### [](#ERC721Component-ApprovalForAll)`ApprovalForAll(owner: ContractAddress, operator: ContractAddress, approved: bool)` event

See [IERC721::ApprovalForAll](#IERC721-ApprovalForAll).

#### [](#ERC721Component-Transfer)`Transfer(from: ContractAddress, to: ContractAddress, token_id: u256)` event

See [IERC721::Transfer](#IERC721-Transfer).

### [](#ERC721ReceiverComponent)`ERC721ReceiverComponent`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/token/src/erc721/erc721_receiver.cairo)

```cairo
use openzeppelin_token::erc721::ERC721ReceiverComponent;
```

ERC721Receiver component implementing [IERC721Receiver](#IERC721Receiver).

Implementing [SRC5Component](introspection#SRC5Component) is a requirement for this component to be implemented.

[Embeddable Mixin Implementations](../components#mixins)

ERCReceiverMixinImpl

- [`ERC721ReceiverImpl`](#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverImpl)
- [`ERC721ReceiverCamelImpl`](#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverCamelImpl)
- [`SRC5Impl`](introspection#SRC5Component-Embeddable-Impls)

Embeddable Implementations

ERC721ReceiverImpl

- [`on_erc721_received(self, operator, from, token_id, data)`](#ERC721ReceiverComponent-on_erc721_received)

ERC721ReceiverCamelImpl

- [`onERC721Received(self, operator, from, tokenId, data)`](#ERC721ReceiverComponent-onERC721Received)

Internal Functions

InternalImpl

- [`initializer(self)`](#ERC721ReceiverComponent-initializer)

#### [](#embeddable_functions_2)Embeddable functions

#### [](#ERC721ReceiverComponent-on_erc721_received)`on_erc721_received(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, data Span<felt252>) -> felt252` external

Returns the `IERC721Receiver` interface ID.

#### [](#ERC721ReceiverComponent-onERC721Received)`onERC721Received(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, data Span<felt252>) -> felt252` external

See [ERC721ReceiverComponent::on\_erc721\_received](#ERC721ReceiverComponent-on_erc721_received).

#### [](#internal_functions_2)Internal functions

#### [](#ERC721ReceiverComponent-initializer)`initializer(ref self: ContractState)` internal

Registers the `IERC721Receiver` interface ID as supported through introspection.

## [](#extensions)Extensions

### [](#ERC721EnumerableComponent)`ERC721EnumerableComponent`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/token/src/erc721/extensions/erc721_enumerable.cairo)

```cairo
use openzeppelin_token::erc721::extensions::ERC721EnumerableComponent;
```

Extension of ERC721 as defined in the EIP that adds enumerability of all the token ids in the contract as well as all token ids owned by each account. This extension allows contracts to publish their entire list of NFTs and make them discoverable.

Implementing [ERC721Component](#ERC721Component) is a requirement for this component to be implemented.

To properly track token ids, this extension requires that the [ERC721EnumerableComponent::before\_update](#ERC721EnumerableComponent-before_update) function is called before every transfer, mint, or burn operation. For this, the [ERC721HooksTrait::before\_update](#ERC721Component-before_update) hook must be used. Here’s how the hook should be implemented in a contract:

```[
#[starknet::contract]
mod ERC721EnumerableContract {
    (...)

    component!(path: ERC721Component, storage: erc721, event: ERC721Event);
    component!(path: ERC721EnumerableComponent, storage: erc721_enumerable, event: ERC721EnumerableEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    impl ERC721HooksImpl of ERC721Component::ERC721HooksTrait<ContractState> {
        fn before_update(
            ref self: ERC721Component::ComponentState<ContractState>,
            to: ContractAddress,
            token_id: u256,
            auth: ContractAddress
        ) {
            let mut contract_state = self.get_contract_mut();
            contract_state.erc721_enumerable.before_update(to, token_id);
        }
    }
}
```

Embeddable Implementations

ERC721EnumerableImpl

- [`total_supply(self)`](#ERC721EnumerableComponent-total_supply)
- [`token_by_index(self, index)`](#ERC721EnumerableComponent-token_by_index)
- [`token_of_owner_by_index(self, address, index)`](#ERC721EnumerableComponent-token_of_owner_by_index)

Internal functions

InternalImpl

- [`initializer(self)`](#ERC721EnumerableComponent-initializer)
- [`before_update(self, to, token_id)`](#ERC721EnumerableComponent-before_update)
- [`all_tokens_of_owner(self, owner)`](#ERC721EnumerableComponent-all_tokens_of_owner)
- [`_add_token_to_owner_enumeration(self, to, token_id)`](#ERC721EnumerableComponent-_add_token_to_owner_enumeration)
- [`_add_token_to_all_tokens_enumeration(self, token_id)`](#ERC721EnumerableComponent-_add_token_to_all_tokens_enumeration)
- [`_remove_token_from_owner_enumeration(self, from, token_id)`](#ERC721EnumerableComponent-_remove_token_from_owner_enumeration)
- [`_remove_token_from_all_tokens_enumeration(self, token_id)`](#ERC721EnumerableComponent-_remove_token_from_all_tokens_enumeration)

#### [](#ERC721EnumerableComponent-Embeddable-functions)Embeddable functions

#### [](#ERC721EnumerableComponent-total_supply)`total_supply(self: @ContractState) → u256` external

Returns the current amount of votes that `account` has.

#### [](#ERC721EnumerableComponent-token_by_index)`token_by_index(self: @ContractState, index: u256) → u256` external

See [IERC721Enumerable::token\_by\_index](#IERC721Enumerable-token_by_index).

Requirements:

- `index` is less than the total token supply.

#### [](#ERC721EnumerableComponent-token_of_owner_by_index)`token_of_owner_by_index(self: @ContractState, owner: ContractAddress, index: u256) → u256` external

See [IERC721Enumerable::token\_of\_owner\_by\_index](#IERC721Enumerable-token_of_owner_by_index).

Requirements:

- `index` is less than `owner`'s token balance.
- `owner` is not the zero address.

#### [](#ERC721EnumerableComponent-Internal-functions)Internal functions

#### [](#ERC721EnumerableComponent-initializer)`initializer(ref self: ContractState)` internal

Registers the `IERC721Enumerable` interface ID as supported through introspection.

#### [](#ERC721EnumerableComponent-before_update)`before_update(ref self: ContractState, to: ContractAddress, token_id: u256)` internal

Updates the ownership and token-tracking data structures.

When a token is minted (or burned), `token_id` is added to (or removed from) the token-tracking structures.

When a token is transferred, minted, or burned, the ownership-tracking data structures reflect the change in ownership of `token_id`.

This must be added to the implementing contract’s [ERC721HooksTrait::before\_update](#ERC721Component-before_update) hook.

#### [](#ERC721EnumerableComponent-all_tokens_of_owner)`all_tokens_of_owner(self: @ContractState, owner: ContractAddress) → Span<u256>` internal

Returns a list of all token ids owned by the specified `owner`. This function provides a more efficient alternative to calling `ERC721::balance_of` and iterating through tokens with `ERC721Enumerable::token_of_owner_by_index`.

Requirements:

- `owner` is not the zero address.

#### [](#ERC721EnumerableComponent-_add_token_to_owner_enumeration)`_add_token_to_owner_enumeration(ref self: ContractState, to: ContractAddress, token_id: u256)` internal

Adds token to this extension’s ownership-tracking data structures.

#### [](#ERC721EnumerableComponent-_add_token_to_all_tokens_enumeration)`_add_token_to_all_tokens_enumeration(ref self: ContractState, token_id: u256)` internal

Adds token to this extension’s token-tracking data structures.

#### [](#ERC721EnumerableComponent-_remove_token_from_owner_enumeration)`_remove_token_from_owner_enumeration(ref self: ContractState, from: ContractAddress, token_id: u256)` internal

Removes a token from this extension’s ownership-tracking data structures.

This has 0(1) time complexity but alters the indexed order of owned tokens by swapping `token_id` and the index thereof with the last token id and the index thereof e.g. removing `1` from `[1, 2, 3, 4]` results in `[4, 2, 3]`.

#### [](#ERC721EnumerableComponent-_remove_token_from_all_tokens_enumeration)`_remove_token_from_all_tokens_enumeration(ref self: ContractState, token_id: u256)` internal

Removes `token_id` from this extension’s token-tracking data structures.

This has 0(1) time complexity but alters the indexed order by swapping `token_id` and the index thereof with the last token id and the index thereof e.g. removing `1` from `[1, 2, 3, 4]` results in `[4, 2, 3]`.

## [](#presets)Presets

### [](#ERC721Upgradeable)`ERC721Upgradeable`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/presets/src/erc721.cairo)

```cairo
use openzeppelin_presets::ERC721Upgradeable;
```

Upgradeable ERC721 contract leveraging [ERC721Component](#ERC721Component).

[Sierra class hash](../presets)

0x04080084ac1ba5a26b4638ac7ca2ff009a9a9b86bf6db5df05e96c90aa143df5

Constructor

- [`constructor(self, name, symbol, recipient, token_ids, base_uri, owner)`](#ERC721Upgradeable-constructor)

Embedded Implementations

ERC721MixinImpl

- [`ERC721MixinImpl`](#ERC721Component-Embeddable-Mixin-Impl)

OwnableMixinImpl

- [`OwnableMixinImpl`](access#OwnableComponent-Mixin-Impl)

External Functions

- [`upgrade(self, new_class_hash)`](#ERC721Upgradeable-upgrade)

#### [](#ERC721Upgradeable-constructor-section)Constructor

#### [](#ERC721Upgradeable-constructor)`constructor(ref self: ContractState, name: ByteArray, symbol: ByteArray, recipient: ContractAddress, token_ids: Span<u256>, base_uri: ByteArray, owner: ContractAddress)` constructor

Sets the `name` and `symbol`. Mints `token_ids` tokens to `recipient` and sets the `base_uri`. Assigns `owner` as the contract owner with permissions to upgrade.

#### [](#ERC721Upgradeable-external-functions)External functions

#### [](#ERC721Upgradeable-upgrade)`upgrade(ref self: ContractState, new_class_hash: ClassHash)` external

Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

- The caller is the contract owner.
- `new_class_hash` cannot be zero.
