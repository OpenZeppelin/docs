---
title: Governance
---

This crate includes primitives for on-chain governance.

## [](#interfaces)Interfaces

Starting from version `3.x.x`, the interfaces are no longer part of the `openzeppelin_governance` package. The references documented here are contained in the `openzeppelin_interfaces` package version `v2.1.0`.

### [](#IGovernor)`IGovernor`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/interfaces/src/governance/governor.cairo)

```cairo
use openzeppelin_interfaces::governor::IGovernor;
```

Interface of a governor contract.

[SRC5 ID](introspection#ISRC5)

0x1100a1f8546595b5bd75a6cd8fcc5b015370655e66f275963321c5cd0357ac9

Functions

- [`name()`](#IGovernor-name)
- [`version()`](#IGovernor-version)
- [`COUNTING_MODE()`](#IGovernor-COUNTING_MODE)
- [`hash_proposal(calls, description_hash)`](#IGovernor-hash_proposal)
- [`state(proposal_id)`](#IGovernor-state)
- [`proposal_threshold()`](#IGovernor-proposal_threshold)
- [`proposal_snapshot(proposal_id)`](#IGovernor-proposal_snapshot)
- [`proposal_deadline(proposal_id)`](#IGovernor-proposal_deadline)
- [`proposal_proposer(proposal_id)`](#IGovernor-proposal_proposer)
- [`proposal_eta(proposal_id)`](#IGovernor-proposal_eta)
- [`proposal_needs_queuing(proposal_id)`](#IGovernor-proposal_needs_queuing)
- [`voting_delay()`](#IGovernor-voting_delay)
- [`voting_period()`](#IGovernor-voting_period)
- [`quorum(timepoint)`](#IGovernor-quorum)
- [`get_votes(account, timepoint)`](#IGovernor-get_votes)
- [`get_votes_with_params(account, timepoint, params)`](#IGovernor-get_votes_with_params)
- [`has_voted(proposal_id, account)`](#IGovernor-has_voted)
- [`propose(calls, description)`](#IGovernor-propose)
- [`queue(calls, description_hash)`](#IGovernor-queue)
- [`execute(calls, description_hash)`](#IGovernor-execute)
- [`cancel(proposal_id, description_hash)`](#IGovernor-cancel)
- [`cast_vote(proposal_id, support)`](#IGovernor-cast_vote)
- [`cast_vote_with_reason(proposal_id, support, reason)`](#IGovernor-cast_vote_with_reason)
- [`cast_vote_with_reason_and_params(proposal_id, support, reason, params)`](#IGovernor-cast_vote_with_reason_and_params)
- [`cast_vote_by_sig(proposal_id, support, reason, signature)`](#IGovernor-cast_vote_by_sig)
- [`cast_vote_with_reason_and_params_by_sig(proposal_id, support, reason, params, signature)`](#IGovernor-cast_vote_with_reason_and_params_by_sig)
- [`nonces(voter)`](#IGovernor-nonces)
- [`relay(call)`](#IGovernor-relay)

Events

- [`ProposalCreated(proposal_id, proposer, calls, signatures, vote_start, vote_end, description)`](#IGovernor-ProposalCreated)
- [`ProposalQueued(proposal_id, eta_seconds)`](#IGovernor-ProposalQueued)
- [`ProposalExecuted(proposal_id)`](#IGovernor-ProposalExecuted)
- [`ProposalCanceled(proposal_id)`](#IGovernor-ProposalCanceled)
- [`VoteCast(voter, proposal_id, support, weight, reason)`](#IGovernor-VoteCast)
- [`VoteCastWithParams(voter, proposal_id, support, weight, reason, params)`](#IGovernor-VoteCastWithParams)

#### [](#IGovernor-Functions)Functions

#### [](#IGovernor-name)`name() → felt252` external

Name of the governor instance (used in building the [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) domain separator).

#### [](#IGovernor-version)`version() → felt252` external

Version of the governor instance (used in building [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) domain separator).

#### [](#IGovernor-COUNTING_MODE)`COUNTING_MODE() → ByteArray` external

A description of the possible `support` values for `cast_vote` and the way these votes are counted, meant to be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.

There are 2 standard keys: `support` and `quorum`.

- `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.
- `quorum=bravo` means that only For votes are counted towards quorum.
- `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.

If a counting module makes use of encoded `params`, it should include this under a `params` key with a unique name that describes the behavior. For example:

- `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.
- `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.

The string can be decoded by the standard [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) JavaScript class.

#### [](#IGovernor-hash_proposal)`hash_proposal(calls: Span<Call>, description_hash: felt252) → felt252` external

Hashing function used to (re)build the proposal id from the proposal details.

#### [](#IGovernor-state)`state(proposal_id: felt252) → ProposalState` external

Returns the state of a proposal, given its id.

#### [](#IGovernor-proposal_threshold)`proposal_threshold() → u256` external

The number of votes required in order for a voter to become a proposer.

#### [](#IGovernor-proposal_snapshot)`proposal_snapshot(proposal_id: felt252) → u64` external

Timepoint used to retrieve user’s votes and quorum. If using block number, the snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the following block.

#### [](#IGovernor-proposal_deadline)`proposal_deadline(proposal_id: felt252) → u64` external

Timepoint at which votes close. If using block number, votes close at the end of this block, so it is possible to cast a vote during this block.

#### [](#IGovernor-proposal_proposer)`proposal_proposer(proposal_id: felt252) → ContractAddress` external

The account that created a proposal.

#### [](#IGovernor-proposal_eta)`proposal_eta(proposal_id: felt252) → u64` external

The time when a queued proposal becomes executable ("ETA"). Unlike `proposal_snapshot` and `proposal_deadline`, this doesn’t use the governor clock, and instead relies on the executor’s clock which may be different. In most cases this will be a timestamp.

#### [](#IGovernor-proposal_needs_queuing)`proposal_needs_queuing(proposal_id: felt252) → bool` external

Whether a proposal needs to be queued before execution. This indicates if the proposal needs to go through a timelock.

#### [](#IGovernor-voting_delay)`voting_delay() → u64` external

Delay between when a proposal is created and when the vote starts. The unit this duration is expressed in depends on the clock (see [ERC-6372](https://eips.ethereum.org/EIPS/eip-6372)) this contract uses.

This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a proposal starts.

#### [](#IGovernor-voting_period)`voting_period() → u64` external

Delay between when a vote starts and when it ends. The unit this duration is expressed in depends on the clock (see [ERC-6372](https://eips.ethereum.org/EIPS/eip-6372)) this contract uses.

The `voting_delay` can delay the start of the vote. This must be considered when setting the voting duration compared to the voting delay.

This value is stored when the proposal is submitted so that possible changes to the value do not affect proposals that have already been submitted.

#### [](#IGovernor-quorum)`quorum(timepoint: u64) → u256` external

Minimum number of votes required for a proposal to be successful.

The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows the quorum to scale depending on values such as the total supply of a token at this timepoint.

#### [](#IGovernor-get_votes)`get_votes(account: ContractAddress, timepoint: u64) → u256` external

Returns the voting power of an `account` at a specific `timepoint`.

This can be implemented in a number of ways, for example by reading the delegated balance from one (or multiple) `ERC20Votes` tokens.

#### [](#IGovernor-get_votes_with_params)`get_votes_with_params(account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` external

Returns the voting power of an `account` at a specific `timepoint`, given additional encoded parameters.

#### [](#IGovernor-has_voted)`has_voted(proposal_id: felt252, account: ContractAddress) → bool` external

Returns whether an `account` has cast a vote on a proposal.

#### [](#IGovernor-propose)`propose(calls: Span<Call>, description: ByteArray) → felt252` external

Creates a new proposal. Vote starts after a delay specified by `voting_delay` and lasts for a duration specified by `voting_period`.

The state of the Governor and targets may change between the proposal creation and its execution. This may be the result of third party actions on the targeted contracts, or other governor proposals. For example, the balance of this contract could be updated or its access control permissions may be modified, possibly compromising the proposal’s ability to execute successfully (e.g. the governor doesn’t have enough value to cover a proposal with multiple transfers).

Returns the id of the proposal.

#### [](#IGovernor-queue)`queue(calls: Span<Call>, description_hash: felt252) → felt252` external

Queue a proposal. Some governors require this step to be performed before execution can happen. If queuing is not necessary, this function may revert.

Queuing a proposal requires the quorum to be reached, the vote to be successful, and the deadline to be reached.

Returns the id of the proposal.

#### [](#IGovernor-execute)`execute(calls: span<Call>, description_hash: felt252) → felt252` external

Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the deadline to be reached. Depending on the governor it might also be required that the proposal was queued and that some delay passed.

Some modules can modify the requirements for execution, for example by adding an additional timelock (See `timelock_controller`).

Returns the id of the proposal.

#### [](#IGovernor-cancel)`cancel(calls: Span<Call>, description_hash: felt252) → felt252` external

Cancel a proposal. A proposal is cancellable by the proposer, but only while it is Pending state, i.e. before the vote starts.

Returns the id of the proposal.

#### [](#IGovernor-cast_vote)`cast_vote(proposal_id: felt252, support: u8) → u256` external

Cast a vote on a proposal.

Returns the weight of the vote.

#### [](#IGovernor-cast_vote_with_reason)`cast_vote_with_reason(proposal_id: felt252, support: u8, reason: ByteArray) → u256` external

Cast a vote on a proposal with a `reason`.

Returns the weight of the vote.

#### [](#IGovernor-cast_vote_with_reason_and_params)`cast_vote_with_reason_and_params(proposal_id: felt252, support: u8, reason: ByteArray, params: Span<felt252>) → u256` external

Cast a vote on a proposal with a reason and additional encoded parameters.

Returns the weight of the vote.

#### [](#IGovernor-cast_vote_by_sig)`cast_vote_by_sig(proposal_id: felt252, support: u8, voter: ContractAddress, signature: Span<felt252>) → u256` external

Cast a vote on a proposal using the voter’s signature.

Returns the weight of the vote.

#### [](#IGovernor-cast_vote_with_reason_and_params_by_sig)`cast_vote_with_reason_and_params_by_sig(proposal_id: felt252, support: u8, voter: ContractAddress, reason: ByteArray, params: Span<felt252>, signature: Span<felt252>) → u256` external

Cast a vote on a proposal with a reason and additional encoded parameters using the `voter`'s signature.

Returns the weight of the vote.

#### [](#IGovernor-nonces)`nonces(voter: ContractAddress) → felt252` external

Returns the next unused nonce for an address.

#### [](#IGovernor-relay)`relay(call: Call)` external

Relays a transaction or function call to an arbitrary target.

In cases where the governance executor is some contract other than the governor itself, like when using a timelock, this function can be invoked in a governance proposal to recover tokens that were sent to the governor contract by mistake.

If the executor is simply the governor itself, use of `relay` is redundant.

#### [](#IGovernor-Events)Events

#### [](#IGovernor-ProposalCreated)`ProposalCreated(proposal_id: felt252, proposer: ContractAddress, calls: Span<Call>, signatures: Span<Span<felt252>>, vote_start: u64, vote_end: u64, description: ByteArray)` event

Emitted when a proposal is created.

#### [](#IGovernor-ProposalQueued)`ProposalQueued(proposal_id: felt252, eta_seconds: u64)` event

Emitted when a proposal is queued.

#### [](#IGovernor-ProposalExecuted)`ProposalExecuted(proposal_id: felt252)` event

Emitted when a proposal is executed.

#### [](#IGovernor-ProposalCanceled)`ProposalCanceled(proposal_id: felt252)` event

Emitted when a proposal is canceled.

#### [](#IGovernor-VoteCast)`VoteCast(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray)` event

Emitted when a vote is cast.

#### [](#IGovernor-VoteCastWithParams)`VoteCastWithParams(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray, params: Span<felt252>)` event

Emitted when a vote is cast with params.

### [](#IMultisig)`IMultisig`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/interfaces/src/governance/multisig.cairo)

```cairo
use openzeppelin_interfaces::multisig::IMultisig;
```

Interface of a multisig contract.

Functions

- [`get_quorum()`](#IMultisig-get_quorum)
- [`is_signer(signer)`](#IMultisig-is_signer)
- [`get_signers()`](#IMultisig-get_signers)
- [`is_confirmed(id)`](#IMultisig-is_confirmed)
- [`is_confirmed_by(id, signer)`](#IMultisig-is_confirmed_by)
- [`is_executed(id)`](#IMultisig-is_executed)
- [`get_submitted_block(id)`](#IMultisig-get_submitted_block)
- [`get_transaction_state(id)`](#IMultisig-get_transaction_state)
- [`get_transaction_confirmations(id)`](#IMultisig-get_transaction_confirmations)
- [`hash_transaction(to, selector, calldata, salt)`](#IMultisig-hash_transaction)
- [`hash_transaction_batch(calls, salt)`](#IMultisig-hash_transaction_batch)
- [`add_signers(new_quorum, signers_to_add)`](#IMultisig-add_signers)
- [`remove_signers(new_quorum, signers_to_remove)`](#IMultisig-remove_signers)
- [`replace_signer(signer_to_remove, signer_to_add)`](#IMultisig-replace_signer)
- [`change_quorum(new_quorum)`](#IMultisig-change_quorum)
- [`submit_transaction(to, selector, calldata, salt)`](#IMultisig-submit_transaction)
- [`submit_transaction_batch(calls, salt)`](#IMultisig-submit_transaction_batch)
- [`confirm_transaction(id)`](#IMultisig-confirm_transaction)
- [`revoke_confirmation(id)`](#IMultisig-revoke_confirmation)
- [`execute_transaction(to, selector, calldata, salt)`](#IMultisig-execute_transaction)
- [`execute_transaction_batch(calls, salt)`](#IMultisig-execute_transaction_batch)

Events

- [`SignerAdded(signer)`](#IMultisig-SignerAdded)
- [`SignerRemoved(signer)`](#IMultisig-SignerRemoved)
- [`QuorumUpdated(old_quorum, new_quorum)`](#IMultisig-QuorumUpdated)
- [`TransactionSubmitted(id, signer)`](#IMultisig-TransactionSubmitted)
- [`TransactionConfirmed(id, signer)`](#IMultisig-TransactionConfirmed)
- [`ConfirmationRevoked(id, signer)`](#IMultisig-ConfirmationRevoked)
- [`TransactionExecuted(id)`](#IMultisig-TransactionExecuted)
- [`CallSalt(id, salt)`](#IMultisig-CallSalt)

#### [](#IMultisig-Functions)Functions

#### [](#IMultisig-get_quorum)`get_quorum() → u32` external

Returns the current quorum value. The quorum is the minimum number of confirmations required to approve a transaction.

#### [](#IMultisig-is_signer)`is_signer(signer: ContractAddress) → bool` external

Returns whether the given `signer` is registered. Only registered signers can submit, confirm, or execute transactions.

#### [](#IMultisig-get_signers)`get_signers() → Span<ContractAddress>` external

Returns the list of all current signers.

#### [](#IMultisig-is_confirmed)`is_confirmed(id: TransactionID) → bool` external

Returns whether the transaction with the given `id` has been confirmed.

#### [](#IMultisig-is_confirmed_by)`is_confirmed_by(id: TransactionID, signer: ContractAddress) → bool` external

Returns whether the transaction with the given `id` has been confirmed by the specified `signer`.

#### [](#IMultisig-is_executed)`is_executed(id: TransactionID) → bool` external

Returns whether the transaction with the given `id` has been executed.

#### [](#IMultisig-get_submitted_block)`get_submitted_block(id: TransactionID) → u64` external

Returns the block number when the transaction with the given `id` was submitted.

#### [](#IMultisig-get_transaction_state)`get_transaction_state(id: TransactionID) → TransactionState` external

Returns the current state of the transaction with the given `id`.

#### [](#IMultisig-get_transaction_confirmations)`get_transaction_confirmations(id: TransactionID) → u32` external

Returns the number of confirmations from registered signers for the transaction with the specified `id`.

#### [](#IMultisig-hash_transaction)`hash_transaction(to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252) → TransactionID` external

Returns the computed identifier of a transaction containing a single call.

#### [](#IMultisig-hash_transaction_batch)`hash_transaction_batch(calls: Span<Call>, salt: felt252) → TransactionID` external

Returns the computed identifier of a transaction containing a batch of calls.

#### [](#IMultisig-add_signers)`add_signers(new_quorum: u32, signers_to_add: Span<ContractAddress>)` external

Adds new signers and updates the quorum.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be less than or equal to the total number of signers after addition.

Emits a [SignerAdded](#IMultisig-SignerAdded) event for each signer added.

Emits a [QuorumUpdated](#IMultisig-QuorumUpdated) event if the quorum changes.

#### [](#IMultisig-remove_signers)`remove_signers(new_quorum: u32, signers_to_remove: Span<ContractAddress>)` external

Removes signers and updates the quorum.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be less than or equal to the total number of signers after removal.

Emits a [SignerRemoved](#IMultisig-SignerRemoved) event for each signer removed.

Emits a [QuorumUpdated](#IMultisig-QuorumUpdated) event if the quorum changes.

#### [](#IMultisig-replace_signer)`replace_signer(signer_to_remove: ContractAddress, signer_to_add: ContractAddress)` external

Replaces an existing signer with a new signer.

Requirements:

- The caller must be the contract itself.
- `signer_to_remove` must be an existing signer.
- `signer_to_add` must not be an existing signer.

Emits a [SignerRemoved](#IMultisig-SignerRemoved) event for the removed signer.

Emits a [SignerAdded](#IMultisig-SignerAdded) event for the new signer.

#### [](#IMultisig-change_quorum)`change_quorum(new_quorum: u32)` external

Updates the quorum value to `new_quorum` if it differs from the current quorum.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be non-zero.
- `new_quorum` must be less than or equal to the total number of signers.

Emits a [QuorumUpdated](#IMultisig-QuorumUpdated) event if the quorum changes.

#### [](#IMultisig-submit_transaction)`submit_transaction(to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252) → TransactionID` external

Submits a new transaction for confirmation.

Requirements:

- The caller must be a registered signer.
- The transaction must not have been submitted before.

Emits a [TransactionSubmitted](#IMultisig-TransactionSubmitted) event.

Emits a [CallSalt](#IMultisig-CallSalt) event if `salt` is not zero.

#### [](#IMultisig-submit_transaction_batch)`submit_transaction_batch(calls: Span<Call>, salt: felt252) → TransactionID` external

Submits a new batch transaction for confirmation.

Requirements:

- The caller must be a registered signer.
- The transaction must not have been submitted before.

Emits a [TransactionSubmitted](#IMultisig-TransactionSubmitted) event.

Emits a [CallSalt](#IMultisig-CallSalt) event if `salt` is not zero.

#### [](#IMultisig-confirm_transaction)`confirm_transaction(id: TransactionID)` external

Confirms a transaction with the given `id`.

Requirements:

- The caller must be a registered signer.
- The transaction must exist and not be executed.
- The caller must not have already confirmed the transaction.

Emits a [TransactionConfirmed](#IMultisig-TransactionConfirmed) event.

#### [](#IMultisig-revoke_confirmation)`revoke_confirmation(id: TransactionID)` external

Revokes a previous confirmation for a transaction with the given `id`.

Requirements:

- The transaction must exist and not be executed.
- The caller must have previously confirmed the transaction.

Emits a [ConfirmationRevoked](#IMultisig-ConfirmationRevoked) event.

#### [](#IMultisig-execute_transaction)`execute_transaction(to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)` external

Executes a confirmed transaction.

Requirements:

- The caller must be a registered signer.
- The transaction must be confirmed and not yet executed.

Emits a [TransactionExecuted](#IMultisig-TransactionExecuted) event.

#### [](#IMultisig-execute_transaction_batch)`execute_transaction_batch(calls: Span<Call>, salt: felt252)` external

Executes a confirmed batch transaction.

Requirements:

- The caller must be a registered signer.
- The transaction must be confirmed and not yet executed.

Emits a [TransactionExecuted](#IMultisig-TransactionExecuted) event.

#### [](#IMultisig-Events)Events

#### [](#IMultisig-SignerAdded)`SignerAdded(signer: ContractAddress)` event

Emitted when a new `signer` is added.

#### [](#IMultisig-SignerRemoved)`SignerRemoved(signer: ContractAddress)` event

Emitted when a `signer` is removed.

#### [](#IMultisig-QuorumUpdated)`QuorumUpdated(old_quorum: u32, new_quorum: u32)` event

Emitted when the `quorum` value is updated.

#### [](#IMultisig-TransactionSubmitted)`TransactionSubmitted(id: TransactionID, signer: ContractAddress)` event

Emitted when a new transaction is submitted by a `signer`.

#### [](#IMultisig-TransactionConfirmed)`TransactionConfirmed(id: TransactionID, signer: ContractAddress)` event

Emitted when a transaction is confirmed by a `signer`.

#### [](#IMultisig-ConfirmationRevoked)`ConfirmationRevoked(id: TransactionID, signer: ContractAddress)` event

Emitted when a `signer` revokes his confirmation.

#### [](#IMultisig-TransactionExecuted)`TransactionExecuted(id: TransactionID)` event

Emitted when a transaction is executed.

#### [](#IMultisig-CallSalt)`CallSalt(id: felt252, salt: felt252)` event

Emitted when a new transaction is submitted with non-zero salt.

### [](#ITimelock)`ITimelock`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/interfaces/src/governance/timelock.cairo)

```cairo
use openzeppelin_interfaces::timelock::ITimelock;
```

Interface of a timelock contract.

Functions

- [`is_operation(id)`](#ITimelock-is_operation)
- [`is_operation_pending(id)`](#ITimelock-is_operation_pending)
- [`is_operation_ready(id)`](#ITimelock-is_operation_ready)
- [`is_operation_done(id)`](#ITimelock-is_operation_done)
- [`get_timestamp(id)`](#ITimelock-get_timestamp)
- [`get_operation_state(id)`](#ITimelock-get_operation_state)
- [`get_min_delay()`](#ITimelock-get_min_delay)
- [`hash_operation(call, predecessor, salt)`](#ITimelock-hash_operation)
- [`hash_operation_batch(calls, predecessor, salt)`](#ITimelock-hash_operation_batch)
- [`schedule(call, predecessor, salt, delay)`](#ITimelock-schedule)
- [`schedule_batch(calls, predecessor, salt, delay)`](#ITimelock-schedule_batch)
- [`cancel(id)`](#ITimelock-cancel)
- [`execute(call, predecessor, salt)`](#ITimelock-execute)
- [`execute_batch(calls, predecessor, salt)`](#ITimelock-execute_batch)
- [`update_delay(new_delay)`](#ITimelock-update_delay)

Events

- [`CallScheduled(id, index, call, predecessor, delay)`](#ITimelock-CallScheduled)
- [`CallExecuted(id, index, call)`](#ITimelock-CallExecuted)
- [`CallSalt(id, salt)`](#ITimelock-CallSalt)
- [`CallCancelled(id)`](#ITimelock-CallCancelled)
- [`MinDelayChanged(old_duration, new_duration)`](#ITimelock-MinDelayChanged)

#### [](#ITimelock-Functions)Functions

#### [](#ITimelock-is_operation)`is_operation(id: felt252) → bool` external

Returns whether `id` corresponds to a registered operation. This includes the OperationStates: `Waiting`, `Ready`, and `Done`.

#### [](#ITimelock-is_operation_pending)`is_operation_pending(id: felt252) → bool` external

Returns whether the `id` OperationState is pending or not. Note that a pending operation may be either `Waiting` or `Ready`.

#### [](#ITimelock-is_operation_ready)`is_operation_ready(id: felt252) → bool` external

Returns whether the `id` OperationState is `Ready` or not.

#### [](#ITimelock-is_operation_done)`is_operation_done(id: felt252) → bool` external

Returns whether the `id` OperationState is `Done` or not.

#### [](#ITimelock-get_timestamp)`get_timestamp(id: felt252) → u64` external

Returns the timestamp at which `id` becomes `Ready`.

`0` means the OperationState is `Unset` and `1` means the OperationState is `Done`.

#### [](#ITimelock-get_operation_state)`get_operation_state(id: felt252) → OperationState` external

Returns the current state of the operation with the given `id`.

The possible states are:

- `Unset`: the operation has not been scheduled or has been canceled.
- `Waiting`: the operation has been scheduled and is pending the scheduled delay.
- `Ready`: the timer has expired, and the operation is eligible for execution.
- `Done`: the operation has been executed.

#### [](#ITimelock-get_min_delay)`get_min_delay() → u64` external

Returns the minimum delay in seconds for an operation to become valid. This value can be changed by executing an operation that calls `update_delay`.

#### [](#ITimelock-hash_operation)`hash_operation(call: Call, predecessor: felt252, salt: felt252)` external

Returns the identifier of an operation containing a single transaction.

#### [](#ITimelock-hash_operation_batch)`hash_operation_batch(calls: Span<Call>, predecessor: felt252, salt: felt252)` external

Returns the identifier of an operation containing a batch of transactions.

#### [](#ITimelock-schedule)`schedule(call: Call, predecessor: felt252, salt: felt252, delay: u64)` external

Schedule an operation containing a single transaction.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.

Emits [CallScheduled](#ITimelock-CallScheduled) event. Emits [CallSalt](#ITimelock-CallSalt) event if `salt` is not zero.

#### [](#ITimelock-schedule_batch)`schedule_batch(calls: Span<Call>, predecessor: felt252, salt: felt252, delay: u64)` external

Schedule an operation containing a batch of transactions.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.

Emits one [CallScheduled](#ITimelock-CallScheduled) event for each transaction in the batch. Emits [CallSalt](#ITimelock-CallSalt) event if `salt` is not zero.

#### [](#ITimelock-cancel)`cancel(id: felt252)` external

Cancels an operation. A canceled operation returns to `Unset` OperationState.

Requirements:

- The caller must have the `CANCELLER_ROLE` role.
- `id` must be a pending operation.

Emits a [CallCancelled](#ITimelock-CallCancelled) event.

#### [](#ITimelock-execute)`execute(call: Call, predecessor: felt252, salt: felt252)` external

Execute a (Ready) operation containing a single Call.

Requirements:

- Caller must have `EXECUTOR_ROLE`.
- `id` must be in Ready OperationState.
- `predecessor` must either be `0` or in Done OperationState.

Emits a [CallExecuted](#ITimelock-CallExecuted) event.

This function can reenter, but it doesn’t pose a risk because [`_after_call(self: @ContractState, id: felt252)` internal](#TimelockControllerComponent-_after_call) checks that the proposal is pending, thus any modifications to the operation during reentrancy should be caught.

#### [](#ITimelock-execute_batch)`execute_batch(calls: Span<Call>, predecessor: felt252, salt: felt252)` external

Execute a (Ready) operation containing a batch of Calls.

Requirements:

- Caller must have `EXECUTOR_ROLE`.
- `id` must be in Ready OperationState.
- `predecessor` must either be `0` or in Done OperationState.

Emits a [CallExecuted](#ITimelock-CallExecuted) event for each Call.

This function can reenter, but it doesn’t pose a risk because `_after_call` checks that the proposal is pending, thus any modifications to the operation during reentrancy should be caught.

#### [](#ITimelock-update_delay)`update_delay(new_delay: u64)` external

Changes the minimum timelock duration for future operations.

Requirements:

- The caller must be the timelock itself. This can only be achieved by scheduling and later executing an operation where the timelock is the target and the data is the serialized call to this function.

Emits a [MinDelayChanged](#ITimelock-MinDelayChanged) event.

#### [](#ITimelock-Events)Events

#### [](#ITimelock-CallScheduled)`CallScheduled(id: felt252, index: felt252, call: Call, predecessor: felt252, delay: u64)` event

Emitted when `call` is scheduled as part of operation `id`.

#### [](#ITimelock-CallExecuted)`CallExecuted(id: felt252, index: felt252, call: Call)` event

Emitted when `call` is performed as part of operation `id`.

#### [](#ITimelock-CallSalt)`CallSalt(id: felt252, salt: felt252)` event

Emitted when a new proposal is scheduled with non-zero salt.

#### [](#ITimelock-CallCancelled)`CallCancelled(id: felt252)` event

Emitted when operation `id` is cancelled.

#### [](#ITimelock-MinDelayChanged)`MinDelayChanged(old_duration: u64, new_duration: u64)` event

Emitted when the minimum delay for future operations is modified.

### [](#IVotes)`IVotes`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/interfaces/src/governance/votes.cairo)

```cairo
use openzeppelin_interfaces::votes::IVotes;
```

Common interface for Votes-enabled contracts.

Functions

- [`get_votes(account)`](#IVotes-get_votes)
- [`get_past_votes(account, timepoint)`](#IVotes-get_past_votes)
- [`get_past_total_supply(timepoint)`](#IVotes-get_past_total_supply)
- [`delegates(account)`](#IVotes-delegates)
- [`delegate(delegatee)`](#IVotes-delegate)
- [`delegate_by_sig(delegator, delegatee, nonce, expiry, signature)`](#IVotes-delegate_by_sig)
- [`clock()`](#IVotes-clock)
- [`CLOCK_MODE()`](#IVotes-CLOCK_MODE)

#### [](#IVotes-Functions)Functions

#### [](#IVotes-get_votes)`get_votes(account: ContractAddress) → u256` external

Returns the current amount of votes that `account` has.

#### [](#IVotes-get_past_votes)`get_past_votes(account: ContractAddress, timepoint: u64) → u256` external

Returns the amount of votes that `account` had at a specific moment in the past.

#### [](#IVotes-get_past_total_supply)`get_past_total_supply(timepoint: u64) → u256` external

Returns the total supply of votes available at a specific moment in the past.

This value is the sum of all available votes, which is not necessarily the sum of all delegated votes. Votes that have not been delegated are still part of total supply, even though they would not participate in a vote.

#### [](#IVotes-delegates)`delegates(account: ContractAddress) → ContractAddress` external

Returns the delegate that `account` has chosen.

#### [](#IVotes-delegate)`delegate(delegatee: ContractAddress)` external

Delegates votes from the sender to `delegatee`.

#### [](#IVotes-delegate_by_sig)`delegate_by_sig(delegator: ContractAddress, delegatee: ContractAddress, nonce: felt252, expiry: u64, signature: Span<felt252>)` external

Delegates votes from `delegator` to `delegatee` through a [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) message signature validation.

#### [](#IVotes-clock)`clock() → u64` external

Returns the current timepoint determined by the contract’s operational mode, intended for use in time-sensitive logic. See [ERC-6372#clock](https://eips.ethereum.org/EIPS/eip-6372#clock).

Requirements:

- This function MUST always be non-decreasing.

#### [](#IVotes-CLOCK_MODE)`CLOCK_MODE() → u64` external

Returns a description of the clock the contract is operating in. See [ERC-6372#CLOCK\_MODE](https://eips.ethereum.org/EIPS/eip-6372#clock_mode).

Requirements:

- The output MUST be formatted like a URL query string, decodable in standard JavaScript.

## [](#governor)Governor

This modular system of Governor components allows the deployment of easily customizable on-chain voting protocols.

For a walkthrough of how to implement a Governor, check the [Governor](../governance/governor) page.

### [](#GovernorComponent)`GovernorComponent`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/governance/src/governor/governor.cairo)

```cairo
use openzeppelin_governance::governor::GovernorComponent;
```

Core of the governance system.

The extension traits presented below are what make the GovernorComponent a modular and configurable system. The embeddable and internal implementations depends on these trait. They can be implemented locally in the contract, or through the provided library [component extensions](#governor_extensions).

Implementing [SRC5Component](introspection#SRC5Component) is a requirement for this component to be implemented.

Extensions traits

GovernorSettingsTrait

- [`voting_delay(self)`](#GovernorComponent-GovernorSettingsTrait-voting_delay)
- [`voting_period(self)`](#GovernorComponent-GovernorSettingsTrait-voting_period)
- [`proposal_threshold(self)`](#GovernorComponent-GovernorSettingsTrait-proposal_threshold)

GovernorQuorumTrait

- [`quorum(self, timepoint)`](#GovernorComponent-GovernorQuorumTrait-quorum)

GovernorCountingTrait

- [`counting_mode(self)`](#GovernorComponent-GovernorCountingTrait-counting_mode)
- [`count_vote(self, proposal_id, account, support, total_weight, params)`](#GovernorComponent-GovernorCountingTrait-count_vote)
- [`has_voted(self, proposal_id, account)`](#GovernorComponent-GovernorCountingTrait-has_voted)
- [`quorum_reached(self, proposal_id)`](#GovernorComponent-GovernorCountingTrait-quorum_reached)
- [`vote_succeeded(self, proposal_id)`](#GovernorComponent-GovernorCountingTrait-vote_succeeded)

GovernorVotesTrait

- [`clock(self)`](#GovernorComponent-GovernorVotesTrait-clock)
- [`CLOCK_MODE(self)`](#GovernorComponent-GovernorVotesTrait-CLOCK_MODE)
- [`get_votes(self, account, timepoint, params)`](#GovernorComponent-GovernorVotesTrait-get_votes)

GovernorExecutionTrait

- [`state(self, proposal_id)`](#GovernorComponent-GovernorExecutionTrait-state)
- [`executor(self)`](#GovernorComponent-GovernorExecutionTrait-executor)
- [`execute_operations(self, proposal_id, calls, description_hash)`](#GovernorComponent-GovernorExecutionTrait-execute_operations)
- [`queue_operations(self, proposal_id, calls, description_hash)`](#GovernorComponent-GovernorExecutionTrait-queue_operations)
- [`proposal_needs_queuing(self, proposal_id)`](#GovernorComponent-GovernorExecutionTrait-proposal_needs_queuing)
- [`cancel_operations(self, proposal_id, description_hash)`](#GovernorComponent-GovernorExecutionTrait-cancel_operations)

Embeddable Implementations

GovernorImpl

- [`name(self)`](#GovernorComponent-name)
- [`version(self)`](#GovernorComponent-version)
- [`COUNTING_MODE(self)`](#GovernorComponent-COUNTING_MODE)
- [`hash_proposal(self, calls, description_hash)`](#GovernorComponent-hash_proposal)
- [`state(self, proposal_id)`](#GovernorComponent-state)
- [`proposal_threshold(self)`](#GovernorComponent-proposal_threshold)
- [`proposal_snapshot(self, proposal_id)`](#GovernorComponent-proposal_snapshot)
- [`proposal_deadline(self, proposal_id)`](#GovernorComponent-proposal_deadline)
- [`proposal_proposer(self, proposal_id)`](#GovernorComponent-proposal_proposer)
- [`proposal_eta(self, proposal_id)`](#GovernorComponent-proposal_eta)
- [`proposal_needs_queuing(self, proposal_id)`](#GovernorComponent-proposal_needs_queuing)
- [`voting_delay(self)`](#GovernorComponent-voting_delay)
- [`voting_period(self)`](#GovernorComponent-voting_period)
- [`quorum(self, timepoint)`](#GovernorComponent-quorum)
- [`get_votes(self, account, timepoint)`](#GovernorComponent-get_votes)
- [`get_votes_with_params(self, account, timepoint, params)`](#GovernorComponent-get_votes_with_params)
- [`has_voted(self, proposal_id, account)`](#GovernorComponent-has_voted)
- [`propose(self, calls, description)`](#GovernorComponent-propose)
- [`queue(self, calls, description_hash)`](#GovernorComponent-queue)
- [`execute(self, calls, description_hash)`](#GovernorComponent-execute)
- [`cancel(self, proposal_id, description_hash)`](#GovernorComponent-cancel)
- [`cast_vote(self, proposal_id, support)`](#GovernorComponent-cast_vote)
- [`cast_vote_with_reason(self, proposal_id, support, reason)`](#GovernorComponent-cast_vote_with_reason)
- [`cast_vote_with_reason_and_params(self, proposal_id, support, reason, params)`](#GovernorComponent-cast_vote_with_reason_and_params)
- [`cast_vote_by_sig(self, proposal_id, support, reason, signature)`](#GovernorComponent-cast_vote_by_sig)
- [`cast_vote_with_reason_and_params_by_sig(self, proposal_id, support, reason, params, signature)`](#GovernorComponent-cast_vote_with_reason_and_params_by_sig)
- [`nonces(self, voter)`](#GovernorComponent-nonces)
- [`relay(self, call)`](#GovernorComponent-relay)

Internal Implementations

InternalImpl

- [`initializer(self)`](#GovernorComponent-initializer)
- [`get_proposal(self, proposal_id)`](#GovernorComponent-get_proposal)
- [`is_valid_description_for_proposer(self, proposer, description)`](#GovernorComponent-is_valid_description_for_proposer)
- [`_hash_proposal(self, calls, description_hash)`](#GovernorComponent-_hash_proposal)
- [`_proposal_snapshot(self, proposal_id)`](#GovernorComponent-_proposal_snapshot)
- [`_proposal_deadline(self, proposal_id)`](#GovernorComponent-_proposal_deadline)
- [`_proposal_proposer(self, proposal_id)`](#GovernorComponent-_proposal_proposer)
- [`_proposal_eta(self, proposal_id)`](#GovernorComponent-_proposal_eta)

InternalExtendedImpl

- [`assert_only_governance(self)`](#GovernorComponent-assert_only_governance)
- [`validate_state(self, proposal_id, allowed_states)`](#GovernorComponent-validate_state)
- [`use_nonce(self, voter)`](#GovernorComponent-use_nonce)
- [`_get_votes(self, account, timepoint, params)`](#GovernorComponent-_get_votes)
- [`_proposal_threshold(self)`](#GovernorComponent-_proposal_threshold)
- [`_state(self, proposal_id)`](#GovernorComponent-_state)
- [`_propose(self, calls, description, proposer)`](#GovernorComponent-_propose)
- [`_cancel(self, proposal_id, description_hash)`](#GovernorComponent-_cancel)
- [`_count_vote(self, proposal_id, account, support, total_weight, params)`](#GovernorComponent-_count_vote)
- [`_cast_vote(self, proposal_id, voter, support, reason, params)`](#GovernorComponent-_cast_vote)

Events

- [`ProposalCreated(proposal_id, proposer, calls, signatures, vote_start, vote_end, description)`](#GovernorComponent-ProposalCreated)
- [`ProposalQueued(proposal_id)`](#GovernorComponent-ProposalQueued)
- [`ProposalExecuted(proposal_id)`](#GovernorComponent-ProposalExecuted)
- [`ProposalCanceled(proposal_id)`](#GovernorComponent-ProposalCanceled)
- [`VoteCast(voter, proposal_id, support, weight, reason)`](#GovernorComponent-VoteCast)
- [`VoteCastWithParams(voter, proposal_id, support, weight, reason, params)`](#GovernorComponent-VoteCastWithParams)

#### [](#GovernorComponent-Extensions-Traits)Extensions traits functions

#### [](#GovernorComponent-GovernorSettingsTrait-voting_delay)`voting_delay(self: @ContractState) → u64` extension

Must return the delay, in number of timepoints, between when the proposal is created and when the vote starts. This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a proposal starts.

#### [](#GovernorComponent-GovernorSettingsTrait-voting_period)`voting_period(self: @ContractState) → u64` extension

Must return the delay, in number of timepoints, between the vote start and vote end.

#### [](#GovernorComponent-GovernorSettingsTrait-proposal_threshold)`proposal_threshold(self: @ContractState) → u256` extension

Must return the minimum number of votes that an account must have to create a proposal.

#### [](#GovernorComponent-GovernorQuorumTrait-quorum)`quorum(self: @ContractState, timepoint: u64) → u256` extension

Must return the minimum number of votes required for a proposal to succeed.

#### [](#GovernorComponent-GovernorCountingTrait-counting_mode)`counting_mode(self: @ContractState) → ByteArray` extension

Must return a description of the possible `support` values for `cast_vote` and the way these votes are counted, meant to be consumed by UIs to show correct vote options and interpret the results. See [COUNTING\_MODE](#GovernorComponent-COUNTING_MODE) for more details.

#### [](#GovernorComponent-GovernorCountingTrait-count_vote)`count_vote(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, total_weight: u256, params: Span<felt252>) → u256` extension

Must register a vote for `proposal_id` by `account` with a given `support`, voting `weight` and voting `params`.

Support is generic and can represent various things depending on the voting system used.

#### [](#GovernorComponent-GovernorCountingTrait-has_voted)`has_voted(self: @ContractState, proposal_id: felt252, account: ContractAddress) → bool` extension

Must return whether an account has cast a vote on a proposal.

#### [](#GovernorComponent-GovernorCountingTrait-quorum_reached)`quorum_reached(self: @ContractState, proposal_id: felt252) → bool` extension

Must return whether the minimum quorum has been reached for a proposal.

#### [](#GovernorComponent-GovernorCountingTrait-vote_succeeded)`vote_succeeded(self: @ContractState, proposal_id: felt252) → bool` extension

Must return whether a proposal has succeeded or not.

#### [](#GovernorComponent-GovernorVotesTrait-clock)`clock(self: @ContractState) → u64` extension

Returns the current timepoint determined by the governor’s operational mode, intended for use in time-sensitive logic. See [ERC-6372#clock](https://eips.ethereum.org/EIPS/eip-6372#clock).

Requirements:

- This function MUST always be non-decreasing.

#### [](#GovernorComponent-GovernorVotesTrait-CLOCK_MODE)`CLOCK_MODE(self: @ContractState) → ByteArray` extension

Returns a description of the clock the governor is operating in. See [ERC-6372#CLOCK\_MODE](https://eips.ethereum.org/EIPS/eip-6372#clock_mode).

Requirements:

- The output MUST be formatted like a URL query string, decodable in standard JavaScript.

#### [](#GovernorComponent-GovernorVotesTrait-get_votes)`get_votes(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` extension

Must return the voting power of an account at a specific timepoint with the given parameters.

#### [](#GovernorComponent-GovernorExecutionTrait-state)`state(self: @ContractState, proposal_id: felt252) → ProposalState` extension

Must return the state of a proposal at the current time.

The state can be either:

- `Pending`: The proposal does not exist yet.
- `Active`: The proposal is active.
- `Canceled`: The proposal has been canceled.
- `Defeated`: The proposal has been defeated.
- `Succeeded`: The proposal has succeeded.
- `Queued`: The proposal has been queued.
- `Executed`: The proposal has been executed.

#### [](#GovernorComponent-GovernorExecutionTrait-executor)`executor(self: @ContractState) → ContractAddress` internal

Must return the address through which the governor executes action. Should be used to specify whether the module execute actions through another contract such as a timelock.

MUST be the governor itself, or an instance of TimelockController with the governor as the only proposer, canceller, and executor.

When the executor is not the governor itself (i.e. a timelock), it can call functions that are restricted with the `assert_only_governance` guard, and also potentially execute transactions on behalf of the governor. Because of this, this module is designed to work with the TimelockController as the unique potential external executor.

#### [](#GovernorComponent-GovernorExecutionTrait-execute_operations)`execute_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>)` internal

Execution mechanism. Can be used to modify the way operations are executed (for example adding a vault/timelock).

#### [](#GovernorComponent-GovernorExecutionTrait-queue_operations)`queue_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>)` internal

Queuing mechanism. Can be used to modify the way queuing is performed (for example adding a vault/timelock).

Requirements:

- Must return a timestamp that describes the expected ETA for execution. If the returned value is 0, the core will consider queueing did not succeed, and the public `queue` function will revert.

#### [](#GovernorComponent-GovernorExecutionTrait-proposal_needs_queuing)`proposal_needs_queuing(self: @ContractState) → bool` internal

Must return whether proposals need to be queued before execution. This usually indicates if the proposal needs to go through a timelock.

#### [](#GovernorComponent-GovernorExecutionTrait-cancel_operations)`cancel_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>)` internal

Cancel mechanism. Can be used to modify the way canceling is performed (for example adding a vault/timelock).

#### [](#GovernorComponent-Embeddable-Functions)Embeddable functions

#### [](#GovernorComponent-name)`name() → felt252` external

Name of the governor instance (used in building the [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) domain separator).

#### [](#GovernorComponent-version)`version() → felt252` external

Version of the governor instance (used in building [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) domain separator).

#### [](#GovernorComponent-COUNTING_MODE)`COUNTING_MODE() → ByteArray` external

A description of the possible `support` values for `cast_vote` and the way these votes are counted, meant to be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.

There are 2 standard keys: `support` and `quorum`.

- `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.
- `quorum=bravo` means that only For votes are counted towards quorum.
- `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.

If a counting module makes use of encoded `params`, it should include this under a `params` key with a unique name that describes the behavior. For example:

- `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.
- `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.

The string can be decoded by the standard [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) JavaScript class.

#### [](#GovernorComponent-hash_proposal)`hash_proposal(calls: Span<Call>, description_hash: felt252) → felt252` external

Hashing function used to (re)build the proposal id from the proposal details.

#### [](#GovernorComponent-state)`state(proposal_id: felt252) → ProposalState` external

Returns the state of a proposal, given its id.

#### [](#GovernorComponent-proposal_threshold)`proposal_threshold() → u256` external

The number of votes required in order for a voter to become a proposer.

#### [](#GovernorComponent-proposal_snapshot)`proposal_snapshot(proposal_id: felt252) → u64` external

Timepoint used to retrieve user’s votes and quorum. If using block number, the snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the following block.

#### [](#GovernorComponent-proposal_deadline)`proposal_deadline(proposal_id: felt252) → u64` external

Timepoint at which votes close. If using block number, votes close at the end of this block, so it is possible to cast a vote during this block.

#### [](#GovernorComponent-proposal_proposer)`proposal_proposer(proposal_id: felt252) → ContractAddress` external

The account that created a proposal.

#### [](#GovernorComponent-proposal_eta)`proposal_eta(proposal_id: felt252) → u64` external

The time when a queued proposal becomes executable ("ETA"). Unlike `proposal_snapshot` and `proposal_deadline`, this doesn’t use the governor clock, and instead relies on the executor’s clock which may be different. In most cases this will be a timestamp.

#### [](#GovernorComponent-proposal_needs_queuing)`proposal_needs_queuing(proposal_id: felt252) → bool` external

Whether a proposal needs to be queued before execution. This indicates if the proposal needs to go through a timelock.

#### [](#GovernorComponent-voting_delay)`voting_delay() → u64` external

Delay between when a proposal is created and when the vote starts. The unit this duration is expressed in depends on the clock (see [ERC-6372](https://eips.ethereum.org/EIPS/eip-6372)) this contract uses.

This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a proposal starts.

#### [](#GovernorComponent-voting_period)`voting_period() → u64` external

Delay between the vote start and vote end. The unit this duration is expressed in depends on the clock (see [ERC-6372](https://eips.ethereum.org/EIPS/eip-6372)) this contract uses.

The `voting_delay` can delay the start of the vote. This must be considered when setting the voting duration compared to the voting delay.

This value is stored when the proposal is submitted so that possible changes to the value do not affect proposals that have already been submitted.

#### [](#GovernorComponent-quorum)`quorum(timepoint: u64) → u256` external

Minimum number of votes required for a proposal to be successful.

The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows the quorum to scale depending on values such as the total supply of a token at this timepoint.

#### [](#GovernorComponent-get_votes)`get_votes(account: ContractAddress, timepoint: u64) → u256` external

Returns the voting power of an `account` at a specific `timepoint`.

This can be implemented in a number of ways, for example by reading the delegated balance from one (or multiple) `ERC20Votes` tokens.

#### [](#GovernorComponent-get_votes_with_params)`get_votes_with_params(account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` external

Returns the voting power of an account at a specific timepoint, given additional encoded parameters.

#### [](#GovernorComponent-has_voted)`has_voted(proposal_id: felt252, account: ContractAddress) → bool` external

Returns whether an account has cast a vote on a proposal.

#### [](#GovernorComponent-propose)`propose(calls: Span<Call>, description: ByteArray) → felt252` external

Creates a new proposal. Voting starts after the delay specified by `voting_delay` and lasts for a duration specified by `voting_period`. Returns the id of the proposal.

This function has opt-in frontrunning protection, described in `is_valid_description_for_proposer`.

The state of the Governor and targets may change between the proposal creation and its execution. This may be the result of third party actions on the targeted contracts, or other governor proposals. For example, the balance of this contract could be updated or its access control permissions may be modified, possibly compromising the proposal’s ability to execute successfully (e.g. the governor doesn’t have enough value to cover a proposal with multiple transfers).

Requirements:

- The proposer must be authorized to submit the proposal.
- The proposer must have enough votes to submit the proposal if `proposal_threshold` is greater than zero.
- The proposal must not already exist.

Emits a [ProposalCreated](#GovernorComponent-ProposalCreated) event.

#### [](#GovernorComponent-queue)`queue(calls: Span<Call>, description_hash: felt252) → felt252` external

Queues a proposal. Some governors require this step to be performed before execution can happen. If queuing is not necessary, this function may revert. Queuing a proposal requires the quorum to be reached, the vote to be successful, and the deadline to be reached.

Returns the id of the proposal.

Requirements:

- The proposal must be in the `Succeeded` state.
- The queue operation must return a non-zero ETA.

Emits a [ProposalQueued](#GovernorComponent-ProposalQueued) event.

#### [](#GovernorComponent-execute)`execute(calls: span<Call>, description_hash: felt252) → felt252` external

Executes a successful proposal. This requires the quorum to be reached, the vote to be successful, and the deadline to be reached. Depending on the governor it might also be required that the proposal was queued and that some delay passed.

Some modules can modify the requirements for execution, for example by adding an additional timelock (See `timelock_controller`).

Returns the id of the proposal.

Requirements:

- The proposal must be in the `Succeeded` or `Queued` state.

Emits a [ProposalExecuted](#GovernorComponent-ProposalExecuted) event.

#### [](#GovernorComponent-cancel)`cancel(calls: Span<Call>, description_hash: felt252) → felt252` external

Cancels a proposal. A proposal is cancellable by the proposer, but only while it is Pending state, i.e. before the vote starts.

Returns the id of the proposal.

Requirements:

- The proposal must be in the `Pending` state.
- The caller must be the proposer of the proposal.

Emits a [ProposalCanceled](#GovernorComponent-ProposalCanceled) event.

#### [](#GovernorComponent-cast_vote)`cast_vote(proposal_id: felt252, support: u8) → u256` external

Cast a vote.

Requirements:

- The proposal must be active.

Emits a [VoteCast](#GovernorComponent-VoteCast) event.

#### [](#GovernorComponent-cast_vote_with_reason)`cast_vote_with_reason(proposal_id: felt252, support: u8, reason: ByteArray) → u256` external

Cast a vote with a `reason`.

Requirements:

- The proposal must be active.

Emits a [VoteCast](#GovernorComponent-VoteCast) event.

#### [](#GovernorComponent-cast_vote_with_reason_and_params)`cast_vote_with_reason_and_params(proposal_id: felt252, support: u8, reason: ByteArray, params: Span<felt252>) → u256` external

Cast a vote with a `reason` and additional serialized `params`.

Requirements:

- The proposal must be active.

Emits either:

- [VoteCast](#GovernorComponent-VoteCast) event if no params are provided.
- [VoteCastWithParams](#GovernorComponent-VoteCastWithParams) event otherwise.

#### [](#GovernorComponent-cast_vote_by_sig)`cast_vote_by_sig(proposal_id: felt252, support: u8, voter: ContractAddress, signature: Span<felt252>) → u256` external

Cast a vote using the `voter`'s signature.

Requirements:

- The proposal must be active.
- The nonce in the signed message must match the account’s current nonce.
- `voter` must implement `SRC6::is_valid_signature`.
- `signature` must be valid for the message hash.

Emits a [VoteCast](#GovernorComponent-VoteCast) event.

#### [](#GovernorComponent-cast_vote_with_reason_and_params_by_sig)`cast_vote_with_reason_and_params_by_sig(proposal_id: felt252, support: u8, voter: ContractAddress, reason: ByteArray, params: Span<felt252>, signature: Span<felt252>) → u256` external

Cast a vote with a `reason` and additional serialized `params` using the `voter`'s signature.

Requirements:

- The proposal must be active.
- The nonce in the signed message must match the account’s current nonce.
- `voter` must implement `SRC6::is_valid_signature`.
- `signature` must be valid for the message hash.

Emits either:

- [VoteCast](#GovernorComponent-VoteCast) event if no params are provided.
- [VoteCastWithParams](#GovernorComponent-VoteCastWithParams) event otherwise.

#### [](#GovernorComponent-nonces)`nonces(voter: ContractAddress) → felt252` external

Returns the next unused nonce for an address.

#### [](#GovernorComponent-relay)`relay(call: Call)` external

Relays a transaction or function call to an arbitrary target.

In cases where the governance executor is some contract other than the governor itself, like when using a timelock, this function can be invoked in a governance proposal to recover tokens that were sent to the governor contract by mistake.

If the executor is simply the governor itself, use of `relay` is redundant.

#### [](#GovernorComponent-Internal-Functions)Internal functions

#### [](#GovernorComponent-initializer)`initializer(ref self: ContractState)` internal

Initializes the contract by registering the supported interface id.

#### [](#GovernorComponent-get_proposal)`get_proposal(self: @ContractState, proposal_id: felt252) → ProposalCore` internal

Returns the proposal object given its id.

#### [](#GovernorComponent-is_valid_description_for_proposer)`is_valid_description_for_proposer(self: @ContractState, proposer: ContractAddress, description: ByteArray) → bool` internal

Checks if the proposer is authorized to submit a proposal with the given description.

If the proposal description ends with `#proposer=0x???`, where `0x???` is an address written as a hex string (case insensitive), then the submission of this proposal will only be authorized to said address.

This is used for frontrunning protection. By adding this pattern at the end of their proposal, one can ensure that no other address can submit the same proposal. An attacker would have to either remove or change that part, which would result in a different proposal id.

In Starknet, the Sequencer ensures the order of transactions, but frontrunning can still be achieved by nodes, and potentially other actors in the future with sequencer decentralization.

If the description does not match this pattern, it is unrestricted and anyone can submit it. This includes:

- If the `0x???` part is not a valid hex string.
- If the `0x???` part is a valid hex string, but does not contain exactly 64 hex digits.
- If it ends with the expected suffix followed by newlines or other whitespace.
- If it ends with some other similar suffix, e.g. `#other=abc`.
- If it does not end with any such suffix.

#### [](#GovernorComponent-_hash_proposal)`_hash_proposal(self: @ContractState, calls: Span<Call>, description_hash: felt252) → felt252` internal

Returns the proposal id computed from the given parameters.

The proposal id is computed as a Pedersen hash of:

- The array of calls being proposed
- The description hash

#### [](#GovernorComponent-_proposal_snapshot)`_proposal_snapshot(self: @ContractState, proposal_id: felt252) → u64` internal

Timepoint used to retrieve user’s votes and quorum. If using block number, the snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the following block.

#### [](#GovernorComponent-_proposal_deadline)`_proposal_deadline(self: @ContractState, proposal_id: felt252) → u64` internal

Timepoint at which votes close. If using block number, votes close at the end of this block, so it is possible to cast a vote during this block.

#### [](#GovernorComponent-_proposal_proposer)`_proposal_proposer(self: @ContractState, proposal_id: felt252) → ContractAddress` internal

The account that created a proposal.

#### [](#GovernorComponent-_proposal_eta)`_proposal_eta(self: @ContractState, proposal_id: felt252) → u64` internal

The time when a queued proposal becomes executable ("ETA"). Unlike `proposal_snapshot` and `proposal_deadline`, this doesn’t use the governor clock, and instead relies on the executor’s clock which may be different. In most cases this will be a timestamp.

#### [](#GovernorComponent-assert_only_governance)`assert_only_governance(self: @ContractState)` internal

Asserts that the caller is the governance executor.

When the executor is not the governor itself (i.e. a timelock), it can call functions that are restricted with this modifier, and also potentially execute transactions on behalf of the governor. Because of this, this module is designed to work with the TimelockController as the unique potential external executor. The timelock MUST have the governor as the only proposer, canceller, and executor.

#### [](#GovernorComponent-validate_state)`validate_state(self: @ContractState, proposal_id: felt252, state: ProposalState)` internal

Validates that a proposal is in the expected state. Otherwise it panics.

#### [](#GovernorComponent-use_nonce)`use_nonce(ref self: ContractState) → felt252` internal

Consumes a nonce, returns the current value, and increments nonce.

#### [](#GovernorComponent-_get_votes)`_get_votes(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` internal

Internal wrapper for `GovernorVotesTrait::get_votes`.

#### [](#GovernorComponent-_proposal_threshold)`_proposal_threshold(self: @ContractState) → u256` internal

Internal wrapper for `GovernorProposeTrait::proposal_threshold`.

#### [](#GovernorComponent-_state)`_state(self: @ContractState, proposal_id: felt252) → ProposalState` internal

Returns the state of a proposal, given its id.

Requirements:

- The proposal must exist.

#### [](#GovernorComponent-_propose)`_propose(ref self: ContractState, calls: Span<Call>, description_hash: felt252) → felt252` internal

Internal propose mechanism. Returns the proposal id.

Requirements:

- The proposal must not already exist.

Emits a [ProposalCreated](#GovernorComponent-ProposalCreated) event.

#### [](#GovernorComponent-_cancel)`_cancel(ref self: ContractState, proposal_id: felt252)` internal

Internal cancel mechanism with minimal restrictions.

A proposal can be cancelled in any state other than Canceled or Executed.

Once cancelled, a proposal can’t be re-submitted.

#### [](#GovernorComponent-_count_vote)`_count_vote(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, weight: u256, params: Span<felt252>)` internal

Internal wrapper for `GovernorCountingTrait::count_vote`.

#### [](#GovernorComponent-_cast_vote)`_cast_vote(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, reason: ByteArray, params: Span<felt252>) → u256` internal

Internal vote-casting mechanism.

Checks that the vote is pending and that it has not been cast yet. This function retrieves the voting weight using `get_votes` and then calls the `_count_vote` internal function.

Emits either:

- [VoteCast](#GovernorComponent-VoteCast) event if no params are provided.
- [VoteCastWithParams](#GovernorComponent-VoteCastWithParams) event otherwise.

#### [](#GovernorComponent-Events)Events

#### [](#GovernorComponent-ProposalCreated)`ProposalCreated(proposal_id: felt252, proposer: ContractAddress, calls: Span<Call>, signatures: Span<Span<felt252>>, vote_start: u64, vote_end: u64, description: ByteArray)` event

Emitted when a proposal is created.

#### [](#GovernorComponent-ProposalQueued)`ProposalQueued(proposal_id: felt252, eta_seconds: u64)` event

Emitted when a proposal is queued.

#### [](#GovernorComponent-ProposalExecuted)`ProposalExecuted(proposal_id: felt252)` event

Emitted when a proposal is executed.

#### [](#GovernorComponent-ProposalCanceled)`ProposalCanceled(proposal_id: felt252)` event

Emitted when a proposal is canceled.

#### [](#GovernorComponent-VoteCast)`VoteCast(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray)` event

Emitted when a vote is cast.

#### [](#GovernorComponent-VoteCastWithParams)`VoteCastWithParams(voter: ContractAddress, proposal_id: felt252, support: u8, weight: u256, reason: ByteArray, params: Span<felt252>)` event

Emitted when a vote is cast with params.

## [](#governor_extensions)Governor extensions

The Governor component can (and must) be extended by implementing the [extensions traits](#GovernorComponent-Extensions-Traits-Traits) to add the desired functionality. This can be achieved by directly implementing the traits on your contract, or by using a set of ready-to-use extensions provided by the library, which are presented below.

### [](#GovernorCoreExecutionComponent)`GovernorCoreExecutionComponent`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/governance/src/governor/extensions/governor_core_execution.cairo)

```cairo
use openzeppelin_governance::governor::extensions::GovernorCoreExecutionComponent;
```

Extension of [GovernorComponent](#GovernorComponent) providing an execution mechanism directly through the Governor itself. For a timelocked execution mechanism, see [GovernorTimelockExecutionComponent](#GovernorTimelockExecutionComponent).

Extension traits implementations

GovernorExecution

- [`state(self, proposal_id)`](#GovernorCoreExecutionComponent-state)
- [`executor(self)`](#GovernorCoreExecutionComponent-executor)
- [`execute_operations(self, proposal_id, calls, description_hash)`](#GovernorCoreExecutionComponent-execute_operations)
- [`queue_operations(self, proposal_id, calls, description_hash)`](#GovernorCoreExecutionComponent-queue_operations)
- [`proposal_needs_queuing(self, proposal_id)`](#GovernorCoreExecutionComponent-proposal_needs_queuing)
- [`cancel_operations(self, proposal_id, description_hash)`](#GovernorCoreExecutionComponent-cancel_operations)

#### [](#GovernorCoreExecutionComponent-Extension-Traits-Functions)Extension traits functions

#### [](#GovernorCoreExecutionComponent-state)`state(self: @ContractState, proposal_id: felt252) → ProposalState` internal

Returns the state of a proposal given its id.

Requirements:

- The proposal must exist.

#### [](#GovernorCoreExecutionComponent-executor)`executor(self: @ContractState) → ContractAddress` internal

Returns the executor address.

In this case, it returns the governor contract address since execution is performed directly through it.

#### [](#GovernorCoreExecutionComponent-execute_operations)`execute_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252)` internal

Executes the proposal’s operations directly through the governor contract.

#### [](#GovernorCoreExecutionComponent-queue_operations)`queue_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252) → u64` internal

In this implementation, queuing is not required so it returns 0.

#### [](#GovernorCoreExecutionComponent-proposal_needs_queuing)`proposal_needs_queuing(self: @ContractState, proposal_id: felt252) → bool` internal

In this implementation, it always returns false.

#### [](#GovernorCoreExecutionComponent-cancel_operations)`cancel_operations(ref self: ContractState, proposal_id: felt252, description_hash: felt252)` internal

Cancels a proposal’s operations.

### [](#GovernorCountingSimpleComponent)`GovernorCountingSimpleComponent`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/governance/src/governor/extensions/governor_counting_simple.cairo)

```cairo
use openzeppelin_governance::governor::extensions::GovernorCountingSimpleComponent;
```

Extension of [GovernorComponent](#GovernorComponent) for simple vote counting with three options.

Extension traits implementations

GovernorCounting

- [`counting_mode(self)`](#GovernorCountingSimpleComponent-counting_mode)
- [`count_vote(self, proposal_id, account, support, total_weight, params)`](#GovernorCountingSimpleComponent-count_vote)
- [`has_voted(self, proposal_id, account)`](#GovernorCountingSimpleComponent-has_voted)
- [`quorum_reached(self, proposal_id)`](#GovernorCountingSimpleComponent-quorum_reached)
- [`vote_succeeded(self, proposal_id)`](#GovernorCountingSimpleComponent-vote_succeeded)

#### [](#GovernorCountingSimpleComponent-Extension-Traits-Functions)Extension traits functions

#### [](#GovernorCountingSimpleComponent-counting_mode)`counting_mode(self: @ContractState) → ByteArray` internal

Returns `"support=bravo&quorum=for,abstain"`.

- `support=bravo` indicates that the support follows the Governor Bravo format where voters can vote For, Against, or Abstain
- `quorum=for,abstain` indicates that both For and Abstain votes count toward quorum

#### [](#GovernorCountingSimpleComponent-count_vote)`count_vote(ref self: ContractState, proposal_id: felt252, account: ContractAddress, support: u8, total_weight: u256, params: Span<felt252>) → u256` internal

Records a vote for a proposal.

The support value follows the `VoteType` enum (0=Against, 1=For, 2=Abstain).

Returns the weight that was counted.

#### [](#GovernorCountingSimpleComponent-has_voted)`has_voted(self: @ContractState, proposal_id: felt252, account: ContractAddress) → bool` internal

Returns whether an account has cast a vote on a proposal.

#### [](#GovernorCountingSimpleComponent-quorum_reached)`quorum_reached(self: @ContractState, proposal_id: felt252) → bool` internal

Returns whether a proposal has reached quorum.

In this implementation, both For and Abstain votes count toward quorum.

#### [](#GovernorCountingSimpleComponent-vote_succeeded)`vote_succeeded(self: @ContractState, proposal_id: felt252) → bool` internal

Returns whether a proposal has succeeded.

In this implementation, the For votes must be strictly greater than Against votes.

### [](#GovernorSettingsComponent)`GovernorSettingsComponent`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/governance/src/governor/extensions/governor_settings.cairo)

```cairo
use openzeppelin_governance::governor::extensions::GovernorSettingsComponent;
```

Extension of [GovernorComponent](#GovernorComponent) for settings that are updatable through governance.

Extension traits implementations

GovernorSettings

- [`voting_delay(self)`](#GovernorSettingsComponent-voting_delay)
- [`voting_period(self)`](#GovernorSettingsComponent-voting_period)
- [`proposal_threshold(self)`](#GovernorSettingsComponent-proposal_threshold)

Embeddable implementations

GovernorSettingsAdminImpl

- [`set_voting_delay(self, new_voting_delay)`](#GovernorSettingsComponent-set_voting_delay)
- [`set_voting_period(self, new_voting_period)`](#GovernorSettingsComponent-set_voting_period)
- [`set_proposal_threshold(self, new_proposal_threshold)`](#GovernorSettingsComponent-set_proposal_threshold)

Internal implementations

InternalImpl

- [`initializer(self, new_voting_delay, new_voting_period, new_proposal_threshold)`](#GovernorSettingsComponent-initializer)
- [`assert_only_governance(self)`](#GovernorSettingsComponent-assert_only_governance)
- [`_set_voting_delay(self, new_voting_delay)`](#GovernorSettingsComponent-_set_voting_delay)
- [`_set_voting_period(self, new_voting_period)`](#GovernorSettingsComponent-_set_voting_period)
- [`_set_proposal_threshold(self, new_proposal_threshold)`](#GovernorSettingsComponent-_set_proposal_threshold)

Events

- [`VotingDelayUpdated(old_voting_delay, new_voting_delay)`](#GovernorSettingsComponent-VotingDelayUpdated)
- [`VotingPeriodUpdated(old_voting_period, new_voting_period)`](#GovernorSettingsComponent-VotingPeriodUpdated)
- [`ProposalThresholdUpdated(old_proposal_threshold, new_proposal_threshold)`](#GovernorSettingsComponent-ProposalThresholdUpdated)

#### [](#GovernorSettings-Extension-Traits-Functions)Extension traits functions

#### [](#GovernorSettingsComponent-voting_delay)`voting_delay(self: @ContractState) → u64` internal

Returns the delay, between when a proposal is created and when voting starts.

#### [](#GovernorSettingsComponent-voting_period)`voting_period(self: @ContractState) → u64` internal

Returns the time period, during which votes can be cast.

#### [](#GovernorSettingsComponent-proposal_threshold)`proposal_threshold(self: @ContractState) → u256` internal

Returns the minimum number of votes required for an account to create a proposal.

#### [](#GovernorSettings-Embeddable-Functions)Embeddable functions

#### [](#GovernorSettingsComponent-set_voting_delay)`set_voting_delay(ref self: ContractState, new_voting_delay: u64)` external

Sets the voting delay.

Requirements:

- Caller must be the governance executor.

This function does not emit an event if the new voting delay is the same as the old one.

May emit a [VotingDelayUpdated](#GovernorSettingsComponent-VotingDelayUpdated) event.

#### [](#GovernorSettingsComponent-set_voting_period)`set_voting_period(ref self: ContractState, new_voting_period: u64)` external

Sets the voting period.

This function does not emit an event if the new voting period is the same as the old one.

Requirements:

- Caller must be the governance executor.
- `new_voting_period` must be greater than 0.

May emit a [VotingPeriodUpdated](#GovernorSettingsComponent-VotingPeriodUpdated) event.

#### [](#GovernorSettingsComponent-set_proposal_threshold)`set_proposal_threshold(ref self: ContractState, new_proposal_threshold: u256)` external

Sets the proposal threshold.

This function does not emit an event if the new proposal threshold is the same as the old one.

Requirements:

- Caller must be the governance executor.

May emit a [ProposalThresholdUpdated](#GovernorSettingsComponent-ProposalThresholdUpdated) event.

#### [](#GovernorSettingsComponent-Internal-Functions)Internal functions

#### [](#GovernorSettingsComponent-initializer)`initializer(ref self: ContractState, initial_voting_delay: u64, initial_voting_period: u64, initial_proposal_threshold: u256)` internal

Initializes the component by setting the default values.

Requirements:

- `new_voting_period` must be greater than 0.

Emits a [VotingDelayUpdated](#GovernorSettingsComponent-VotingDelayUpdated), [VotingPeriodUpdated](#GovernorSettingsComponent-VotingPeriodUpdated), and [ProposalThresholdUpdated](#GovernorSettingsComponent-ProposalThresholdUpdated) event.

#### [](#GovernorSettingsComponent-assert_only_governance)`assert_only_governance(ref self: ContractState)` internal

Asserts that the caller is the governance executor.

#### [](#GovernorSettingsComponent-_set_voting_delay)`_set_voting_delay(ref self: ContractState, new_voting_delay: u64)` internal

Internal function to update the voting delay.

This function does not emit an event if the new voting delay is the same as the old one.

May emit a [VotingDelayUpdated](#GovernorSettingsComponent-VotingDelayUpdated) event.

#### [](#GovernorSettingsComponent-_set_voting_period)`_set_voting_period(ref self: ContractState, new_voting_period: u64)` internal

Internal function to update the voting period.

Requirements:

- `new_voting_period` must be greater than 0.

This function does not emit an event if the new voting period is the same as the old one.

May emit a [VotingPeriodUpdated](#GovernorSettingsComponent-VotingPeriodUpdated) event.

#### [](#GovernorSettingsComponent-_set_proposal_threshold)`_set_proposal_threshold(ref self: ContractState, new_proposal_threshold: u256)` internal

Internal function to update the proposal threshold.

This function does not emit an event if the new proposal threshold is the same as the old one.

May emit a [ProposalThresholdUpdated](#GovernorSettingsComponent-ProposalThresholdUpdated) event.

#### [](#GovernorSettings-Events)Events

#### [](#GovernorSettingsComponent-VotingDelayUpdated)`VotingDelayUpdated(old_voting_delay: u64, new_voting_delay: u64)` event

Emitted when the voting delay is updated.

#### [](#GovernorSettingsComponent-VotingPeriodUpdated)`VotingPeriodUpdated(old_voting_period: u64, new_voting_period: u64)` event

Emitted when the voting period is updated.

#### [](#GovernorSettingsComponent-ProposalThresholdUpdated)`ProposalThresholdUpdated(old_proposal_threshold: u256, new_proposal_threshold: u256)` event

Emitted when the proposal threshold is updated.

### [](#GovernorVotesComponent)`GovernorVotesComponent`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/governance/src/governor/extensions/governor_votes.cairo)

```cairo
use openzeppelin_governance::governor::extensions::GovernorVotesComponent;
```

Extension of [GovernorComponent](#GovernorComponent) for voting weight extraction from a token with the [IVotes](#IVotes) extension.

Extension traits implementations

GovernorVotes

- [`clock(self)`](#GovernorVotesComponent-clock)
- [`CLOCK_MODE(self)`](#GovernorVotesComponent-CLOCK_MODE)
- [`get_votes(self, account, timepoint, params)`](#GovernorVotesComponent-get_votes)

Embeddable implementations

VotesTokenImpl

- [`token(self)`](#GovernorVotesComponent-token)

Internal implementations

InternalImpl

- [`initializer(self, votes_token)`](#GovernorVotesComponent-initializer)

#### [](#GovernorVotes-Extension-Traits-Functions)Extension traits functions

#### [](#GovernorVotesComponent-clock)`clock(self: @ContractState) → u64` internal

Returns the current timepoint determined by the governor’s operational mode, intended for use in time-sensitive logic. See [ERC-6372#clock](https://eips.ethereum.org/EIPS/eip-6372#clock).

Requirements:

- This function MUST always be non-decreasing.

#### [](#GovernorVotesComponent-CLOCK_MODE)`CLOCK_MODE(self: @ContractState) → ByteArray` internal

Returns a description of the clock the governor is operating in. See [ERC-6372#CLOCK\_MODE](https://eips.ethereum.org/EIPS/eip-6372#clock_mode).

Requirements:

- The output MUST be formatted like a URL query string, decodable in standard JavaScript.

#### [](#GovernorVotesComponent-get_votes)`get_votes(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` internal

Returns the voting power of `account` at a specific `timepoint` using the votes token.

#### [](#GovernorVotesComponent-Embeddable-Functions)Embeddable functions

#### [](#GovernorVotesComponent-token)`token(self: @ContractState) → ContractAddress` external

Returns the votes token that voting power is sourced from.

#### [](#GovernorVotesComponent-Internal-Functions)Internal functions

#### [](#GovernorVotesComponent-initializer)`initializer(ref self: ContractState, votes_token: ContractAddress)` internal

Initializes the component by setting the votes token.

Requirements:

- `votes_token` must not be zero.

### [](#GovernorVotesQuorumFractionComponent)`GovernorVotesQuorumFractionComponent`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/governance/src/governor/extensions/governor_votes_quorum_fraction.cairo)

```cairo
use openzeppelin_governance::governor::extensions::GovernorVotesQuorumFractionComponent;
```

Extension of [GovernorComponent](#GovernorComponent) for voting weight extraction from a token with the [IVotes](#IVotes) extension and a quorum expressed as a fraction of the total supply.

Extension traits implementations

GovernorQuorum

- [`quorum(self, timepoint)`](#GovernorVotesQuorumFractionComponent-quorum)

GovernorVotes

- [`clock(self)`](#GovernorVotesQuorumFractionComponent-clock)
- [`CLOCK_MODE(self)`](#GovernorVotesQuorumFractionComponent-CLOCK_MODE)
- [`get_votes(self, account, timepoint, params)`](#GovernorVotesQuorumFractionComponent-get_votes)

Embeddable implementations

QuorumFractionImpl

- [`token(self)`](#GovernorVotesQuorumFractionComponent-token)
- [`current_quorum_numerator(self)`](#GovernorVotesQuorumFractionComponent-current_quorum_numerator)
- [`quorum_numerator(self, timepoint)`](#GovernorVotesQuorumFractionComponent-quorum_numerator)
- [`quorum_denominator(self)`](#GovernorVotesQuorumFractionComponent-quorum_denominator)

Internal implementations

InternalImpl

- [`initializer(self, votes_token, quorum_numerator)`](#GovernorVotesQuorumFractionComponent-initializer)
- [`update_quorum_numerator(self, new_quorum_numerator)`](#GovernorVotesQuorumFractionComponent-update_quorum_numerator)

Events

- [`QuorumNumeratorUpdated(old_quorum_numerator, new_quorum_numerator)`](#GovernorVotesQuorumFractionComponent-QuorumNumeratorUpdated)

#### [](#GovernorVotesQuorumFractionComponent-Extension-Traits-Functions)Extension traits functions

#### [](#GovernorVotesQuorumFractionComponent-quorum)`quorum(self: @ContractState, timepoint: u64) → u256` internal

It is computed as a percentage of the votes token total supply at a given `timepoint` in the past.

#### [](#GovernorVotesQuorumFractionComponent-clock)`clock(self: @ContractState) → u64` internal

Returns the current timepoint determined by the governor’s operational mode, intended for use in time-sensitive logic. See [ERC-6372#clock](https://eips.ethereum.org/EIPS/eip-6372#clock).

Requirements:

- This function MUST always be non-decreasing.

#### [](#GovernorVotesQuorumFractionComponent-CLOCK_MODE)`CLOCK_MODE(self: @ContractState) → ByteArray` internal

Returns a description of the clock the governor is operating in. See [ERC-6372#CLOCK\_MODE](https://eips.ethereum.org/EIPS/eip-6372#clock_mode).

Requirements:

- The output MUST be formatted like a URL query string, decodable in standard JavaScript.

#### [](#GovernorVotesQuorumFractionComponent-get_votes)`get_votes(self: @ContractState, account: ContractAddress, timepoint: u64, params: Span<felt252>) → u256` internal

Returns the voting power of `account` at a specific `timepoint` using the votes token.

#### [](#GovernorVotesQuorumFractionComponent-Embeddable-Functions)Embeddable functions

#### [](#GovernorVotesQuorumFractionComponent-token)`token(self: @ContractState) → ContractAddress` external

Returns the address of the votes token used for voting power extraction.

#### [](#GovernorVotesQuorumFractionComponent-current_quorum_numerator)`current_quorum_numerator(self: @ContractState) → u256` external

Returns the current quorum numerator value.

#### [](#GovernorVotesQuorumFractionComponent-quorum_numerator)`quorum_numerator(self: @ContractState, timepoint: u64) → u256` external

Returns the quorum numerator value at a specific `timepoint` in the past.

#### [](#GovernorVotesQuorumFractionComponent-quorum_denominator)`quorum_denominator(self: @ContractState) → u256` external

Returns the quorum denominator value.

#### [](#GovernorVotesQuorumFractionComponent-Internal-Functions)Internal functions

#### [](#GovernorVotesQuorumFractionComponent-initializer)`initializer(self: @ComponentState<TContractState>, votes_token: ContractAddress, quorum_numerator: u256)` internal

Initializes the component by setting the votes token and the initial quorum numerator value.

Requirements:

- `votes_token` must not be zero.
- `quorum_numerator` must be less than `quorum_denominator`.

Emits a [QuorumNumeratorUpdated](#GovernorVotesQuorumFractionComponent-QuorumNumeratorUpdated) event.

#### [](#GovernorVotesQuorumFractionComponent-update_quorum_numerator)`update_quorum_numerator(self: @ComponentState<TContractState>, new_quorum_numerator: u256)` internal

Updates the quorum numerator.

This function does not emit an event if the new quorum numerator is the same as the old one.

Requirements:

- `new_quorum_numerator` must be less than `quorum_denominator`.

May emit a [QuorumNumeratorUpdated](#GovernorVotesQuorumFractionComponent-QuorumNumeratorUpdated) event.

#### [](#GovernorVotesQuorumFractionComponent-Events)Events

#### [](#GovernorVotesQuorumFractionComponent-QuorumNumeratorUpdated)`QuorumNumeratorUpdated(old_quorum_numerator: u256, new_quorum_numerator: u256)` event

Emitted when the quorum numerator is updated.

### [](#GovernorTimelockExecutionComponent)`GovernorTimelockExecutionComponent`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/governance/src/governor/extensions/governor_timelock_execution.cairo)

```cairo
use openzeppelin_governance::governor::extensions::GovernorTimelockExecutionComponent;
```

Extension of [GovernorComponent](#GovernorComponent) that binds the execution process to an instance of a contract implementing [TimelockControllerComponent](#TimelockControllerComponent). This adds a delay, enforced by the timelock to all successful proposals (in addition to the voting duration).

The Governor needs the [PROPOSER, EXECUTOR, and CANCELLER roles](../governance/timelock#roles) to work properly.

Using this model means the proposal will be operated by the timelock and not by the governor. Thus, the assets and permissions must be attached to the timelock. Any asset sent to the governor will be inaccessible from a proposal, unless executed via `Governor::relay`.

Setting up the timelock to have additional proposers or cancellers besides the governor is very risky, as it grants them the ability to: 1) execute operations as the timelock, and thus possibly performing operations or accessing funds that are expected to only be accessible through a vote, and 2) block governance proposals that have been approved by the voters, effectively executing a Denial of Service attack.

Extension traits implementations

GovernorExecution

- [`state(self, proposal_id)`](#GovernorTimelockExecutionComponent-state)
- [`executor(self)`](#GovernorTimelockExecutionComponent-executor)
- [`execute_operations(self, proposal_id, calls, description_hash)`](#GovernorTimelockExecutionComponent-execute_operations)
- [`queue_operations(self, proposal_id, calls, description_hash)`](#GovernorTimelockExecutionComponent-queue_operations)
- [`proposal_needs_queuing(self, proposal_id)`](#GovernorTimelockExecutionComponent-proposal_needs_queuing)
- [`cancel_operations(self, proposal_id, description_hash)`](#GovernorTimelockExecutionComponent-cancel_operations)

Embeddable implementations

TimelockedImpl

- [`timelock(self)`](#GovernorTimelockExecutionComponent-timelock)
- [`get_timelock_id(self, proposal_id)`](#GovernorTimelockExecutionComponent-get_timelock_id)
- [`update_timelock(self, new_timelock)`](#GovernorTimelockExecutionComponent-update_timelock)

Internal implementations

InternalImpl

- [`initializer(self, timelock_controller)`](#GovernorTimelockExecutionComponent-initializer)
- [`assert_only_governance(self)`](#GovernorTimelockExecutionComponent-assert_only_governance)
- [`timelock_salt(self, description_hash)`](#GovernorTimelockExecutionComponent-timelock_salt)
- [`get_timelock_dispatcher(self)`](#GovernorTimelockExecutionComponent-get_timelock_dispatcher)
- [`_update_timelock(self, new_timelock)`](#GovernorTimelockExecutionComponent-_update_timelock)

Events

- [`TimelockUpdated(old_timelock, new_timelock)`](#GovernorTimelockExecutionComponent-TimelockUpdated)

#### [](#GovernorTimelockExecutionComponent-Extension-Traits-Functions)Extension traits functions

#### [](#GovernorTimelockExecutionComponent-state)`state(self: @ContractState, proposal_id: felt252) → ProposalState` internal

Returns the state of a proposal given its id.

Requirements:

- The proposal must exist.

#### [](#GovernorTimelockExecutionComponent-executor)`executor(self: @ContractState) → ContractAddress` internal

Returns the executor address.

In this module, the executor is the timelock controller.

#### [](#GovernorTimelockExecutionComponent-execute_operations)`execute_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252)` internal

Runs the already queued proposal through the timelock.

#### [](#GovernorTimelockExecutionComponent-queue_operations)`queue_operations(ref self: ContractState, proposal_id: felt252, calls: Span<Call>, description_hash: felt252) → u64` internal

Queue a proposal to the timelock.

Returns the eta for the execution of the queued proposal.

#### [](#GovernorTimelockExecutionComponent-proposal_needs_queuing)`proposal_needs_queuing(self: @ContractState, proposal_id: felt252) → bool` internal

In this implementation, it always returns true.

#### [](#GovernorTimelockExecutionComponent-cancel_operations)`cancel_operations(ref self: ContractState, proposal_id: felt252, description_hash: felt252)` internal

Cancels the timelocked proposal if it has already been queued.

#### [](#GovernorTimelockExecutionComponent-Embeddable-Functions)Embeddable functions

#### [](#GovernorTimelockExecutionComponent-timelock)`timelock(self: @ContractState) → ContractAddress` external

Returns the timelock controller address.

#### [](#GovernorTimelockExecutionComponent-get_timelock_id)`get_timelock_id(self: @ContractState) → felt252` external

Returns the timelock proposal id for a given proposal id.

#### [](#GovernorTimelockExecutionComponent-update_timelock)`update_timelock(ref self: ContractState, new_timelock: ContractAddress)` external

Updates the associated timelock.

Requirements:

- The caller must be the governance.

Emits a [TimelockUpdated](#GovernorTimelockExecutionComponent-TimelockUpdated) event.

#### [](#GovernorTimelockExecutionComponent-Internal-Functions)Internal functions

#### [](#GovernorTimelockExecutionComponent-initializer)`initializer(ref self: ContractState, timelock: ContractAddress)` internal

Initializes the timelock controller.

Requirements:

- The timelock must not be the zero address.

#### [](#GovernorTimelockExecutionComponent-assert_only_governance)`assert_only_governance(self: @ContractState)` internal

Ensures the caller is the executor (the timelock controller in this case).

#### [](#GovernorTimelockExecutionComponent-timelock_salt)`timelock_salt(self: @ContractState, description_hash: felt252) → felt252` internal

Computes the `TimelockController` operation salt as the XOR of the governor address and `description_hash`.

It is computed with the governor address itself to avoid collisions across governor instances using the same timelock.

#### [](#GovernorTimelockExecutionComponent-get_timelock_dispatcher)`get_timelock_dispatcher(self: @ContractState) → ITimelockDispatcher` internal

Returns a dispatcher for interacting with the timelock controller.

#### [](#GovernorTimelockExecutionComponent-_update_timelock)`_update_timelock(ref self: ContractState, new_timelock: ContractAddress)` internal

Internal function to update the timelock controller address.

Emits a [TimelockUpdated](#GovernorTimelockExecutionComponent-TimelockUpdated) event.

#### [](#GovernorTimelockExecutionComponent-Events)Events

#### [](#GovernorTimelockExecutionComponent-TimelockUpdated)`TimelockUpdated(old_timelock: ContractAddress, new_timelock: ContractAddress)` event

Emitted when the timelock controller is updated.

## [](#multisig)Multisig

A Multisig module enhances security and decentralization by requiring multiple signers to approve and execute transactions. Features include configurable quorum, signer management, and self-administration, ensuring collective decision-making and transparency for critical operations.

### [](#MultisigComponent)`MultisigComponent`

```cairo
use openzeppelin_governance::multisig::MultisigComponent;
```

Component that implements [IMultisig](#IMultisig) and provides functionality for multisignature wallets, including transaction management, quorum handling, and signer operations.

Embeddable Implementations

MultisigImpl

- [`get_quorum(self)`](#MultisigComponent-get_quorum)
- [`is_signer(self, signer)`](#MultisigComponent-is_signer)
- [`get_signers(self)`](#MultisigComponent-get_signers)
- [`is_confirmed(self, id)`](#MultisigComponent-is_confirmed)
- [`is_confirmed_by(self, id, signer)`](#MultisigComponent-is_confirmed_by)
- [`is_executed(self, id)`](#MultisigComponent-is_executed)
- [`get_submitted_block(self, id)`](#MultisigComponent-get_submitted_block)
- [`get_transaction_state(self, id)`](#MultisigComponent-get_transaction_state)
- [`get_transaction_confirmations(self, id)`](#MultisigComponent-get_transaction_confirmations)
- [`hash_transaction(self, to, selector, calldata, salt)`](#MultisigComponent-hash_transaction)
- [`hash_transaction_batch(self, calls, salt)`](#MultisigComponent-hash_transaction_batch)
- [`add_signers(ref self, new_quorum, signers_to_add)`](#MultisigComponent-add_signers)
- [`remove_signers(ref self, new_quorum, signers_to_remove)`](#MultisigComponent-remove_signers)
- [`replace_signer(ref self, signer_to_remove, signer_to_add)`](#MultisigComponent-replace_signer)
- [`change_quorum(ref self, new_quorum)`](#MultisigComponent-change_quorum)
- [`submit_transaction(ref self, to, selector, calldata, salt)`](#MultisigComponent-submit_transaction)
- [`submit_transaction_batch(ref self, calls, salt)`](#MultisigComponent-submit_transaction_batch)
- [`confirm_transaction(ref self, id)`](#MultisigComponent-confirm_transaction)
- [`revoke_confirmation(ref self, id)`](#MultisigComponent-revoke_confirmation)
- [`execute_transaction(ref self, to, selector, calldata, salt)`](#MultisigComponent-execute_transaction)
- [`execute_transaction_batch(ref self, calls, salt)`](#MultisigComponent-execute_transaction_batch)

Internal Implementations

InternalImpl

- [`initializer(ref self, quorum, signers)`](#MultisigComponent-initializer)
- [`resolve_tx_state(self, id)`](#MultisigComponent-resolve_tx_state)
- [`assert_one_of_signers(self, caller)`](#MultisigComponent-assert_one_of_signers)
- [`assert_tx_exists(self, id)`](#MultisigComponent-assert_tx_exists)
- [`assert_only_self(self)`](#MultisigComponent-assert_only_self)
- [`_add_signers(ref self, new_quorum, signers_to_add)`](#MultisigComponent-_add_signers)
- [`_remove_signers(ref self, new_quorum, signers_to_remove)`](#MultisigComponent-_remove_signers)
- [`_replace_signer(ref self, signer_to_remove, signer_to_add)`](#MultisigComponent-_replace_signer)
- [`_change_quorum(ref self, new_quorum)`](#MultisigComponent-_change_quorum)

Events

- [`SignerAdded(signer)`](#MultisigComponent-SignerAdded)
- [`SignerRemoved(signer)`](#MultisigComponent-SignerRemoved)
- [`QuorumUpdated(old_quorum, new_quorum)`](#MultisigComponent-QuorumUpdated)
- [`TransactionSubmitted(id, signer)`](#MultisigComponent-TransactionSubmitted)
- [`TransactionConfirmed(id, signer)`](#MultisigComponent-TransactionConfirmed)
- [`ConfirmationRevoked(id, signer)`](#MultisigComponent-ConfirmationRevoked)
- [`TransactionExecuted(id)`](#MultisigComponent-TransactionExecuted)
- [`CallSalt(id, salt)`](#MultisigComponent-CallSalt)

#### [](#MultisigComponent-Functions)Embeddable functions

#### [](#MultisigComponent-get_quorum)`get_quorum(self: @ContractState) → u32` external

Returns the current quorum value.

#### [](#MultisigComponent-is_signer)`is_signer(self: @ContractState, signer: ContractAddress) → bool` external

Checks if a given `signer` is registered.

#### [](#MultisigComponent-get_signers)`get_signers(self: @ContractState) → Span<ContractAddress>` external

Returns a list of all current signers.

#### [](#MultisigComponent-is_confirmed)`is_confirmed(self: @ContractState, id: TransactionID) → bool` external

Returns whether the transaction with the given `id` has been confirmed. A confirmed transaction has received the required number of confirmations (quorum).

#### [](#MultisigComponent-is_confirmed_by)`is_confirmed_by(self: @ContractState, id: TransactionID, signer: ContractAddress) → bool` external

Returns whether the transaction with the given `id` has been confirmed by the specified `signer`.

#### [](#MultisigComponent-is_executed)`is_executed(self: @ContractState, id: TransactionID) → bool` external

Returns whether the transaction with the given `id` has been executed.

#### [](#MultisigComponent-get_submitted_block)`get_submitted_block(self: @ContractState, id: TransactionID) → u64` external

Returns the block number when the transaction with the given `id` was submitted.

#### [](#MultisigComponent-get_transaction_state)`get_transaction_state(self: @ContractState, id: TransactionID) → TransactionState` external

Returns the current state of the transaction with the given `id`.

The possible states are:

- `NotFound`: the transaction does not exist.
- `Pending`: the transaction exists but hasn’t reached the required confirmations.
- `Confirmed`: the transaction has reached the required confirmations but hasn’t been executed.
- `Executed`: the transaction has been executed.

#### [](#MultisigComponent-get_transaction_confirmations)`get_transaction_confirmations(self: @ContractState, id: TransactionID) → u32` external

Returns the number of confirmations from registered signers for the transaction with the specified `id`.

#### [](#MultisigComponent-hash_transaction)`hash_transaction(self: @ContractState, to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)` external

Returns the computed identifier of a transaction containing a single call.

#### [](#MultisigComponent-hash_transaction_batch)`hash_transaction_batch(self: @ContractState, calls: Span<Call>, salt: felt252)` external

Returns the computed identifier of a transaction containing a batch of calls.

#### [](#MultisigComponent-add_signers)`add_signers(ref self: ContractState, new_quorum: u32, signers_to_add: Span<ContractAddress>)` external

Adds new signers and updates the quorum.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be less than or equal to the total number of signers after addition.

Emits a [SignerAdded](#MultisigComponent-SignerAdded) event for each signer added.

Emits a [QuorumUpdated](#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### [](#MultisigComponent-remove_signers)`remove_signers(ref self: ContractState, new_quorum: u32, signers_to_remove: Span<ContractAddress>)` external

Removes signers and updates the quorum.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be less than or equal to the total number of signers after removal.

Emits a [SignerRemoved](#MultisigComponent-SignerRemoved) event for each signer removed.

Emits a [QuorumUpdated](#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### [](#MultisigComponent-replace_signer)`replace_signer(ref self: ContractState, signer_to_remove: ContractAddress, signer_to_add: ContractAddress)` external

Replaces an existing signer with a new signer.

Requirements:

- The caller must be the contract itself.
- `signer_to_remove` must be an existing signer.
- `signer_to_add` must not be an existing signer.

Emits a [SignerRemoved](#MultisigComponent-SignerRemoved) event for the removed signer.

Emits a [SignerAdded](#MultisigComponent-SignerAdded) event for the new signer.

#### [](#MultisigComponent-change_quorum)`change_quorum(ref self: ContractState, new_quorum: u32)` external

Updates the quorum value to `new_quorum`.

Requirements:

- The caller must be the contract itself.
- `new_quorum` must be non-zero.
- `new_quorum` must be less than or equal to the total number of signers.

Emits a [QuorumUpdated](#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### [](#MultisigComponent-submit_transaction)`submit_transaction(ref self: ContractState, to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)` external

Submits a new transaction for confirmation.

Requirements:

- The caller must be a registered signer.
- The transaction must not have been submitted before.

Emits a [TransactionSubmitted](#MultisigComponent-TransactionSubmitted) event.

Emits a [CallSalt](#MultisigComponent-CallSalt) event if `salt` is not zero.

#### [](#MultisigComponent-submit_transaction_batch)`submit_transaction_batch(ref self: ContractState, calls: Span<Call>, salt: felt252)` external

Submits a new batch transaction for confirmation.

Requirements:

- The caller must be a registered signer.
- The transaction must not have been submitted before.

Emits a [TransactionSubmitted](#MultisigComponent-TransactionSubmitted) event.

Emits a [CallSalt](#MultisigComponent-CallSalt) event if `salt` is not zero.

#### [](#MultisigComponent-confirm_transaction)`confirm_transaction(ref self: ContractState, id: TransactionID)` external

Confirms a transaction with the given `id`.

Requirements:

- The caller must be a registered signer.
- The transaction must exist and not be executed.
- The caller must not have already confirmed the transaction.

Emits a [TransactionConfirmed](#MultisigComponent-TransactionConfirmed) event.

#### [](#MultisigComponent-revoke_confirmation)`revoke_confirmation(ref self: ContractState, id: TransactionID)` external

Revokes a previous confirmation for a transaction with the given `id`.

Requirements:

- The transaction must exist and not be executed.
- The caller must have previously confirmed the transaction.

Emits a [ConfirmationRevoked](#MultisigComponent-ConfirmationRevoked) event.

#### [](#MultisigComponent-execute_transaction)`execute_transaction(ref self: ContractState, to: ContractAddress, selector: felt252, calldata: Span<felt252>, salt: felt252)` external

Executes a confirmed transaction.

Requirements:

- The caller must be a registered signer.
- The transaction must be confirmed and not yet executed.

Emits a [TransactionExecuted](#MultisigComponent-TransactionExecuted) event.

#### [](#MultisigComponent-execute_transaction_batch)`execute_transaction_batch(ref self: ContractState, calls: Span<Call>, salt: felt252)` external

Executes a confirmed batch transaction.

Requirements:

- The caller must be a registered signer.
- The transaction must be confirmed and not yet executed.

Emits a [TransactionExecuted](#MultisigComponent-TransactionExecuted) event.

#### [](#MultisigComponent-Internal-Functions)Internal functions

#### [](#MultisigComponent-initializer)`initializer(ref self: ContractState, quorum: u32, signers: Span<ContractAddress>)` internal

Initializes the Multisig component with the initial `quorum` and `signers`. This function must be called during contract initialization to set up the initial state.

Requirements:

- `quorum` must be non-zero and less than or equal to the number of `signers`.

Emits a [SignerAdded](#MultisigComponent-SignerAdded) event for each signer added.

Emits a [QuorumUpdated](#MultisigComponent-QuorumUpdated) event.

#### [](#MultisigComponent-resolve_tx_state)`resolve_tx_state(self: @ContractState, id: TransactionID) → TransactionState` internal

Resolves and returns the current state of the transaction with the given `id`.

The possible states are:

- `NotFound`: the transaction does not exist.
- `Pending`: the transaction exists but hasn’t reached the required confirmations.
- `Confirmed`: the transaction has reached the required confirmations but hasn’t been executed.
- `Executed`: the transaction has been executed.

#### [](#MultisigComponent-assert_one_of_signers)`assert_one_of_signers(self: @ContractState, caller: ContractAddress)` internal

Asserts that the `caller` is one of the registered signers.

Requirements:

- The `caller` must be a registered signer.

#### [](#MultisigComponent-assert_tx_exists)`assert_tx_exists(self: @ContractState, id: TransactionID)` internal

Asserts that a transaction with the given `id` exists.

Requirements:

- The transaction with the given `id` must have been submitted.

#### [](#MultisigComponent-assert_only_self)`assert_only_self(self: @ContractState)` internal

Asserts that the caller is the contract itself.

Requirements:

- The caller must be the contract’s own address.

#### [](#MultisigComponent-_add_signers)`_add_signers(ref self: ContractState, new_quorum: u32, signers_to_add: Span<ContractAddress>)` internal

Adds new signers and updates the quorum.

Requirements:

- Each signer address must be non-zero.
- `new_quorum` must be non-zero and less than or equal to the total number of signers after addition.

Emits a [SignerAdded](#MultisigComponent-SignerAdded) event for each new signer added.

Emits a [QuorumUpdated](#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### [](#MultisigComponent-_remove_signers)`_remove_signers(ref self: ContractState, new_quorum: u32, signers_to_remove: Span<ContractAddress>)` internal

Removes existing signers and updates the quorum.

Requirements:

- `new_quorum` must be non-zero and less than or equal to the total number of signers after removal.

Emits a [SignerRemoved](#MultisigComponent-SignerRemoved) event for each signer removed.

Emits a [QuorumUpdated](#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### [](#MultisigComponent-_replace_signer)`_replace_signer(ref self: ContractState, signer_to_remove: ContractAddress, signer_to_add: ContractAddress)` internal

Replaces an existing signer with a new signer.

Requirements:

- `signer_to_remove` must be an existing signer.
- `signer_to_add` must not be an existing signer.
- `signer_to_add` must be a non-zero address.

Emits a [SignerRemoved](#MultisigComponent-SignerRemoved) event for the removed signer.

Emits a [SignerAdded](#MultisigComponent-SignerAdded) event for the new signer.

#### [](#MultisigComponent-_change_quorum)`_change_quorum(ref self: ContractState, new_quorum: u32)` internal

Updates the quorum value to `new_quorum` if it differs from the current quorum.

Requirements:

- `new_quorum` must be non-zero.
- `new_quorum` must be less than or equal to the total number of signers.

Emits a [QuorumUpdated](#MultisigComponent-QuorumUpdated) event if the quorum changes.

#### [](#MultisigComponent-Events)Events

#### [](#MultisigComponent-SignerAdded)`SignerAdded(signer: ContractAddress)` event

Emitted when a new `signer` is added.

#### [](#MultisigComponent-SignerRemoved)`SignerRemoved(signer: ContractAddress)` event

Emitted when a `signer` is removed.

#### [](#MultisigComponent-QuorumUpdated)`QuorumUpdated(old_quorum: u32, new_quorum: u32)` event

Emitted when the `quorum` value is updated.

#### [](#MultisigComponent-TransactionSubmitted)`TransactionSubmitted(id: TransactionID, signer: ContractAddress)` event

Emitted when a new transaction is submitted by a `signer`.

#### [](#MultisigComponent-TransactionConfirmed)`TransactionConfirmed(id: TransactionID, signer: ContractAddress)` event

Emitted when a transaction is confirmed by a `signer`.

#### [](#MultisigComponent-ConfirmationRevoked)`ConfirmationRevoked(id: TransactionID, signer: ContractAddress)` event

Emitted when a `signer` revokes his confirmation.

#### [](#MultisigComponent-TransactionExecuted)`TransactionExecuted(id: TransactionID)` event

Emitted when a transaction is executed.

#### [](#MultisigComponent-CallSalt)`CallSalt(id: felt252, salt: felt252)` event

Emitted when a new transaction is submitted with non-zero salt.

## [](#timelock)Timelock

In a governance system, `TimelockControllerComponent` is in charge of introducing a delay between a proposal and its execution.

### [](#TimelockControllerComponent)`TimelockControllerComponent`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/governance/src/timelock/timelock_controller.cairo)

```cairo
use openzeppelin_governance::timelock::TimelockControllerComponent;
```

Component that implements [ITimelock](#ITimelock) and enables the implementing contract to act as a timelock controller.

[Embeddable Mixin Implementations](../components#mixins)

TimelockMixinImpl

- [`TimelockImpl`](#TimelockControllerComponent-Embeddable-Impls-TimelockImpl)
- [`SRC5Impl`](introspection#SRC5Component-Embeddable-Impls)
- [`AccessControlImpl`](access#AccessControlComponent-Embeddable-Impls)
- [`AccessControlCamelImpl`](access#AccessControlComponent-Embeddable-Impls)

Embeddable Implementations

TimelockImpl

- [`is_operation(self, id)`](#TimelockControllerComponent-is_operation)
- [`is_operation_pending(self, id)`](#TimelockControllerComponent-is_operation_pending)
- [`is_operation_ready(self, id)`](#TimelockControllerComponent-is_operation_ready)
- [`is_operation_done(self, id)`](#TimelockControllerComponent-is_operation_done)
- [`get_timestamp(self, id)`](#TimelockControllerComponent-get_timestamp)
- [`get_operation_state(self, id)`](#TimelockControllerComponent-get_operation_state)
- [`get_min_delay(self)`](#TimelockControllerComponent-get_min_delay)
- [`hash_operation(self, call, predecessor, salt)`](#TimelockControllerComponent-hash_operation)
- [`hash_operation_batch(self, calls, predecessor, salt)`](#TimelockControllerComponent-hash_operation_batch)
- [`schedule(self, call, predecessor, salt, delay)`](#TimelockControllerComponent-schedule)
- [`schedule_batch(self, calls, predecessor, salt, delay)`](#TimelockControllerComponent-schedule_batch)
- [`cancel(self, id)`](#TimelockControllerComponent-cancel)
- [`execute(self, call, predecessor, salt)`](#TimelockControllerComponent-execute)
- [`execute_batch(self, calls, predecessor, salt)`](#TimelockControllerComponent-execute_batch)
- [`update_delay(self, new_delay)`](#TimelockControllerComponent-update_delay)

SRC5Impl

- [`supports_interface(self, interface_id: felt252)`](introspection#ISRC5-supports_interface)

AccessControlImpl

- [`has_role(self, role, account)`](access#IAccessControl-has_role)
- [`get_role_admin(self, role)`](access#IAccessControl-get_role_admin)
- [`grant_role(self, role, account)`](access#IAccessControl-grant_role)
- [`revoke_role(self, role, account)`](access#IAccessControl-revoke_role)
- [`renounce_role(self, role, account)`](access#IAccessControl-renounce_role)

AccessControlCamelImpl

- [`hasRole(self, role, account)`](access#IAccessControl-hasRole)
- [`getRoleAdmin(self, role)`](access#IAccessControl-getRoleAdmin)
- [`grantRole(self, role, account)`](access#IAccessControl-grantRole)
- [`revokeRole(self, role, account)`](access#IAccessControl-revokeRole)
- [`renounceRole(self, role, account)`](access#IAccessControl-renounceRole)

Internal Implementations

InternalImpl

- [`initializer(self, min_delay, proposers, executors, admin)`](#TimelockControllerComponent-initializer)
- [`assert_only_role(self, role)`](#TimelockControllerComponent-assert_only_role)
- [`assert_only_role_or_open_role(self, role)`](#TimelockControllerComponent-assert_only_role_or_open_role)
- [`assert_only_self(self)`](#TimelockControllerComponent-assert_only_self)
- [`_before_call(self, id, predecessor)`](#TimelockControllerComponent-_before_call)
- [`_after_call(self, id)`](#TimelockControllerComponent-_after_call)
- [`_schedule(self, id, delay)`](#TimelockControllerComponent-_schedule)
- [`_execute(self, call)`](#TimelockControllerComponent-_execute)

Events

- [`CallScheduled(id, index, call, predecessor, delay)`](#TimelockControllerComponent-CallScheduled)
- [`CallExecuted(id, index, call)`](#TimelockControllerComponent-CallExecuted)
- [`CallSalt(id, salt)`](#TimelockControllerComponent-CallSalt)
- [`CallCancelled(id)`](#TimelockControllerComponent-CallCancelled)
- [`MinDelayChanged(old_duration, new_duration)`](#TimelockControllerComponent-MinDelayChanged)

#### [](#TimelockControllerComponent-Functions)Embeddable functions

#### [](#TimelockControllerComponent-is_operation)`is_operation(self: @ContractState, id: felt252) → bool` external

Returns whether `id` corresponds to a registered operation. This includes the OperationStates: `Waiting`, `Ready`, and `Done`.

#### [](#TimelockControllerComponent-is_operation_pending)`is_operation_pending(self: @ContractState, id: felt252) → bool` external

Returns whether the `id` OperationState is pending or not. Note that a pending operation may be either `Waiting` or `Ready`.

#### [](#TimelockControllerComponent-is_operation_ready)`is_operation_ready(self: @ContractState, id: felt252) → bool` external

Returns whether the `id` OperationState is `Ready` or not.

#### [](#TimelockControllerComponent-is_operation_done)`is_operation_done(self: @ContractState, id: felt252) → bool` external

Returns whether the `id` OperationState is `Done` or not.

#### [](#TimelockControllerComponent-get_timestamp)`get_timestamp(self: @ContractState, id: felt252) → u64` external

Returns the timestamp at which `id` becomes `Ready`.

`0` means the OperationState is `Unset` and `1` means the OperationState is `Done`.

#### [](#TimelockControllerComponent-get_operation_state)`get_operation_state(self: @ContractState, id: felt252) → OperationState` external

Returns the current state of the operation with the given `id`.

The possible states are:

- `Unset`: the operation has not been scheduled or has been canceled.
- `Waiting`: the operation has been scheduled and is pending the scheduled delay.
- `Ready`: the timer has expired, and the operation is eligible for execution.
- `Done`: the operation has been executed.

#### [](#TimelockControllerComponent-get_min_delay)`get_min_delay(self: @ContractState) → u64` external

Returns the minimum delay in seconds for an operation to become valid. This value can be changed by executing an operation that calls `update_delay`.

#### [](#TimelockControllerComponent-hash_operation)`hash_operation(self: @ContractState, call: Call, predecessor: felt252, salt: felt252)` external

Returns the identifier of an operation containing a single transaction.

#### [](#TimelockControllerComponent-hash_operation_batch)`hash_operation_batch(self: @ContractState, calls: Span<Call>, predecessor: felt252, salt: felt252)` external

Returns the identifier of an operation containing a batch of transactions.

#### [](#TimelockControllerComponent-schedule)`schedule(ref self: ContractState, call: Call, predecessor: felt252, salt: felt252, delay: u64)` external

Schedule an operation containing a single transaction.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.
- The proposal must not already exist.
- `delay` must be greater than or equal to the min delay.

Emits [CallScheduled](#TimelockControllerComponent-CallScheduled) event. Emits [CallSalt](#TimelockControllerComponent-CallSalt) event if `salt` is not zero.

#### [](#TimelockControllerComponent-schedule_batch)`schedule_batch(ref self: ContractState, calls: Span<Call>, predecessor: felt252, salt: felt252, delay: u64)` external

Schedule an operation containing a batch of transactions.

Requirements:

- The caller must have the `PROPOSER_ROLE` role.
- The proposal must not already exist.
- `delay` must be greater than or equal to the min delay.

Emits one [CallScheduled](#TimelockControllerComponent-CallScheduled) event for each transaction in the batch. Emits [CallSalt](#TimelockControllerComponent-CallSalt) event if `salt` is not zero.

#### [](#TimelockControllerComponent-cancel)`cancel(ref self: ContractState, id: felt252)` external

Cancels an operation. A canceled operation returns to `Unset` OperationState.

Requirements:

- The caller must have the `CANCELLER_ROLE` role.
- `id` must be a pending operation.

Emits a [CallCancelled](#TimelockControllerComponent-CallCancelled) event.

#### [](#TimelockControllerComponent-execute)`execute(ref self: ContractState, call: Call, predecessor: felt252, salt: felt252)` external

Execute a (Ready) operation containing a single Call.

Requirements:

- Caller must have `EXECUTOR_ROLE`.
- `id` must be in Ready OperationState.
- `predecessor` must either be `0` or in Done OperationState.

Emits a [CallExecuted](#TimelockControllerComponent-CallExecuted) event.

This function can reenter, but it doesn’t pose a risk because [`_after_call(self: @ContractState, id: felt252)` internal](#TimelockControllerComponent-_after_call) checks that the proposal is pending, thus any modifications to the operation during reentrancy should be caught.

#### [](#TimelockControllerComponent-execute_batch)`execute_batch(ref self: ContractState, calls: Span<Call>, predecessor: felt252, salt: felt252)` external

Execute a (Ready) operation containing a batch of Calls.

Requirements:

- Caller must have `EXECUTOR_ROLE`.
- `id` must be in Ready OperationState.
- `predecessor` must either be `0` or in Done OperationState.

Emits a [CallExecuted](#TimelockControllerComponent-CallExecuted) event for each Call.

This function can reenter, but it doesn’t pose a risk because `_after_call` checks that the proposal is pending, thus any modifications to the operation during reentrancy should be caught.

#### [](#TimelockControllerComponent-update_delay)`update_delay(ref self: ContractState, new_delay: u64)` external

Changes the minimum timelock duration for future operations.

Requirements:

- The caller must be the timelock itself. This can only be achieved by scheduling and later executing an operation where the timelock is the target and the data is the serialized call to this function.

Emits a [MinDelayChanged](#TimelockControllerComponent-MinDelayChanged) event.

#### [](#TimelockControllerComponent-Internal-Functions)Internal functions

#### [](#TimelockControllerComponent-initializer)`initializer(ref self: ContractState, min_delay: u64, proposers: Span<ContractAddress>, executors: Span<ContractState>, admin: ContractAddress)` internal

Initializes the contract by registering support for SRC5 and AccessControl.

This function also configures the contract with the following parameters:

- `min_delay`: initial minimum delay in seconds for operations.
- `proposers`: accounts to be granted proposer and canceller roles.
- `executors`: accounts to be granted executor role.
- `admin`: optional account to be granted admin role; disable with zero address.

The optional admin can aid with initial configuration of roles after deployment without being subject to delay, but this role should be subsequently renounced in favor of administration through timelocked proposals.

Emits two [IAccessControl::RoleGranted](access#IAccessControl-RoleGranted) events for each account in `proposers` with `PROPOSER_ROLE` and `CANCELLER_ROLE` roles.

Emits a [IAccessControl::RoleGranted](access#IAccessControl-RoleGranted) event for each account in `executors` with `EXECUTOR_ROLE` role.

May emit a [IAccessControl::RoleGranted](access#IAccessControl-RoleGranted) event for `admin` with `DEFAULT_ADMIN_ROLE` role (if `admin` is not zero).

Emits [MinDelayChanged](#TimelockControllerComponent-MinDelayChanged) event.

#### [](#TimelockControllerComponent-assert_only_role)`assert_only_role(self: @ContractState, role: felt252)` internal

Validates that the caller has the given `role`. Otherwise it panics.

#### [](#TimelockControllerComponent-assert_only_role_or_open_role)`assert_only_role_or_open_role(self: @ContractState, role: felt252)` internal

Validates that the caller has the given `role`. If `role` is granted to the zero address, then this is considered an open role which allows anyone to be the caller.

#### [](#TimelockControllerComponent-assert_only_self)`assert_only_self(self: @ContractState)` internal

Validates that the caller is the timelock contract itself. Otherwise it panics.

#### [](#TimelockControllerComponent-_before_call)`_before_call(self: @ContractState, id: felt252, predecessor: felt252)` internal

Private function that checks before execution of an operation’s calls.

Requirements:

- `id` must be in the `Ready` OperationState.
- `predecessor` must either be zero or be in the `Done` OperationState.

#### [](#TimelockControllerComponent-_after_call)`_after_call(self: @ContractState, id: felt252)` internal

Private function that checks after execution of an operation’s calls and sets the OperationState of `id` to `Done`.

Requirements:

- `id` must be in the Ready OperationState.

#### [](#TimelockControllerComponent-_schedule)`_schedule(ref self: ContractState, id: felt252, delay: u64)` internal

Private function that schedules an operation that is to become valid after a given `delay`.

#### [](#TimelockControllerComponent-_execute)`_execute(ref self: ContractState, call: Call)` internal

Private function that executes an operation’s calls.

#### [](#TimelockControllerComponent-Events)Events

#### [](#TimelockControllerComponent-CallScheduled)`CallScheduled(id: felt252, index: felt252, call: Call, predecessor: felt252, delay: u64)` event

Emitted when `call` is scheduled as part of operation `id`.

#### [](#TimelockControllerComponent-CallExecuted)`CallExecuted(id: felt252, index: felt252, call: Call)` event

Emitted when `call` is performed as part of operation `id`.

#### [](#TimelockControllerComponent-CallSalt)`CallSalt(id: felt252, salt: felt252)` event

Emitted when a new proposal is scheduled with non-zero salt.

#### [](#TimelockControllerComponent-CallCancelled)`CallCancelled(id: felt252)` event

Emitted when operation `id` is cancelled.

#### [](#TimelockControllerComponent-MinDelayChanged)`MinDelayChanged(old_duration: u64, new_duration: u64)` event

Emitted when the minimum delay for future operations is modified.

## [](#votes)Votes

The `VotesComponent` provides a flexible system for tracking and delegating voting power. This system allows users to delegate their voting power to other addresses, enabling more active participation in governance.

### [](#VotesComponent)`VotesComponent`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/governance/src/votes/votes.cairo)

```cairo
use openzeppelin_governance::votes::VotesComponent;
```

Component that implements the [IVotes](#IVotes) interface and provides a flexible system for tracking and delegating voting power.

By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.

When using this module, your contract must implement the [VotingUnitsTrait](#VotingUnitsTrait). For convenience, this is done automatically for `ERC20` and `ERC721` tokens.

Voting Units Trait Implementations

ERC20VotesImpl

- [`get_voting_units(self, account)`](#VotesComponent-ERC20VotesImpl-get_voting_units)

ERC721VotesImpl

- [`get_voting_units(self, account)`](#VotesComponent-ERC721VotesImpl-get_voting_units)

Embeddable Implementations

VotesImpl

- [`get_votes(self, account)`](#VotesComponent-get_votes)
- [`get_past_votes(self, account, timepoint)`](#VotesComponent-get_past_votes)
- [`get_past_total_supply(self, timepoint)`](#VotesComponent-get_past_total_supply)
- [`delegates(self, account)`](#VotesComponent-delegates)
- [`delegate(self, delegatee)`](#VotesComponent-delegate)
- [`delegate_by_sig(self, delegator, delegatee, nonce, expiry, signature)`](#VotesComponent-delegate_by_sig)
- [`clock(self)`](#VotesComponent-clock)
- [`CLOCK_MODE(self)`](#VotesComponent-CLOCK_MODE)

Internal implementations

InternalImpl

- [`get_total_supply(self)`](#VotesComponent-get_total_supply)
- [`move_delegate_votes(self, from, to, amount)`](#VotesComponent-move_delegate_votes)
- [`transfer_voting_units(self, from, to, amount)`](#VotesComponent-transfer_voting_units)
- [`num_checkpoints(self, account)`](#VotesComponent-num_checkpoints)
- [`checkpoints(self, account, pos)`](#VotesComponent-checkpoints)
- [`_delegate(self, account, delegatee)`](#VotesComponent-_delegate)

Events

- [`DelegateChanged(delegator, from_delegate, to_delegate)`](#VotesComponent-DelegateChanged)
- [`DelegateVotesChanged(delegate, previous_votes, new_votes)`](#VotesComponent-DelegateVotesChanged)

#### [](#VotesComponent-ERC20VotesImpl)ERC20VotesImpl

#### [](#VotesComponent-ERC20VotesImpl-get_voting_units)`get_voting_units(self: @ContractState, account: ContractAddress) → u256` internal

Returns the number of voting units for a given account.

This implementation is specific to ERC20 tokens, where the balance of tokens directly represents the number of voting units.

This implementation will work out of the box if the ERC20 component is implemented in the final contract.

This implementation assumes tokens map to voting units 1:1. Any deviation from this formula when transferring voting units (e.g. by using hooks) may compromise the internal vote accounting.

#### [](#VotesComponent-ERC721VotesImpl)ERC721VotesImpl

#### [](#VotesComponent-ERC721VotesImpl-get_voting_units)`get_voting_units(self: @ContractState, account: ContractAddress) → u256` internal

Returns the number of voting units for a given account.

This implementation is specific to ERC721 tokens, where each token represents one voting unit. The function returns the balance of ERC721 tokens for the specified account.

This implementation will work out of the box if the ERC721 component is implemented in the final contract.

This implementation assumes tokens map to voting units 1:1. Any deviation from this formula when transferring voting units (e.g. by using hooks) may compromise the internal vote accounting.

#### [](#VotesComponent-Functions)Embeddable functions

#### [](#VotesComponent-get_votes)`get_votes(self: @ContractState, account: ContractAddress) → u256` external

Returns the current amount of votes that `account` has.

#### [](#VotesComponent-get_past_votes)`get_past_votes(self: @ContractState, account: ContractAddress, timepoint: u64) → u256` external

Returns the amount of votes that `account` had at a specific moment in the past.

Requirements:

- `timepoint` must be in the past.

#### [](#VotesComponent-get_past_total_supply)`get_past_total_supply(self: @ContractState, timepoint: u64) → u256` external

Returns the total supply of votes available at a specific moment in the past.

This value is the sum of all available votes, which is not necessarily the sum of all delegated votes. Votes that have not been delegated are still part of total supply, even though they would not participate in a vote.

Requirements:

- `timepoint` must be in the past.

#### [](#VotesComponent-delegates)`delegates(self: @ContractState, account: ContractAddress) → ContractAddress` external

Returns the delegate that `account` has chosen.

#### [](#VotesComponent-delegate)`delegate(ref self: ContractState, delegatee: ContractAddress)` external

Delegates votes from the sender to `delegatee`.

Emits a [DelegateChanged](#VotesComponent-DelegateChanged) event.

May emit one or two [DelegateVotesChanged](#VotesComponent-DelegateVotesChanged) events.

#### [](#VotesComponent-delegate_by_sig)`delegate_by_sig(ref self: ContractState, delegator: ContractAddress, delegatee: ContractAddress, nonce: felt252, expiry: u64, signature: Span<felt252>)` external

Delegates votes from `delegator` to `delegatee` through a [SNIP-12](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md) message signature validation.

Requirements:

- `expiry` must not be in the past.
- `nonce` must match the account’s current nonce.
- `delegator` must implement `SRC6::is_valid_signature`.
- `signature` should be valid for the message hash.

Emits a [DelegateChanged](#VotesComponent-DelegateChanged) event.

May emit one or two [DelegateVotesChanged](#VotesComponent-DelegateVotesChanged) events.

#### [](#VotesComponent-clock)`clock(self: @ContractState) → u64` external

Returns the current timepoint determined by the contract’s operational mode, intended for use in time-sensitive logic. See [ERC-6372#clock](https://eips.ethereum.org/EIPS/eip-6372#clock).

Requirements:

- This function MUST always be non-decreasing.

#### [](#VotesComponent-CLOCK_MODE)`CLOCK_MODE(self: @ContractState) → u64` external

Returns a description of the clock the contract is operating in. See [ERC-6372#CLOCK\_MODE](https://eips.ethereum.org/EIPS/eip-6372#clock_mode).

Requirements:

- The output MUST be formatted like a URL query string, decodable in standard JavaScript.

#### [](#VotesComponent-Internal-functions)Internal functions

#### [](#VotesComponent-get_total_supply)`get_total_supply(self: @ContractState) → u256` internal

Returns the current total supply of votes.

#### [](#VotesComponent-move_delegate_votes)`move_delegate_votes(ref self: ContractState, from: ContractAddress, to: ContractAddress, amount: u256)` internal

Moves delegated votes from one delegate to another.

May emit one or two [DelegateVotesChanged](#VotesComponent-DelegateVotesChanged) events.

#### [](#VotesComponent-transfer_voting_units)`transfer_voting_units(ref self: ContractState, from: ContractAddress, to: ContractAddress, amount: u256)` internal

Transfers, mints, or burns voting units.

To register a mint, `from` should be zero. To register a burn, `to` should be zero. Total supply of voting units will be adjusted with mints and burns.

If voting units are based on an underlying transferable asset (like a token), you must call this function every time the asset is transferred to keep the internal voting power accounting in sync. For ERC20 and ERC721 tokens, this is typically handled using hooks.

May emit one or two [DelegateVotesChanged](#VotesComponent-DelegateVotesChanged) events.

#### [](#VotesComponent-num_checkpoints)`num_checkpoints(self: @ContractState, account: ContractAddress) → u64` internal

Returns the number of checkpoints for `account`.

#### [](#VotesComponent-checkpoints)`checkpoints(self: @ContractState, account: ContractAddress, pos: u64) → Checkpoint` internal

Returns the `pos`-th checkpoint for `account`.

#### [](#VotesComponent-_delegate)`_delegate(ref self: ContractState, account: ContractAddress, delegatee: ContractAddress)` internal

Delegates all of `account`'s voting units to `delegatee`.

Emits a [DelegateChanged](#VotesComponent-DelegateChanged) event.

May emit one or two [DelegateVotesChanged](#VotesComponent-DelegateVotesChanged) events.

#### [](#VotesComponent-Events)Events

#### [](#VotesComponent-DelegateChanged)`DelegateChanged(delegator: ContractAddress, from_delegate: ContractAddress, to_delegate: ContractAddress)` event

Emitted when an account changes their delegate.

#### [](#VotesComponent-DelegateVotesChanged)`DelegateVotesChanged(delegate: ContractAddress, previous_votes: u256, new_votes: u256)` event

Emitted when a token transfer or delegate change results in changes to a delegate’s number of votes.

### [](#VotingUnitsTrait)`VotingUnitsTrait`[](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.1/packages/governance/src/votes/votes.cairo)

```cairo
pub trait VotingUnitsTrait<TState> {
    fn get_voting_units(self: @TState, account: ContractAddress) -> u256;
}
```

A trait that must be implemented when integrating [VotesComponent](#VotesComponent) into a contract. It offers a mechanism to retrieve the number of voting units for a given account at the current time.

Functions

- [`get_voting_units(self, account)`](#VotingUnitsTrait-get_voting_units)

#### [](#VotingUnitsTrait-Functions)Functions

#### [](#VotingUnitsTrait-get_voting_units)`get_voting_units(self: @TState, account: ContractAddress) → u256` external

Returns the number of voting units for a given account. For ERC20, this is typically the token balance. For ERC721, this is typically the number of tokens owned.

While any formula can be used as a measure of voting units, the internal vote accounting of the contract may be compromised if voting units are transferred in any external flow by following a different formula.
For example, when implementing the hook for ERC20, the number of voting units transferred should match the formula given by the `get_voting_units` implementation.
