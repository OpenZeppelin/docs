---
title: ERC721
description: ERC721
---

This module provides interfaces, presets, and utilities related to ERC721 contracts.

<Callout>
For an overview of ERC721, read our [ERC721 guide](erc721.adoc).
</Callout>

## Interfaces

<Callout>
Starting from version `3.x.x`, the interfaces are no longer part of the `openzeppelin_token` package. The references
</Callout>
documented here are contained in the `openzeppelin_interfaces` package version `current_openzeppelin_interfaces_version`.

### `++IERC721++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc721.cairo[pass:[<svg class="icon"><use href="#github-icon"/></svg>],role=heading-link]

```rust
use openzeppelin_interfaces::erc721::IERC721;
```

Interface of the IERC721 standard as defined in [EIP721](https://eips.ethereum.org/EIPS/eip-721).

**[SRC5 ID](api/introspection.adoc#ISRC5)**

0x33eb2f84c309543403fd69f0d0f363781ef06ef6faeb0131ff16ea3175bd943

**Functions**

* [`+balance_of(account)+`](#`[.contract-item-name]#++balance_of++#++(account:-contractaddress)-→-u256++`-[.item-kind]#external#)
* [`+owner_of(token_id)+`](#`[.contract-item-name]#++owner_of++#++(token_id:-u256)-→-contractaddress++`-[.item-kind]#external#)
* [`+safe_transfer_from(from, to, token_id, data)+`](#`[.contract-item-name]#++safe_transfer_from++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256,-data:-span<felt252>)++`-[.item-kind]#external#)
* [`+transfer_from(from, to, token_id)+`](#`[.contract-item-name]#++transfer_from++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#external#)
* [`+approve(to, token_id)+`](#`[.contract-item-name]#++approve++#++(to:-contractaddress,-token_id:-u256)++`-[.item-kind]#external#)
* [`+set_approval_for_all(operator, approved)+`](#`[.contract-item-name]#++set_approval_for_all++#++(operator:-contractaddress,-approved:-bool)++`-[.item-kind]#external#)
* [`+get_approved(token_id)+`](#`[.contract-item-name]#++get_approved++#++(token_id:-u256)-->-u256++`-[.item-kind]#external#)
* [`+is_approved_for_all(owner, operator)+`](#`[.contract-item-name]#++is_approved_for_all++#++(owner:-contractaddress,-operator:-contractaddress)-->-bool++`-[.item-kind]#external#)

**Events**

* [`+Approval(owner, approved, token_id)+`](#`[.contract-item-name]#++approval++#++(owner:-contractaddress,-approved:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#)
* [`+ApprovalForAll(owner, operator, approved)+`](#`[.contract-item-name]#++approvalforall++#++(owner:-contractaddress,-operator:-contractaddress,-approved:-bool)++`-[.item-kind]#event#)
* [`+Transfer(from, to, token_id)+`](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#)

#### Functions

#### `[.contract-item-name]#++balance_of++#++(account: ContractAddress) → u256++` [.item-kind]#external#

Returns the number of NFTs owned by `account`.

#### `[.contract-item-name]#++owner_of++#++(token_id: u256) → ContractAddress++` [.item-kind]#external#

Returns the owner address of `token_id`.

#### `[.contract-item-name]#++safe_transfer_from++#++(from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)++` [.item-kind]#external#

Transfer ownership of `token_id` from `from` to `to`, checking first that `to` is aware of the ERC721 protocol to prevent tokens being locked forever.
For information regarding how contracts communicate their awareness of the ERC721 protocol, see [Receiving Tokens](/erc721.adoc#receiving_tokens).

Emits a [Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++transfer_from++#++(from: ContractAddress, to: ContractAddress, token_id: u256)++` [.item-kind]#external#

Transfer ownership of `token_id` from `from` to `to`.

Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721 transfers or else they may be permanently lost.
Usage of [IERC721::safe_transfer_from](#`[.contract-item-name]#++safe_transfer_from++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256,-data:-span<felt252>)++`-[.item-kind]#external#) prevents loss, though the caller must understand this adds an external call which potentially creates a reentrancy vulnerability.

Emits a [Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++approve++#++(to: ContractAddress, token_id: u256)++` [.item-kind]#external#

Change or reaffirm the approved address for an NFT.

Emits an [Approval](#`[.contract-item-name]#++approval++#++(owner:-contractaddress,-approved:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++set_approval_for_all++#++(operator: ContractAddress, approved: bool)++` [.item-kind]#external#

Enable or disable approval for `operator` to manage all of the caller’s assets.

Emits an [ApprovalForAll](#`[.contract-item-name]#++approvalforall++#++(owner:-contractaddress,-operator:-contractaddress,-approved:-bool)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++get_approved++#++(token_id: u256) -> u256++` [.item-kind]#external#

Returns the address approved for `token_id`.

#### `[.contract-item-name]#++is_approved_for_all++#++(owner: ContractAddress, operator: ContractAddress) -> bool++` [.item-kind]#external#

Query if `operator` is an authorized operator for `owner`.

#### Events

#### `[.contract-item-name]#++Approval++#++(owner: ContractAddress, approved: ContractAddress, token_id: u256)++` [.item-kind]#event#

Emitted when `owner` enables `approved` to manage the `token_id` token.

#### `[.contract-item-name]#++ApprovalForAll++#++(owner: ContractAddress, operator: ContractAddress, approved: bool)++` [.item-kind]#event#

Emitted when `owner` enables or disables `operator` to manage the `token_id` token.

#### `[.contract-item-name]#++Transfer++#++(from: ContractAddress, to: ContractAddress, token_id: u256)++` [.item-kind]#event#

Emitted when `token_id` token is transferred from `from` to `to`.

### `++IERC721Metadata++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc721.cairo[pass:[<svg class="icon"><use href="#github-icon"/></svg>],role=heading-link]

```rust
use openzeppelin_interfaces::erc721::IERC721Metadata;
```

Interface for the optional metadata functions in [EIP721](https://eips.ethereum.org/EIPS/eip-721).

**[SRC5 ID](api/introspection.adoc#ISRC5)**

0xabbcd595a567dce909050a1038e055daccb3c42af06f0add544fa90ee91f25

**Functions**

* [`+name()+`](#`[.contract-item-name]#++name++#++()-->-bytearray++`-[.item-kind]#external#)
* [`+symbol()+`](#`[.contract-item-name]#++symbol++#++()-->-bytearray++`-[.item-kind]#external#)
* [`+token_uri(token_id)+`](#`[.contract-item-name]#++token_uri++#++(token_id:-u256)-->-bytearray++`-[.item-kind]#external#)

#### Functions

#### `[.contract-item-name]#++name++#++() -> ByteArray++` [.item-kind]#external#

Returns the NFT name.

#### `[.contract-item-name]#++symbol++#++() -> ByteArray++` [.item-kind]#external#

Returns the NFT ticker symbol.

#### `[.contract-item-name]#++token_uri++#++(token_id: u256) -> ByteArray++` [.item-kind]#external#

Returns the Uniform Resource Identifier (URI) for the `token_id` token.
If the URI is not set for `token_id`, the return value will be an empty `ByteArray`.

### `++IERC721Receiver++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc721.cairo[pass:[<svg class="icon"><use href="#github-icon"/></svg>],role=heading-link]

```rust
use openzeppelin_interfaces::erc721::IERC721Receiver;
```

Interface for contracts that support receiving `safe_transfer_from` transfers.

**[SRC5 ID](api/introspection.adoc#ISRC5)**

0x3a0dff5f70d80458ad14ae37bb182a728e3c8cdda0402a5daa86620bdf910bc

**Functions**

* [`+on_erc721_received(operator, from, token_id, data)+`](#`[.contract-item-name]#++on_erc721_received++#++(operator:-contractaddress,-from:-contractaddress,-token_id:-u256,-data:-span<felt252>)-->-felt252++`-[.item-kind]#external#)

#### Functions

#### `[.contract-item-name]#++on_erc721_received++#++(operator: ContractAddress, from: ContractAddress, token_id: u256, data: Span<felt252>) -> felt252++` [.item-kind]#external#

Whenever an IERC721 `token_id` token is transferred to this non-account contract via [IERC721::safe_transfer_from](#`[.contract-item-name]#++safe_transfer_from++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256,-data:-span<felt252>)++`-[.item-kind]#external#) by `operator` from `from`, this function is called.

### `++IERC721Enumerable++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc721.cairo[pass:[<svg class="icon"><use href="#github-icon"/></svg>],role=heading-link]

Interface for the optional enumerable functions in [EIP721](https://eips.ethereum.org/EIPS/eip-721).

**[SRC5 ID](api/introspection.adoc#ISRC5)**

0x16bc0f502eeaf65ce0b3acb5eea656e2f26979ce6750e8502a82f377e538c87

**Functions**

* [`+total_supply()+`](#`[.contract-item-name]#++total_supply++#++()-->-u256++`-[.item-kind]#external#)
* [`+token_by_index(index)+`](#`[.contract-item-name]#++token_by_index++#++(index:-u256)-->-u256++`-[.item-kind]#external#)
* [`+token_of_owner_by_index(owner, index)+`](#`[.contract-item-name]#++token_of_owner_by_index++#++(owner:-contractaddress,-index:-u256)-->-u256++`-[.item-kind]#external#)

#### Functions

#### `[.contract-item-name]#++total_supply++#++() -> u256++` [.item-kind]#external#

Returns the total amount of tokens stored by the contract.

#### `[.contract-item-name]#++token_by_index++#++(index: u256) -> u256++` [.item-kind]#external#

Returns a token id at a given `index` of all the tokens stored by the contract.
Use along with [IERC721Enumerable::total_supply](#`[.contract-item-name]#++total_supply++#++()-->-u256++`-[.item-kind]#external#) to enumerate all tokens.

#### `[.contract-item-name]#++token_of_owner_by_index++#++(owner: ContractAddress, index: u256) -> u256++` [.item-kind]#external#

Returns the token id owned by `owner` at a given `index` of its token list.
Use along with [IERC721::balance_of](#`[.contract-item-name]#++balance_of++#++(account:-contractaddress)-→-u256++`-[.item-kind]#external#) to enumerate all of ``owner`’s tokens.

## Core

### `++ERC721Component++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/token/src/erc721/erc721.cairo[pass:[<svg class="icon"><use href="#github-icon"/></svg>],role=heading-link]

```rust
use openzeppelin_token::erc721::ERC721Component;
```

ERC721 component implementing [IERC721](#`++ierc721++`-link:https://github.com/openzeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc721.cairo[pass:[<svg-class="icon"><use-href="#github-icon"/></svg>],role=heading-link]) and [IERC721Metadata](#`++ierc721metadata++`-link:https://github.com/openzeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc721.cairo[pass:[<svg-class="icon"><use-href="#github-icon"/></svg>],role=heading-link]).

<Callout>
src5-component-required-note
</Callout>

<Callout>
See [Hooks](#hooks) to understand how are hooks used.
</Callout>

**Hooks**

<a name="ERC721Component-ERC721HooksTrait"></a>**ERC721HooksTrait**

* [`+before_update(self, to, token_id, auth)+`](#`[.contract-item-name]#++before_update++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256,-auth:-contractaddress)++`-[.item-kind]#hook#)
* [`+after_update(self, to, token_id, auth)+`](#`[.contract-item-name]#++after_update++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256,-auth:-contractaddress)++`-[.item-kind]#hook#)

**ERC721MixinImpl**

* [`+ERC721Impl+`](#ERC721Component-Embeddable-Impls-ERC721Impl)
* [`+ERC721MetadataImpl+`](#ERC721Component-Embeddable-Impls-ERC721MetadataImpl)
* [`+ERC721CamelOnlyImpl+`](#ERC721Component-Embeddable-Impls-ERC721CamelOnlyImpl)
* [`+ERC721MetadataCamelOnlyImpl+`](#ERC721Component-Embeddable-Impls-ERC721MetadataCamelOnlyImpl)
* [`+SRC5Impl+`](api/introspection.adoc#SRC5Component-Embeddable-Impls)

<a name="ERC721Component-Embeddable-Impls"></a>**Embeddable Implementations**

<a name="ERC721Component-Embeddable-Impls-ERC721Impl"></a>**ERC721Impl**

* [`+balance_of(self, account)+`](#`[.contract-item-name]#++balance_of++#++(self:-@contractstate,-account:-contractaddress)-→-u256++`-[.item-kind]#external#)
* [`+owner_of(self, token_id)+`](#`[.contract-item-name]#++owner_of++#++(self:-@contractstate,-token_id:-u256)-→-contractaddress++`-[.item-kind]#external#)
* [`+safe_transfer_from(self, from, to, token_id, data)+`](#`[.contract-item-name]#++safe_transfer_from++#++(ref-self:-contractstate,-from:-contractaddress,-to:-contractaddress,-token_id:-u256,-data:-span<felt252>)++`-[.item-kind]#external#)
* [`+transfer_from(self, from, to, token_id)+`](#`[.contract-item-name]#++transfer_from++#++(ref-self:-contractstate,-from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#external#)
* [`+approve(self, to, token_id)+`](#`[.contract-item-name]#++approve++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#external#)
* [`+set_approval_for_all(self, operator, approved)+`](#`[.contract-item-name]#++set_approval_for_all++#++(ref-self:-contractstate,-operator:-contractaddress,-approved:-bool)++`-[.item-kind]#external#)
* [`+get_approved(self, token_id)+`](#`[.contract-item-name]#++get_approved++#++(self:-@contractstate,-token_id:-u256)-->-u256++`-[.item-kind]#external#)
* [`+is_approved_for_all(self, owner, operator)+`](#`[.contract-item-name]#++is_approved_for_all++#++(self:-@contractstate,-owner:-contractaddress,-operator:-contractaddress)-->-bool++`-[.item-kind]#external#)

<a name="ERC721Component-Embeddable-Impls-ERC721MetadataImpl"></a>**ERC721MetadataImpl**

* [`+name(self)+`](#`[.contract-item-name]#++name++#++(self:-@contractstate)-->-bytearray++`-[.item-kind]#external#)
* [`+symbol(self)+`](#`[.contract-item-name]#++symbol++#++(self:-@contractstate)-->-bytearray++`-[.item-kind]#external#)
* [`+token_uri(self, token_id)+`](#`[.contract-item-name]#++token_uri++#++(self:-@contractstate,-token_id:-u256)-->-bytearray++`-[.item-kind]#external#)

<a name="ERC721Component-Embeddable-Impls-ERC721CamelOnlyImpl"></a>**ERC721CamelOnlyImpl**

* [`+balanceOf(self, account)+`](#`[.contract-item-name]#++balanceof++#++(self:-@contractstate,-account:-contractaddress)-->-u256++`-[.item-kind]#external#)
* [`+ownerOf(self, tokenId)+`](#`[.contract-item-name]#++ownerof++#++(self:-@contractstate,-tokenid:-u256)-->-contractaddress++`-[.item-kind]#external#)
* [`+safeTransferFrom(self, from, to, tokenId, data)+`](#`[.contract-item-name]#++safetransferfrom++#++(ref-self:-contractstate,-from:-contractaddress,-to:-contractaddress,-tokenid:-u256,-data:-span<felt252>)++`-[.item-kind]#external#)
* [`+transferFrom(self, from, to, tokenId)+`](#`[.contract-item-name]#++transferfrom++#++(ref-self:-contractstate,-from:-contractaddress,-to:-contractaddress,-tokenid:-u256)++`-[.item-kind]#external#)
* [`+setApprovalForAll(self, operator, approved)+`](#`[.contract-item-name]#++setapprovalforall++#++(ref-self:-contractstate,-operator:-contractaddress,-approved:-bool)++`-[.item-kind]#external#)
* [`+getApproved(self, tokenId)+`](#`[.contract-item-name]#++getapproved++#++(self:-@contractstate,-tokenid:-u256)-->-contractaddress++`-[.item-kind]#external#)
* [`+isApprovedForAll(self, owner, operator)+`](#`[.contract-item-name]#++isapprovedforall++#++(self:-@contractstate,-owner:-contractaddress,-operator:-contractaddress)-->-bool++`-[.item-kind]#external#)

<a name="ERC721Component-Embeddable-Impls-ERC721MetadataCamelOnlyImpl"></a>**ERC721MetadataCamelOnlyImpl**

* [`+tokenURI(self, tokenId)+`](#`[.contract-item-name]#++tokenuri++#++(self:-@contractstate,-tokenid:-u256)-->-bytearray++`-[.item-kind]#external#)

**SRC5Impl**

* [`supports_interface(self, interface_id: felt252)`](api/introspection.adoc#ISRC5-supports_interface)

**Internal functions**

**InternalImpl**

* [`+initializer(self, name, symbol, base_uri)+`](#`[.contract-item-name]#++initializer++#++(ref-self:-contractstate,-name:-bytearray,-symbol:-bytearray,-base_uri:-bytearray)++`-[.item-kind]#internal#)
* [`+initializer_no_metadata(self)+`](#`[.contract-item-name]#++initializer_no_metadata++#++(ref-self:-contractstate)++`-[.item-kind]#internal#)
* [`+exists(self, token_id)+`](#`[.contract-item-name]#++exists++#++(self:-@contractstate,-token_id:-u256)-->-bool++`-[.item-kind]#internal#)
* [`+transfer(self, from, to, token_id)+`](#`[.contract-item-name]#++transfer++#++(ref-self:-contractstate,-from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#internal#)
* [`+mint(self, to, token_id)+`](#`[.contract-item-name]#++mint++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#internal#)
* [`+safe_transfer(self, from, to, token_id, data)+`](#`[.contract-item-name]#++safe_transfer++#++(ref-self:-contractstate,-from:-contractaddress,-to:-contractaddress,-token_id:-u256,-data:-span<felt252>)++`-[.item-kind]#internal#)
* [`+safe_mint(self, to, token_id, data)+`](#`[.contract-item-name]#++safe_mint++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256,-data:-span<felt252>)++`-[.item-kind]#internal#)
* [`+burn(self, token_id)+`](#`[.contract-item-name]#++burn++#++(ref-self:-contractstate,-token_id:-u256)++`-[.item-kind]#internal#)
* [`+update(self, to, token_id, auth)+`](#`[.contract-item-name]#++update++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256,-auth:-contractaddress)++`-[.item-kind]#internal#)
* [`+_owner_of(self, token_id)+`](#`[.contract-item-name]#++_owner_of++#++(self:-@contractstate,-token_id:-felt252)-->-contractaddress++`-[.item-kind]#internal#)
* [`+_require_owned(self, token_id)+`](#`[.contract-item-name]#++_require_owned++#++(self:-@contractstate,-token_id:-felt252)-->-contractaddress++`-[.item-kind]#internal#)
* [`+_approve(self, to, token_id, auth)+`](#`[.contract-item-name]#++_approve++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256,-auth:-contractaddress)++`-[.item-kind]#internal#)
* [`+_approve_with_optional_event(self, to, token_id, auth, emit_event)+`](#`[.contract-item-name]#++_approve_with_optional_event++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256,-auth:-contractaddress,-emit_event:-bool)++`-[.item-kind]#internal#)
* [`+_set_approval_for_all(self, owner, operator, approved)+`](#`[.contract-item-name]#++_set_approval_for_all++#++(ref-self:-contractstate,-owner:-contractaddress,-operator:-contractaddress,-approved:-bool)++`-[.item-kind]#internal#)
* [`+_set_base_uri(self, base_uri)+`](#`[.contract-item-name]#++_set_base_uri++#++(ref-self:-contractstate,-base_uri:-bytearray)++`-[.item-kind]#internal#)
* [`+_base_uri(self)+`](#`[.contract-item-name]#++_base_uri++#++(self:-@contractstate)-->-bytearray++`-[.item-kind]#internal#)
* [`+_is_authorized(self, owner, spender, token_id)+`](#`[.contract-item-name]#++_is_authorized++#++(self:-@contractstate,-owner:-contractaddress,-spender:-contractaddress,-token_id:-u256)-->-bool++`-[.item-kind]#internal#)
* [`+_check_authorized(self, owner, spender, token_id)+`](#`[.contract-item-name]#++_check_authorized++#++(self:-@contractstate,-owner:-contractaddress,-spender:-contractaddress,-token_id:-u256)-->-bool++`-[.item-kind]#internal#)

**Events**

**IERC721**

* [`+Approval(owner, approved, token_id)+`](#`[.contract-item-name]#++approval++#++(owner:-contractaddress,-approved:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#)
* [`+ApprovalForAll(owner, operator, approved)+`](#`[.contract-item-name]#++approvalforall++#++(owner:-contractaddress,-operator:-contractaddress,-approved:-bool)++`-[.item-kind]#event#)
* [`+Transfer(from, to, token_id)+`](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#)

#### Hooks

Hooks are functions which implementations can extend the functionality of the component source code. Every contract
using ERC721Component is expected to provide an implementation of the ERC721HooksTrait. For basic token contracts, an
empty implementation with no logic must be provided.

<Callout>
You can use `openzeppelin_token::erc721::ERC721HooksEmptyImpl` which is already available as part of the library
</Callout>
for this purpose.

#### `[.contract-item-name]#++before_update++#++(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)++` [.item-kind]#hook#

Function executed at the beginning of the [update](#`[.contract-item-name]#++update++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256,-auth:-contractaddress)++`-[.item-kind]#internal#) function prior to any other logic.

#### `[.contract-item-name]#++after_update++#++(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)++` [.item-kind]#hook#

Function executed at the end of the [update](#`[.contract-item-name]#++update++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256,-auth:-contractaddress)++`-[.item-kind]#internal#) function.

#### Embeddable functions

#### `[.contract-item-name]#++balance_of++#++(self: @ContractState, account: ContractAddress) → u256++` [.item-kind]#external#

See [IERC721::balance_of](#`[.contract-item-name]#++balance_of++#++(account:-contractaddress)-→-u256++`-[.item-kind]#external#).

#### `[.contract-item-name]#++owner_of++#++(self: @ContractState, token_id: u256) → ContractAddress++` [.item-kind]#external#

See [IERC721::owner_of](#`[.contract-item-name]#++owner_of++#++(token_id:-u256)-→-contractaddress++`-[.item-kind]#external#).

Requirements:

* `token_id` exists.

#### `[.contract-item-name]#++safe_transfer_from++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)++` [.item-kind]#external#

See [IERC721::safe_transfer_from](#`[.contract-item-name]#++safe_transfer_from++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256,-data:-span<felt252>)++`-[.item-kind]#external#).

Requirements:

* Caller is either approved or the `token_id` owner.
* `to` is not the zero address.
* `from` is not the zero address.
* `token_id` exists.
* `to` is either an account contract or supports the [IERC721Receiver](#`++ierc721receiver++`-link:https://github.com/openzeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc721.cairo[pass:[<svg-class="icon"><use-href="#github-icon"/></svg>],role=heading-link]) interface.

#### `[.contract-item-name]#++transfer_from++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256)++` [.item-kind]#external#

See [IERC721::transfer_from](#`[.contract-item-name]#++transfer_from++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#external#).

Requirements:

* Caller either approved or the `token_id` owner.
* `to` is not the zero address.
* `from` is not the zero address.
* `token_id` exists.

#### `[.contract-item-name]#++approve++#++(ref self: ContractState, to: ContractAddress, token_id: u256)++` [.item-kind]#external#

See [IERC721::approve](#`[.contract-item-name]#++approve++#++(to:-contractaddress,-token_id:-u256)++`-[.item-kind]#external#).

Requirements:

* The caller is either an approved operator or the `token_id` owner.
* `to` cannot be the token owner or the zero address.
* `token_id` exists.

#### `[.contract-item-name]#++set_approval_for_all++#++(ref self: ContractState, operator: ContractAddress, approved: bool)++` [.item-kind]#external#

See [IERC721::set_approval_for_all](#`[.contract-item-name]#++set_approval_for_all++#++(operator:-contractaddress,-approved:-bool)++`-[.item-kind]#external#).

Requirements:

* `operator` is not the zero address.

#### `[.contract-item-name]#++get_approved++#++(self: @ContractState, token_id: u256) -> u256++` [.item-kind]#external#

See [IERC721::get_approved](#`[.contract-item-name]#++get_approved++#++(token_id:-u256)-->-u256++`-[.item-kind]#external#).

Requirements:

* `token_id` exists.

#### `[.contract-item-name]#++is_approved_for_all++#++(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool++` [.item-kind]#external#

See [IERC721::is_approved_for_all](#`[.contract-item-name]#++is_approved_for_all++#++(owner:-contractaddress,-operator:-contractaddress)-->-bool++`-[.item-kind]#external#).

#### `[.contract-item-name]#++name++#++(self: @ContractState) -> ByteArray++` [.item-kind]#external#

See [IERC721Metadata::name](#`[.contract-item-name]#++name++#++()-->-bytearray++`-[.item-kind]#external#).

#### `[.contract-item-name]#++symbol++#++(self: @ContractState) -> ByteArray++` [.item-kind]#external#

See [IERC721Metadata::symbol](#`[.contract-item-name]#++symbol++#++()-->-bytearray++`-[.item-kind]#external#).

#### `[.contract-item-name]#++token_uri++#++(self: @ContractState, token_id: u256) -> ByteArray++` [.item-kind]#external#

Returns the Uniform Resource Identifier (URI) for the `token_id` token.
If a base URI is set, the resulting URI for each token will be the concatenation of the base URI and the token ID.
For example, the base URI pass:[<code>https://token-cdn-domain/</code>] would be returned as pass:[<code>https://token-cdn-domain/123</code>] for token ID `123`.

If the URI is not set for `token_id`, the return value will be an empty `ByteArray`.

#### `[.contract-item-name]#++balanceOf++#++(self: @ContractState, account: ContractAddress) -> u256++` [.item-kind]#external#

See [ERC721Component::balance_of](#`[.contract-item-name]#++balance_of++#++(self:-@contractstate,-account:-contractaddress)-→-u256++`-[.item-kind]#external#).

#### `[.contract-item-name]#++ownerOf++#++(self: @ContractState, tokenId: u256) -> ContractAddress++` [.item-kind]#external#

See [ERC721Component::owner_of](#`[.contract-item-name]#++owner_of++#++(self:-@contractstate,-token_id:-u256)-→-contractaddress++`-[.item-kind]#external#).

#### `[.contract-item-name]#++safeTransferFrom++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256, data: Span<felt252>)++` [.item-kind]#external#

See [ERC721Component::safe_transfer_from](#`[.contract-item-name]#++safe_transfer_from++#++(ref-self:-contractstate,-from:-contractaddress,-to:-contractaddress,-token_id:-u256,-data:-span<felt252>)++`-[.item-kind]#external#).

#### `[.contract-item-name]#++transferFrom++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, tokenId: u256)++` [.item-kind]#external#

See [ERC721Component::transfer_from](#`[.contract-item-name]#++transfer_from++#++(ref-self:-contractstate,-from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#external#).

#### `[.contract-item-name]#++setApprovalForAll++#++(ref self: ContractState, operator: ContractAddress, approved: bool)++` [.item-kind]#external#

See [ERC721Component::set_approval_for_all](#`[.contract-item-name]#++set_approval_for_all++#++(ref-self:-contractstate,-operator:-contractaddress,-approved:-bool)++`-[.item-kind]#external#).

#### `[.contract-item-name]#++getApproved++#++(self: @ContractState, tokenId: u256) -> ContractAddress++` [.item-kind]#external#

See [ERC721Component::get_approved](#`[.contract-item-name]#++get_approved++#++(self:-@contractstate,-token_id:-u256)-->-u256++`-[.item-kind]#external#).

#### `[.contract-item-name]#++isApprovedForAll++#++(self: @ContractState, owner: ContractAddress, operator: ContractAddress) -> bool++` [.item-kind]#external#

See [ERC721Component::is_approved_for_all](#`[.contract-item-name]#++is_approved_for_all++#++(self:-@contractstate,-owner:-contractaddress,-operator:-contractaddress)-->-bool++`-[.item-kind]#external#).

#### `[.contract-item-name]#++tokenURI++#++(self: @ContractState, tokenId: u256) -> ByteArray++` [.item-kind]#external#

See [ERC721Component::token_uri](#`[.contract-item-name]#++token_uri++#++(self:-@contractstate,-token_id:-u256)-->-bytearray++`-[.item-kind]#external#).

#### Internal functions

#### `[.contract-item-name]#++initializer++#++(ref self: ContractState, name: ByteArray, symbol: ByteArray, base_uri: ByteArray)++` [.item-kind]#internal#

Initializes the contract by setting the token name and symbol.
This should be used inside the contract’s constructor.

<Callout type='warn'>
Most ERC721 contracts expose the [IERC721Metadata](#`++ierc721metadata++`-link:https://github.com/openzeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc721.cairo[pass:[<svg-class="icon"><use-href="#github-icon"/></svg>],role=heading-link]) interface which
</Callout>
is what this initializer is meant to support.
If the contract DOES NOT expose the [IERC721Metadata](#`++ierc721metadata++`-link:https://github.com/openzeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc721.cairo[pass:[<svg-class="icon"><use-href="#github-icon"/></svg>],role=heading-link]) interface,
meaning the token does not have a name, symbol, or URI,
the contract must instead use [initializer_no_metadata](#`[.contract-item-name]#++initializer_no_metadata++#++(ref-self:-contractstate)++`-[.item-kind]#internal#) in the constructor.
Failure to abide by these instructions can lead to unexpected issues especially with
UIs.

#### `[.contract-item-name]#++initializer_no_metadata++#++(ref self: ContractState)++` [.item-kind]#internal#

Initializes the contract with no metadata by registering only the IERC721 interface.

<Callout type='warn'>
This initializer should ONLY be used during construction in the very
</Callout>
specific instance when the contract does NOT expose the [IERC721Metadata](#`++ierc721metadata++`-link:https://github.com/openzeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc721.cairo[pass:[<svg-class="icon"><use-href="#github-icon"/></svg>],role=heading-link]) interface.
Initializing a contract with this initializer means that tokens will not
have a name, symbol, or URI.

#### `[.contract-item-name]#++exists++#++(self: @ContractState, token_id: u256) -> bool++` [.item-kind]#internal#

Internal function that returns whether `token_id` exists.

Tokens start existing when they are minted ([mint](#ERC721-mint)), and stop existing when they are burned ([burn](#ERC721-burn)).

#### `[.contract-item-name]#++transfer++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256)++` [.item-kind]#internal#

Transfers `token_id` from `from` to `to`.

Internal function without access restriction.

<Callout type='warn'>
This method may lead to the loss of tokens if `to` is not aware of the ERC721 protocol.
</Callout>

Requirements:

* `to` is not the zero address.
* `from` is the token owner.
* `token_id` exists.

Emits a [Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++mint++#++(ref self: ContractState, to: ContractAddress, token_id: u256)++` [.item-kind]#internal#

Mints `token_id` and transfers it to `to`.
Internal function without access restriction.

<Callout type='warn'>
This method may lead to the loss of tokens if `to` is not aware of the ERC721 protocol.
</Callout>

Requirements:

* `to` is not the zero address.
* `token_id` does not exist.

Emits a [Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++safe_transfer++#++(ref self: ContractState, from: ContractAddress, to: ContractAddress, token_id: u256, data: Span<felt252>)++` [.item-kind]#internal#

Transfers ownership of `token_id` from `from` if `to` is either an account or `IERC721Receiver`.

`data` is additional data, it has no specified format and is forwarded in `IERC721Receiver::on_erc721_received` to `to`.

<Callout type='warn'>
This method makes an external call to the recipient contract, which can lead to reentrancy vulnerabilities.
</Callout>

Requirements:

* `to` cannot be the zero address.
* `from` must be the token owner.
* `token_id` exists.
* `to` is either an account contract or supports the `IERC721Receiver` interface.

Emits a [Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++safe_mint++#++(ref self: ContractState, to: ContractAddress, token_id: u256, data: Span<felt252>)++` [.item-kind]#internal#

Mints `token_id` if `to` is either an account or `IERC721Receiver`.

`data` is additional data, it has no specified format and is forwarded in `IERC721Receiver::on_erc721_received` to `to`.

<Callout type='warn'>
This method makes an external call to the recipient contract, which can lead to reentrancy vulnerabilities.
</Callout>

Requirements:

* `token_id` does not exist.
* `to` is either an account contract or supports the `IERC721Receiver` interface.

Emits a [Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++burn++#++(ref self: ContractState, token_id: u256)++` [.item-kind]#internal#

Destroys `token_id`. The approval is cleared when the token is burned.

This internal function does not check if the caller is authorized
to operate on the token.

Requirements:

* `token_id` exists.

Emits a [Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++update++#++(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)++` [.item-kind]#internal#

Transfers `token_id` from its current owner to `to`, or alternatively mints (or burns) if the current owner
(or `to`) is the zero address. Returns the owner of the `token_id` before the update.

The `auth` argument is optional. If the value passed is non-zero, then this function will check that
`auth` is either the owner of the token, or approved to operate on the token (by the owner).

Emits a [Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#) event.

<Callout>
This function can be extended using the `ERC721HooksTrait`, to add
</Callout>
functionality before and/or after the transfer, mint, or burn.

#### `[.contract-item-name]#++_owner_of++#++(self: @ContractState, token_id: felt252) -> ContractAddress++` [.item-kind]#internal#

Internal function that returns the owner address of `token_id`.

#### `[.contract-item-name]#++_require_owned++#++(self: @ContractState, token_id: felt252) -> ContractAddress++` [.item-kind]#internal#

Version of [_owner_of](#`[.contract-item-name]#++_owner_of++#++(self:-@contractstate,-token_id:-felt252)-->-contractaddress++`-[.item-kind]#internal#) that panics if owner is the zero address.

#### `[.contract-item-name]#++_approve++#++(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress)++` [.item-kind]#internal#

Approve `to` to operate on `token_id`

The `auth` argument is optional. If the value passed is non-zero, then this function will check that `auth` is
either the owner of the token, or approved to operate on all tokens held by this owner.

Emits an [Approval](#`[.contract-item-name]#++approval++#++(owner:-contractaddress,-approved:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++_approve_with_optional_event++#++(ref self: ContractState, to: ContractAddress, token_id: u256, auth: ContractAddress, emit_event: bool)++` [.item-kind]#internal#

Variant of [_approve](#`[.contract-item-name]#++_approve++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256,-auth:-contractaddress)++`-[.item-kind]#internal#) with an optional flag to enable or disable the `Approval` event.
The event is not emitted in the context of transfers.

<Callout type='warn'>
If `auth` is zero and `emit_event` is false, this function will not check that the token exists.
</Callout>

Requirements:

* if `auth` is non-zero, it must be either the owner of the token or approved to
operate on all of its tokens.

May emit an [Approval](#`[.contract-item-name]#++approval++#++(owner:-contractaddress,-approved:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++_set_approval_for_all++#++(ref self: ContractState, owner: ContractAddress, operator: ContractAddress, approved: bool)++` [.item-kind]#internal#

Enables or disables approval for `operator` to manage
all of the `owner` assets.

Requirements:

* `operator` is not the zero address.

Emits an [Approval](#`[.contract-item-name]#++approval++#++(owner:-contractaddress,-approved:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#) event.

#### `[.contract-item-name]#++_set_base_uri++#++(ref self: ContractState, base_uri: ByteArray)++` [.item-kind]#internal#

Internal function that sets the `base_uri`.

#### `[.contract-item-name]#++_base_uri++#++(self: @ContractState) -> ByteArray++` [.item-kind]#internal#

Base URI for computing [token_uri](#`[.contract-item-name]#++token_uri++#++(token_id:-u256)-->-bytearray++`-[.item-kind]#external#).

If set, the resulting URI for each token will be the concatenation of the base URI and the token ID.
Returns an empty `ByteArray` if not set.

#### `[.contract-item-name]#++_is_authorized++#++(self: @ContractState, owner: ContractAddress, spender: ContractAddress, token_id: u256) -> bool++` [.item-kind]#internal#

Returns whether `spender` is allowed to manage ``owner`’s tokens, or `token_id` in
particular (ignoring whether it is owned by `owner`).

<Callout type='warn'>
This function assumes that `owner` is the actual owner of `token_id` and does not verify this
</Callout>
assumption.

#### `[.contract-item-name]#++_check_authorized++#++(self: @ContractState, owner: ContractAddress, spender: ContractAddress, token_id: u256) -> bool++` [.item-kind]#internal#

Checks if `spender` can operate on `token_id`, assuming the provided `owner` is the actual owner.

Requirements:

* `owner` cannot be the zero address.
* `spender` cannot be the zero address.
* `spender` must be the owner of `token_id` or be approved to operate on it.

<Callout type='warn'>
This function assumes that `owner` is the actual owner of `token_id` and does not verify this
</Callout>
assumption.

#### Events

#### `[.contract-item-name]#++Approval++#++(owner: ContractAddress, approved: ContractAddress, token_id: u256)++` [.item-kind]#event#

See [IERC721::Approval](#`[.contract-item-name]#++approval++#++(owner:-contractaddress,-approved:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#).

#### `[.contract-item-name]#++ApprovalForAll++#++(owner: ContractAddress, operator: ContractAddress, approved: bool)++` [.item-kind]#event#

See [IERC721::ApprovalForAll](#`[.contract-item-name]#++approvalforall++#++(owner:-contractaddress,-operator:-contractaddress,-approved:-bool)++`-[.item-kind]#event#).

#### `[.contract-item-name]#++Transfer++#++(from: ContractAddress, to: ContractAddress, token_id: u256)++` [.item-kind]#event#

See [IERC721::Transfer](#`[.contract-item-name]#++transfer++#++(from:-contractaddress,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#event#).

### `++ERC721ReceiverComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/token/src/erc721/erc721_receiver.cairo[pass:[<svg class="icon"><use href="#github-icon"/></svg>],role=heading-link]

```rust
use openzeppelin_token::erc721::ERC721ReceiverComponent;
```

ERC721Receiver component implementing [IERC721Receiver](#`++ierc721receiver++`-link:https://github.com/openzeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/interfaces/src/token/erc721.cairo[pass:[<svg-class="icon"><use-href="#github-icon"/></svg>],role=heading-link]).

<Callout>
src5-component-required-note
</Callout>

**ERCReceiverMixinImpl**

* [`+ERC721ReceiverImpl+`](#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverImpl)
* [`+ERC721ReceiverCamelImpl+`](#ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverCamelImpl)
* [`+SRC5Impl+`](api/introspection.adoc#SRC5Component-Embeddable-Impls)

<a name="ERC721ReceiverComponent-Embeddable-Impls"></a>**Embeddable Implementations**

<a name="ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverImpl"></a>**ERC721ReceiverImpl**

* [`+on_erc721_received(self, operator, from, token_id, data)+`](#`[.contract-item-name]#++on_erc721_received++#++(self:-@contractstate,-operator:-contractaddress,-from:-contractaddress,-token_id:-u256,-data-span<felt252>)-->-felt252++`-[.item-kind]#external#)

<a name="ERC721ReceiverComponent-Embeddable-Impls-ERC721ReceiverCamelImpl"></a>**ERC721ReceiverCamelImpl**

* [`+onERC721Received(self, operator, from, tokenId, data)+`](#`[.contract-item-name]#++onerc721received++#++(self:-@contractstate,-operator:-contractaddress,-from:-contractaddress,-token_id:-u256,-data-span<felt252>)-->-felt252++`-[.item-kind]#external#)

**Internal Functions**

**InternalImpl**

* [`+initializer(self)+`](#`[.contract-item-name]#++initializer++#++(ref-self:-contractstate)++`-[.item-kind]#internal#)

#### Embeddable functions

#### `[.contract-item-name]#++on_erc721_received++#++(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, data Span<felt252>) -> felt252++` [.item-kind]#external#

Returns the `IERC721Receiver` interface ID.

#### `[.contract-item-name]#++onERC721Received++#++(self: @ContractState, operator: ContractAddress, from: ContractAddress, token_id: u256, data Span<felt252>) -> felt252++` [.item-kind]#external#

See [ERC721ReceiverComponent::on_erc721_received](#`[.contract-item-name]#++on_erc721_received++#++(self:-@contractstate,-operator:-contractaddress,-from:-contractaddress,-token_id:-u256,-data-span<felt252>)-->-felt252++`-[.item-kind]#external#).

#### Internal functions

#### `[.contract-item-name]#++initializer++#++(ref self: ContractState)++` [.item-kind]#internal#

Registers the `IERC721Receiver` interface ID as supported through introspection.

## Extensions

### `++ERC721EnumerableComponent++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/token/src/erc721/extensions/erc721_enumerable.cairo[pass:[<svg class="icon"><use href="#github-icon"/></svg>],role=heading-link]

```rust
use openzeppelin_token::erc721::extensions::ERC721EnumerableComponent;
```

Extension of ERC721 as defined in the EIP that adds enumerability of all the token ids in the contract as well as all token ids owned by each account.
This extension allows contracts to publish their entire list of NFTs and make them discoverable.

<Callout>
Implementing [ERC721Component](#`++erc721component++`-link:https://github.com/openzeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/token/src/erc721/erc721.cairo[pass:[<svg-class="icon"><use-href="#github-icon"/></svg>],role=heading-link]) is a requirement for this component to be implemented.
</Callout>

To properly track token ids, this extension requires that the [ERC721EnumerableComponent::before_update](#`[.contract-item-name]#++before_update++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#internal#) function is called before every transfer, mint, or burn operation.
For this, the [ERC721HooksTrait::before_update](#`[.contract-item-name]#++before_update++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256,-auth:-contractaddress)++`-[.item-kind]#hook#) hook must be used.
Here’s how the hook should be implemented in a contract:

```[,cairo]
#[starknet::contract]
mod ERC721EnumerableContract {
    (...)

    component!(path: ERC721Component, storage: erc721, event: ERC721Event);
    component!(path: ERC721EnumerableComponent, storage: erc721_enumerable, event: ERC721EnumerableEvent);
    component!(path: SRC5Component, storage: src5, event: SRC5Event);

    impl ERC721HooksImpl of ERC721Component::ERC721HooksTrait<ContractState> {
        fn before_update(
            ref self: ERC721Component::ComponentState<ContractState>,
            to: ContractAddress,
            token_id: u256,
            auth: ContractAddress
        ) {
            let mut contract_state = self.get_contract_mut();
            contract_state.erc721_enumerable.before_update(to, token_id);
        }
    }
}
```

<a name="ERC721EnumerableComponent-Embeddable-Impls"></a>**Embeddable Implementations**

<a name="ERC721EnumerableComponent-Embeddable-Impls-ERC721EnumerableImpl"></a>**ERC721EnumerableImpl**

* [`+total_supply(self)+`](#`[.contract-item-name]#++total_supply++#++(self:-@contractstate)-→-u256++`-[.item-kind]#external#)
* [`+token_by_index(self, index)+`](#`[.contract-item-name]#++token_by_index++#++(self:-@contractstate,-index:-u256)-→-u256++`-[.item-kind]#external#)
* [`+token_of_owner_by_index(self, address, index)+`](#`[.contract-item-name]#++token_of_owner_by_index++#++(self:-@contractstate,-owner:-contractaddress,-index:-u256)-→-u256++`-[.item-kind]#external#)

**Internal functions**

**InternalImpl**

* [`+initializer(self)+`](#`[.contract-item-name]#++initializer++#++(ref-self:-contractstate)++`-[.item-kind]#internal#)
* [`+before_update(self, to, token_id)+`](#`[.contract-item-name]#++before_update++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#internal#)
* [`+all_tokens_of_owner(self, owner)+`](#`[.contract-item-name]#++all_tokens_of_owner++#++(self:-@contractstate,-owner:-contractaddress)-→-span<u256>++`-[.item-kind]#internal#)
* [`+_add_token_to_owner_enumeration(self, to, token_id)+`](#`[.contract-item-name]#++_add_token_to_owner_enumeration++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256)++`-[.item-kind]#internal#)
* [`+_add_token_to_all_tokens_enumeration(self, token_id)+`](#`[.contract-item-name]#++_add_token_to_all_tokens_enumeration++#++(ref-self:-contractstate,-token_id:-u256)++`-[.item-kind]#internal#)
* [`+_remove_token_from_owner_enumeration(self, from, token_id)+`](#`[.contract-item-name]#++_remove_token_from_owner_enumeration++#++(ref-self:-contractstate,-from:-contractaddress,-token_id:-u256)++`-[.item-kind]#internal#)
* [`+_remove_token_from_all_tokens_enumeration(self, token_id)+`](#`[.contract-item-name]#++_remove_token_from_all_tokens_enumeration++#++(ref-self:-contractstate,-token_id:-u256)++`-[.item-kind]#internal#)

#### Embeddable functions

#### `[.contract-item-name]#++total_supply++#++(self: @ContractState) → u256++` [.item-kind]#external#

Returns the current amount of votes that `account` has.

#### `[.contract-item-name]#++token_by_index++#++(self: @ContractState, index: u256) → u256++` [.item-kind]#external#

See [IERC721Enumerable::token_by_index](#`[.contract-item-name]#++token_by_index++#++(index:-u256)-->-u256++`-[.item-kind]#external#).

Requirements:

* `index` is less than the total token supply.

#### `[.contract-item-name]#++token_of_owner_by_index++#++(self: @ContractState, owner: ContractAddress, index: u256) → u256++` [.item-kind]#external#

See [IERC721Enumerable::token_of_owner_by_index](#`[.contract-item-name]#++token_of_owner_by_index++#++(owner:-contractaddress,-index:-u256)-->-u256++`-[.item-kind]#external#).

Requirements:

* `index` is less than ``owner`’s token balance.
* `owner` is not the zero address.

#### Internal functions

#### `[.contract-item-name]#++initializer++#++(ref self: ContractState)++` [.item-kind]#internal#

Registers the `IERC721Enumerable` interface ID as supported through introspection.

#### `[.contract-item-name]#++before_update++#++(ref self: ContractState, to: ContractAddress, token_id: u256)++` [.item-kind]#internal#

Updates the ownership and token-tracking data structures.

When a token is minted (or burned), `token_id` is added to (or removed from) the token-tracking structures.

When a token is transferred, minted, or burned, the ownership-tracking data structures reflect the change in ownership of `token_id`.

This must be added to the implementing contract’s [ERC721HooksTrait::before_update](#`[.contract-item-name]#++before_update++#++(ref-self:-contractstate,-to:-contractaddress,-token_id:-u256,-auth:-contractaddress)++`-[.item-kind]#hook#) hook.

#### `[.contract-item-name]#++all_tokens_of_owner++#++(self: @ContractState, owner: ContractAddress) → Span<u256>++` [.item-kind]#internal#

Returns a list of all token ids owned by the specified `owner`.
This function provides a more efficient alternative to calling `ERC721::balance_of`
and iterating through tokens with `ERC721Enumerable::token_of_owner_by_index`.

Requirements:

* `owner` is not the zero address.

#### `[.contract-item-name]#++_add_token_to_owner_enumeration++#++(ref self: ContractState, to: ContractAddress, token_id: u256)++` [.item-kind]#internal#

Adds token to this extension’s ownership-tracking data structures.

#### `[.contract-item-name]#++_add_token_to_all_tokens_enumeration++#++(ref self: ContractState, token_id: u256)++` [.item-kind]#internal#

Adds token to this extension’s token-tracking data structures.

#### `[.contract-item-name]#++_remove_token_from_owner_enumeration++#++(ref self: ContractState, from: ContractAddress, token_id: u256)++` [.item-kind]#internal#

Removes a token from this extension’s ownership-tracking data structures.

This has 0(1) time complexity but alters the indexed order of owned tokens by swapping `token_id` and the index thereof with the last token id and the index thereof e.g. removing `1` from `[1, 2, 3, 4]` results in `[4, 2, 3]`.

#### `[.contract-item-name]#++_remove_token_from_all_tokens_enumeration++#++(ref self: ContractState, token_id: u256)++` [.item-kind]#internal#

Removes `token_id` from this extension’s token-tracking data structures.

This has 0(1) time complexity but alters the indexed order by swapping `token_id` and the index thereof with the last token id and the index thereof e.g. removing `1` from `[1, 2, 3, 4]` results in `[4, 2, 3]`.

## Presets

### `++ERC721Upgradeable++` link:https://github.com/OpenZeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/presets/src/erc721.cairo[pass:[<svg class="icon"><use href="#github-icon"/></svg>],role=heading-link]

```rust
use openzeppelin_presets::ERC721Upgradeable;
```

Upgradeable ERC721 contract leveraging [ERC721Component](#`++erc721component++`-link:https://github.com/openzeppelin/cairo-contracts/blob/release-v3.0.0-alpha.0/packages/token/src/erc721/erc721.cairo[pass:[<svg-class="icon"><use-href="#github-icon"/></svg>],role=heading-link]).

**presets-page**

ERC721Upgradeable-class-hash

**Constructor**

* [`+constructor(self, name, symbol, recipient, token_ids, base_uri, owner)+`](#`[.contract-item-name]#++constructor++#++(ref-self:-contractstate,-name:-bytearray,-symbol:-bytearray,-recipient:-contractaddress,-token_ids:-span<u256>,-base_uri:-bytearray,-owner:-contractaddress)++`-[.item-kind]#constructor#)

**Embedded Implementations**

* [`+ERC721MixinImpl+`](#ERC721Component-Embeddable-Mixin-Impl)

* [`+OwnableMixinImpl+`](/api/access.adoc#OwnableComponent-Mixin-Impl)

**External Functions**

* [`+upgrade(self, new_class_hash)+`](#`[.contract-item-name]#++upgrade++#++(ref-self:-contractstate,-new_class_hash:-classhash)++`-[.item-kind]#external#)

#### Constructor

#### `[.contract-item-name]#++constructor++#++(ref self: ContractState, name: ByteArray, symbol: ByteArray, recipient: ContractAddress, token_ids: Span<u256>, base_uri: ByteArray, owner: ContractAddress)++` [.item-kind]#constructor#

Sets the `name` and `symbol`.
Mints `token_ids` tokens to `recipient` and sets the `base_uri`.
Assigns `owner` as the contract owner with permissions to upgrade.

#### External functions

#### `[.contract-item-name]#++upgrade++#++(ref self: ContractState, new_class_hash: ClassHash)++` [.item-kind]#external#

Upgrades the contract to a new implementation given by `new_class_hash`.

Requirements:

* The caller is the contract owner.
* `new_class_hash` cannot be zero.
