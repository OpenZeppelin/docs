---
title: "Crosschain"
description: "Smart contract crosschain utilities and implementations"
---

<Callout>
This document is better viewed at https://docs.openzeppelin.com/contracts/api/crosschain
</Callout>

This directory provides building blocks to improve cross-chain awareness of smart contracts.

* [`CrossChainEnabled`](#CrossChainEnabled) is an abstraction that contains accessors and modifiers to control the execution flow when receiving cross-chain messages.

## CrossChainEnabled specializations

The following specializations of [`CrossChainEnabled`](#CrossChainEnabled) provide implementations of the [`CrossChainEnabled`](#CrossChainEnabled) abstraction for specific bridges. This can be used to complex cross-chain aware components such as [`AccessControlCrossChain`](access#AccessControlCrossChain).

[`CrossChainEnabledAMB`](#CrossChainEnabledAMB)

[`CrossChainEnabledArbitrumL1`](#CrossChainEnabledArbitrumL1)

[`CrossChainEnabledArbitrumL2`](#CrossChainEnabledArbitrumL2)

[`CrossChainEnabledOptimism`](#CrossChainEnabledOptimism)

[`CrossChainEnabledPolygonChild`](#CrossChainEnabledPolygonChild)

## Libraries for cross-chain

In addition to the [`CrossChainEnabled`](#CrossChainEnabled) abstraction, cross-chain awareness is also available through libraries. These libraries can be used to build complex designs such as contracts with the ability to interact with multiple bridges.

[`LibAMB`](#LibAMB)

[`LibArbitrumL1`](#LibArbitrumL1)

[`LibArbitrumL2`](#LibArbitrumL2)

[`LibOptimism`](#LibOptimism)

<a id="CrossChainEnabled"></a>

## `CrossChainEnabled` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.6/contracts/crosschain/CrossChainEnabled.sol)

```solidity
import "@openzeppelin/contracts/crosschain/CrossChainEnabled.sol";
```

Provides information for building cross-chain aware contracts. This
abstract contract provides accessors and modifiers to control the execution
flow when receiving cross-chain messages.

Actual implementations of cross-chain aware contracts, which are based on
this abstraction, will  have to inherit from a bridge-specific
specialization. Such specializations are provided under
`crosschain/<chain>/CrossChainEnabled<chain>.sol`.

_Available since v4.6._

### Modifiers
- [onlyCrossChain()](#CrossChainEnabled-onlyCrossChain--)
- [onlyCrossChainSender(expected)](#CrossChainEnabled-onlyCrossChainSender-address-)

### Functions
- [_isCrossChain()](#CrossChainEnabled-_isCrossChain--)
- [_crossChainSender()](#CrossChainEnabled-_crossChainSender--)

<a id="CrossChainEnabled-onlyCrossChain--"></a>

### `onlyCrossChain()`

Throws if the current function call is not the result of a
cross-chain execution.

<a id="CrossChainEnabled-onlyCrossChainSender-address-"></a>

### `onlyCrossChainSender(address expected)`

Throws if the current function call is not the result of a
cross-chain execution initiated by `account`.

<a id="CrossChainEnabled-_isCrossChain--"></a>

### `_isCrossChain() ‚Üí bool`
*internal*

Returns whether the current function call is the result of a
cross-chain message.

<a id="CrossChainEnabled-_crossChainSender--"></a>

### `_crossChainSender() ‚Üí address`
*internal*

Returns the address of the sender of the cross-chain message that
triggered the current function call.

IMPORTANT: Should revert with `NotCrossChainCall` if the current function
call is not the result of a cross-chain message.

<a id="CrossChainEnabledAMB"></a>

## `CrossChainEnabledAMB` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.6/contracts/crosschain/amb/CrossChainEnabledAMB.sol)

```solidity
import "@openzeppelin/contracts/crosschain/amb/CrossChainEnabledAMB.sol";
```

[AMB](https://docs.tokenbridge.net/amb-bridge/about-amb-bridge)
specialization or the [`CrossChainEnabled`](#CrossChainEnabled) abstraction.

As of february 2020, AMB bridges are available between the following chains:

- [ETH ‚áå xDai](https://docs.tokenbridge.net/eth-xdai-amb-bridge/about-the-eth-xdai-amb)
- [ETH ‚áå qDai](https://docs.tokenbridge.net/eth-qdai-bridge/about-the-eth-qdai-amb)
- [ETH ‚áå ETC](https://docs.tokenbridge.net/eth-etc-amb-bridge/about-the-eth-etc-amb)
- [ETH ‚áå BSC](https://docs.tokenbridge.net/eth-bsc-amb/about-the-eth-bsc-amb)
- [ETH ‚áå POA](https://docs.tokenbridge.net/eth-poa-amb-bridge/about-the-eth-poa-amb)
- [BSC ‚áå xDai](https://docs.tokenbridge.net/bsc-xdai-amb/about-the-bsc-xdai-amb)
- [POA ‚áå xDai](https://docs.tokenbridge.net/poa-xdai-amb/about-the-poa-xdai-amb)
- [Rinkeby ‚áå xDai](https://docs.tokenbridge.net/rinkeby-xdai-amb-bridge/about-the-rinkeby-xdai-amb)
- [Kovan ‚áå Sokol](https://docs.tokenbridge.net/kovan-sokol-amb-bridge/about-the-kovan-sokol-amb)

_Available since v4.6._

### Functions
- [constructor(bridge)](#CrossChainEnabledAMB-constructor-address-)
- [_isCrossChain()](#CrossChainEnabledAMB-_isCrossChain--)
- [_crossChainSender()](#CrossChainEnabledAMB-_crossChainSender--)

#### CrossChainEnabled

<a id="CrossChainEnabledAMB-constructor-address-"></a>

### `constructor(address bridge)`
*public*

<a id="CrossChainEnabledAMB-_isCrossChain--"></a>

### `_isCrossChain() ‚Üí bool`
*internal*

see [`CrossChainEnabled._isCrossChain`](#CrossChainEnabled-_isCrossChain--)

<a id="CrossChainEnabledAMB-_crossChainSender--"></a>

### `_crossChainSender() ‚Üí address`
*internal*

see [`CrossChainEnabled._crossChainSender`](#CrossChainEnabled-_crossChainSender--)

<a id="LibAMB"></a>

## `LibAMB` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.6/contracts/crosschain/amb/LibAMB.sol)

```solidity
import "@openzeppelin/contracts/crosschain/amb/LibAMB.sol";
```

Primitives for cross-chain aware contracts using the
[AMB](https://docs.tokenbridge.net/amb-bridge/about-amb-bridge)
family of bridges.

### Functions
- [isCrossChain(bridge)](#LibAMB-isCrossChain-address-)
- [crossChainSender(bridge)](#LibAMB-crossChainSender-address-)

<a id="LibAMB-isCrossChain-address-"></a>

### `isCrossChain(address bridge) ‚Üí bool`
*internal*

Returns whether the current function call is the result of a
cross-chain message relayed by `bridge`.

<a id="LibAMB-crossChainSender-address-"></a>

### `crossChainSender(address bridge) ‚Üí address`
*internal*

Returns the address of the sender that triggered the current
cross-chain message through `bridge`.

NOTE: [`LibAMB.isCrossChain`](#LibAMB-isCrossChain-address-) should be checked before trying to recover the
sender, as it will revert with `NotCrossChainCall` if the current
function call is not the result of a cross-chain message.

<a id="CrossChainEnabledArbitrumL1"></a>

## `CrossChainEnabledArbitrumL1` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.6/contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL1.sol)

```solidity
import "@openzeppelin/contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL1.sol";
```

[Arbitrum](https://arbitrum.io/) specialization or the
[`CrossChainEnabled`](#CrossChainEnabled) abstraction the L1 side (mainnet).

This version should only be deployed on L1 to process cross-chain messages
originating from L2. For the other side, use [`CrossChainEnabledArbitrumL2`](#CrossChainEnabledArbitrumL2).

The bridge contract is provided and maintained by the arbitrum team. You can
find the address of this contract on the rinkeby testnet in
[Arbitrum's developer documentation](https://developer.offchainlabs.com/docs/useful_addresses).

_Available since v4.6._

### Functions
- [constructor(bridge)](#CrossChainEnabledArbitrumL1-constructor-address-)
- [_isCrossChain()](#CrossChainEnabledArbitrumL1-_isCrossChain--)
- [_crossChainSender()](#CrossChainEnabledArbitrumL1-_crossChainSender--)

#### CrossChainEnabled

<a id="CrossChainEnabledArbitrumL1-constructor-address-"></a>

### `constructor(address bridge)`
*internal*

<a id="CrossChainEnabledArbitrumL1-_isCrossChain--"></a>

### `_isCrossChain() ‚Üí bool`
*internal*

see [`CrossChainEnabled._isCrossChain`](#CrossChainEnabled-_isCrossChain--)

<a id="CrossChainEnabledArbitrumL1-_crossChainSender--"></a>

### `_crossChainSender() ‚Üí address`
*internal*

see [`CrossChainEnabled._crossChainSender`](#CrossChainEnabled-_crossChainSender--)

<a id="CrossChainEnabledArbitrumL2"></a>

## `CrossChainEnabledArbitrumL2` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.6/contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL2.sol)

```solidity
import "@openzeppelin/contracts/crosschain/arbitrum/CrossChainEnabledArbitrumL2.sol";
```

[Arbitrum](https://arbitrum.io/) specialization or the
[`CrossChainEnabled`](#CrossChainEnabled) abstraction the L2 side (arbitrum).

This version should only be deployed on L2 to process cross-chain messages
originating from L1. For the other side, use [`CrossChainEnabledArbitrumL1`](#CrossChainEnabledArbitrumL1).

Arbitrum L2 includes the `ArbSys` contract at a fixed address. Therefore,
this specialization of [`CrossChainEnabled`](#CrossChainEnabled) does not include a constructor.

_Available since v4.6._

WARNING: There is currently a bug in Arbitrum that causes this contract to
fail to detect cross-chain calls when deployed behind a proxy. This will be
fixed when the network is upgraded to Arbitrum Nitro, currently scheduled for
August 31st 2022.

### Functions
- [_isCrossChain()](#CrossChainEnabledArbitrumL2-_isCrossChain--)
- [_crossChainSender()](#CrossChainEnabledArbitrumL2-_crossChainSender--)

#### CrossChainEnabled

<a id="CrossChainEnabledArbitrumL2-_isCrossChain--"></a>

### `_isCrossChain() ‚Üí bool`
*internal*

see [`CrossChainEnabled._isCrossChain`](#CrossChainEnabled-_isCrossChain--)

<a id="CrossChainEnabledArbitrumL2-_crossChainSender--"></a>

### `_crossChainSender() ‚Üí address`
*internal*

see [`CrossChainEnabled._crossChainSender`](#CrossChainEnabled-_crossChainSender--)

<a id="LibArbitrumL1"></a>

## `LibArbitrumL1` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.6/contracts/crosschain/arbitrum/LibArbitrumL1.sol)

```solidity
import "@openzeppelin/contracts/crosschain/arbitrum/LibArbitrumL1.sol";
```

Primitives for cross-chain aware contracts for
[Arbitrum](https://arbitrum.io/).

This version should only be used on L1 to process cross-chain messages
originating from L2. For the other side, use [`LibArbitrumL2`](#LibArbitrumL2).

### Functions
- [isCrossChain(bridge)](#LibArbitrumL1-isCrossChain-address-)
- [crossChainSender(bridge)](#LibArbitrumL1-crossChainSender-address-)

<a id="LibArbitrumL1-isCrossChain-address-"></a>

### `isCrossChain(address bridge) ‚Üí bool`
*internal*

Returns whether the current function call is the result of a
cross-chain message relayed by the `bridge`.

<a id="LibArbitrumL1-crossChainSender-address-"></a>

### `crossChainSender(address bridge) ‚Üí address`
*internal*

Returns the address of the sender that triggered the current
cross-chain message through the `bridge`.

NOTE: [`LibAMB.isCrossChain`](#LibAMB-isCrossChain-address-) should be checked before trying to recover the
sender, as it will revert with `NotCrossChainCall` if the current
function call is not the result of a cross-chain message.

<a id="LibArbitrumL2"></a>

## `LibArbitrumL2` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.6/contracts/crosschain/arbitrum/LibArbitrumL2.sol)

```solidity
import "@openzeppelin/contracts/crosschain/arbitrum/LibArbitrumL2.sol";
```

Primitives for cross-chain aware contracts for
[Arbitrum](https://arbitrum.io/).

This version should only be used on L2 to process cross-chain messages
originating from L1. For the other side, use [`LibArbitrumL1`](#LibArbitrumL1).

WARNING: There is currently a bug in Arbitrum that causes this contract to
fail to detect cross-chain calls when deployed behind a proxy. This will be
fixed when the network is upgraded to Arbitrum Nitro, currently scheduled for
August 31st 2022.

### Functions
- [isCrossChain(arbsys)](#LibArbitrumL2-isCrossChain-address-)
- [crossChainSender(arbsys)](#LibArbitrumL2-crossChainSender-address-)
- [ARBSYS()](#LibArbitrumL2-ARBSYS-address)

<a id="LibArbitrumL2-isCrossChain-address-"></a>

### `isCrossChain(address arbsys) ‚Üí bool`
*internal*

<a id="LibArbitrumL2-crossChainSender-address-"></a>

### `crossChainSender(address arbsys) ‚Üí address`
*internal*

Returns the address of the sender that triggered the current
cross-chain message through `arbsys`.

NOTE: [`LibAMB.isCrossChain`](#LibAMB-isCrossChain-address-) should be checked before trying to recover the
sender, as it will revert with `NotCrossChainCall` if the current
function call is not the result of a cross-chain message.

<a id="LibArbitrumL2-ARBSYS-address"></a>

### `ARBSYS() ‚Üí address`
*public*

Returns whether the current function call is the result of a
cross-chain message relayed by `arbsys`.

<a id="NotCrossChainCall--"></a>

## `NotCrossChainCall` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.6/contracts/crosschain/errors.sol)

```solidity
import "@openzeppelin/contracts/crosschain/errors.sol";
```

<a id="NotCrossChainCall--"></a>

### `NotCrossChainCall()`
*error*

<a id="InvalidCrossChainSender-address-address-"></a>

## `InvalidCrossChainSender` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.6/contracts/crosschain/errors.sol)

```solidity
import "@openzeppelin/contracts/crosschain/errors.sol";
```

<a id="InvalidCrossChainSender-address-address-"></a>

### `InvalidCrossChainSender(address actual, address expected)`
*error*

<a id="CrossChainEnabledOptimism"></a>

## `CrossChainEnabledOptimism` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.6/contracts/crosschain/optimism/CrossChainEnabledOptimism.sol)

```solidity
import "@openzeppelin/contracts/crosschain/optimism/CrossChainEnabledOptimism.sol";
```

[Optimism](https://www.optimism.io/) specialization or the
[`CrossChainEnabled`](#CrossChainEnabled) abstraction.

The messenger (`CrossDomainMessenger`) contract is provided and maintained by
the optimism team. You can find the address of this contract on mainnet and
kovan in the [deployments section of Optimism monorepo](https://github.com/ethereum-optimism/optimism/tree/develop/packages/contracts/deployments).

_Available since v4.6._

### Functions
- [constructor(messenger)](#CrossChainEnabledOptimism-constructor-address-)
- [_isCrossChain()](#CrossChainEnabledOptimism-_isCrossChain--)
- [_crossChainSender()](#CrossChainEnabledOptimism-_crossChainSender--)

#### CrossChainEnabled

<a id="CrossChainEnabledOptimism-constructor-address-"></a>

### `constructor(address messenger)`
*internal*

<a id="CrossChainEnabledOptimism-_isCrossChain--"></a>

### `_isCrossChain() ‚Üí bool`
*internal*

see [`CrossChainEnabled._isCrossChain`](#CrossChainEnabled-_isCrossChain--)

<a id="CrossChainEnabledOptimism-_crossChainSender--"></a>

### `_crossChainSender() ‚Üí address`
*internal*

see [`CrossChainEnabled._crossChainSender`](#CrossChainEnabled-_crossChainSender--)

<a id="LibOptimism"></a>

## `LibOptimism` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.6/contracts/crosschain/optimism/LibOptimism.sol)

```solidity
import "@openzeppelin/contracts/crosschain/optimism/LibOptimism.sol";
```

Primitives for cross-chain aware contracts for [Optimism](https://www.optimism.io/).
See the [documentation](https://community.optimism.io/docs/developers/bridge/messaging/#accessing-msg-sender)
for the functionality used here.

### Functions
- [isCrossChain(messenger)](#LibOptimism-isCrossChain-address-)
- [crossChainSender(messenger)](#LibOptimism-crossChainSender-address-)

<a id="LibOptimism-isCrossChain-address-"></a>

### `isCrossChain(address messenger) ‚Üí bool`
*internal*

Returns whether the current function call is the result of a
cross-chain message relayed by `messenger`.

<a id="LibOptimism-crossChainSender-address-"></a>

### `crossChainSender(address messenger) ‚Üí address`
*internal*

Returns the address of the sender that triggered the current
cross-chain message through `messenger`.

NOTE: [`LibAMB.isCrossChain`](#LibAMB-isCrossChain-address-) should be checked before trying to recover the
sender, as it will revert with `NotCrossChainCall` if the current
function call is not the result of a cross-chain message.

<a id="DEFAULT_SENDER-address"></a>

## `DEFAULT_SENDER` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.6/contracts/crosschain/polygon/CrossChainEnabledPolygonChild.sol)

```solidity
import "@openzeppelin/contracts/crosschain/polygon/CrossChainEnabledPolygonChild.sol";
```

<a id="CrossChainEnabledPolygonChild"></a>

## `CrossChainEnabledPolygonChild` [üìÅ](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.6/contracts/crosschain/polygon/CrossChainEnabledPolygonChild.sol)

```solidity
import "@openzeppelin/contracts/crosschain/polygon/CrossChainEnabledPolygonChild.sol";
```

[Polygon](https://polygon.technology/) specialization or the
[`CrossChainEnabled`](#CrossChainEnabled) abstraction the child side (polygon/mumbai).

This version should only be deployed on child chain to process cross-chain
messages originating from the parent chain.

The fxChild contract is provided and maintained by the polygon team. You can
find the address of this contract polygon and mumbai in
[Polygon's Fx-Portal documentation](https://docs.polygon.technology/docs/develop/l1-l2-communication/fx-portal/#contract-addresses).

_Available since v4.6._

### Functions
- [constructor(fxChild)](#CrossChainEnabledPolygonChild-constructor-address-)
- [_isCrossChain()](#CrossChainEnabledPolygonChild-_isCrossChain--)
- [_crossChainSender()](#CrossChainEnabledPolygonChild-_crossChainSender--)
- [processMessageFromRoot(, rootMessageSender, data)](#CrossChainEnabledPolygonChild-processMessageFromRoot-uint256-address-bytes-)

#### ReentrancyGuard
- [_reentrancyGuardEntered()](#ReentrancyGuard-_reentrancyGuardEntered--)

#### CrossChainEnabled

#### IFxMessageProcessor

<a id="CrossChainEnabledPolygonChild-constructor-address-"></a>

### `constructor(address fxChild)`
*internal*

<a id="CrossChainEnabledPolygonChild-_isCrossChain--"></a>

### `_isCrossChain() ‚Üí bool`
*internal*

see [`CrossChainEnabled._isCrossChain`](#CrossChainEnabled-_isCrossChain--)

<a id="CrossChainEnabledPolygonChild-_crossChainSender--"></a>

### `_crossChainSender() ‚Üí address`
*internal*

see [`CrossChainEnabled._crossChainSender`](#CrossChainEnabled-_crossChainSender--)

<a id="CrossChainEnabledPolygonChild-processMessageFromRoot-uint256-address-bytes-"></a>

### `processMessageFromRoot(uint256, address rootMessageSender, bytes data)`
*external*

External entry point to receive and relay messages originating
from the fxChild.

Non-reentrancy is crucial to avoid a cross-chain call being able
to impersonate anyone by just looping through this with user-defined
arguments.

Note: if _fxChild calls any other function that does a delegate-call,
then security could be compromised.

