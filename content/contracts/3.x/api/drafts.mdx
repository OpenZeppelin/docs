---
title: Draft EIPs
---

This directory contains implementations of EIPs that are still in Draft status.

Due to their nature as drafts, the details of these contracts may change and we cannot guarantee their [stability](/contracts/3.x/releases-stability). Minor releases of OpenZeppelin Contracts may contain breaking changes for the contracts in this directory, which will be duly announced in the [changelog](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/CHANGELOG.md). The EIPs included here are used by projects in production and this may make them less likely to change significantly.

## Cryptography

### ``EIP712``

[EIP 712](https://eips.ethereum.org/EIPS/eip-712) is a standard for hashing and signing of typed structured data.

The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,
thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding
they need in their contracts using a combination of `abi.encode` and `keccak256`.

This contract implements the EIP 712 domain separator (_domainSeparatorV4) that is used as part of the encoding
scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA
(_hashTypedDataV4).

The implementation of the domain separator was designed to be as efficient as possible while still properly updating
the chain id to protect against replay attacks on an eventual fork of the chain.

<Callout>
This contract implements the version of the encoding known as "v4", as implemented by the JSON RPC method
[`eth_signTypedDataV4` in MetaMask](https://docs.metamask.io/guide/signing-data.html).
</Callout>

_Available since v3.4._

**Functions**

* [`constructor(name, version)`](#EIP712-constructor-string-string-)
* [`_domainSeparatorV4()`](#EIP712-_domainSeparatorV4)
* [`_hashTypedDataV4(structHash)`](#EIP712-_hashTypedDataV4-bytes32-)

<a id="EIP712-constructor"></a>

#### `constructor(string name, string version) *internal*`

Initializes the domain separator and parameter caches.

The meaning of `name` and `version` is specified in
[EIP 712](https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator):

* `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.
* `version`: the current major version of the signing domain.

<Callout>
These parameters cannot be changed except through a [smart
contract upgrade](/contracts/5.x/learn/upgrading-smart-contracts).
</Callout>

<a id="EIP712-_domainSeparatorV4"></a>

#### `_domainSeparatorV4() → bytes32 *internal*`

Returns the domain separator for the current chain.

<a id="EIP712-_hashTypedDataV4"></a>

#### `_hashTypedDataV4(bytes32 structHash) → bytes32 *internal*`

Given an already [hashed struct](https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct), this
function returns the hash of the fully encoded EIP712 message for this domain.

This hash can be used together with ECDSA-recover to obtain the signer of a message. For example:

```solidity
bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
    keccak256("Mail(address to,string contents)"),
    mailTo,
    keccak256(bytes(mailContents))
)));
address signer = ECDSA.recover(digest, signature);
```

## ERC 20

### ``IERC20Permit``

Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
[EIP-2612](https://eips.ethereum.org/EIPS/eip-2612).

Adds the permit method, which can be used to change an account’s ERC20 allowance (see IERC20-allowance) by
presenting a message signed by the account. By not relying on `IERC20-approve`, the token holder account doesn’t
need to send a transaction, and thus is not required to hold Ether at all.

**Functions**

* [`permit(owner, spender, value, deadline, v, r, s)`](#IERC20Permit-permit-address-address-uint256-uint256-uint8-bytes32-bytes32-)
* [`nonces(owner)`](#IERC20Permit-nonces-address-)
* [`DOMAIN_SEPARATOR()`](#IERC20Permit-DOMAIN_SEPARATOR)

<a id="EIP712-permit"></a>

#### `permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) *external*`

Sets `value` as the allowance of `spender` over `owner’s tokens,
given `owner’s signed approval.

<Callout type='warn'>
The same issues IERC20-approve has related to transaction
ordering also apply here.
</Callout>

Emits an Approval event.

Requirements:

* `spender` cannot be the zero address.
* `deadline` must be a timestamp in the future.
* `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
over the EIP712-formatted function arguments.
* the signature must use ``owner`’s current nonce (see nonces).

For more information on the signature format, see the
https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
section].

<a id="EIP712-nonces"></a>

#### `nonces(address owner) → uint256 *external*`

Returns the current nonce for `owner`. This value must be
included whenever a signature is generated for permit.

Every successful call to permit increases ``owner`’s nonce by one. This
prevents a signature from being used multiple times.

<a id="EIP712-DOMAIN_SEPARATOR"></a>

#### `DOMAIN_SEPARATOR() → bytes32 *external*`

Returns the domain separator used in the encoding of the signature for `permit`, as defined by EIP712.

### ``ERC20Permit``

Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
[EIP-2612](https://eips.ethereum.org/EIPS/eip-2612).

Adds the permit method, which can be used to change an account’s ERC20 allowance (see IERC20-allowance) by
presenting a message signed by the account. By not relying on `IERC20-approve`, the token holder account doesn’t
need to send a transaction, and thus is not required to hold Ether at all.

_Available since v3.4._

**Functions**

* [`constructor(name)`](#ERC20Permit-constructor-string-)
* [`permit(owner, spender, value, deadline, v, r, s)`](#ERC20Permit-permit-address-address-uint256-uint256-uint8-bytes32-bytes32-)
* [`nonces(owner)`](#ERC20Permit-nonces-address-)
* [`DOMAIN_SEPARATOR()`](#ERC20Permit-DOMAIN_SEPARATOR)

**EIP712**

* [`_domainSeparatorV4()`](#EIP712-_domainSeparatorV4)
* [`_hashTypedDataV4(structHash)`](#EIP712-_hashTypedDataV4-bytes32-)

**ERC20**

* [`name()`](#ERC20-name)
* [`symbol()`](#ERC20-symbol)
* [`decimals()`](#ERC20-decimals)
* [`totalSupply()`](#ERC20-totalSupply)
* [`balanceOf(account)`](#ERC20-balanceOf-address-)
* [`transfer(recipient, amount)`](#ERC20-transfer-address-uint256-)
* [`allowance(owner, spender)`](#ERC20-allowance-address-address-)
* [`approve(spender, amount)`](#ERC20-approve-address-uint256-)
* [`transferFrom(sender, recipient, amount)`](#ERC20-transferFrom-address-address-uint256-)
* [`increaseAllowance(spender, addedValue)`](#ERC20-increaseAllowance-address-uint256-)
* [`decreaseAllowance(spender, subtractedValue)`](#ERC20-decreaseAllowance-address-uint256-)
* [`_transfer(sender, recipient, amount)`](#ERC20-_transfer-address-address-uint256-)
* [`_mint(account, amount)`](#ERC20-_mint-address-uint256-)
* [`_burn(account, amount)`](#ERC20-_burn-address-uint256-)
* [`_approve(owner, spender, amount)`](#ERC20-_approve-address-address-uint256-)
* [`_setupDecimals(decimals_)`](#ERC20-_setupDecimals-uint8-)
* [`_beforeTokenTransfer(from, to, amount)`](#ERC20-_beforeTokenTransfer-address-address-uint256-)

**Events**

**IERC20**

* [`Transfer(from, to, value)`](#IERC20-Transfer-address-address-uint256-)
* [`Approval(owner, spender, value)`](#IERC20-Approval-address-address-uint256-)

<a id="EIP712-constructor"></a>

#### `constructor(string name) *internal*`

Initializes the EIP712 domain separator using the `name` parameter, and setting `version` to `"1"`.

It’s a good idea to use the same `name` that is defined as the ERC20 token name.

<a id="EIP712-permit"></a>

#### `permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) *public*`

See IERC20Permit-permit.

<a id="EIP712-nonces"></a>

#### `nonces(address owner) → uint256 *public*`

See IERC20Permit-nonces.

<a id="EIP712-DOMAIN_SEPARATOR"></a>

#### `DOMAIN_SEPARATOR() → bytes32 *external*`

See IERC20Permit-DOMAIN_SEPARATOR.
